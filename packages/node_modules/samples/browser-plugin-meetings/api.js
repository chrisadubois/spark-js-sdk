// ------- Required configurations ---------
if (typeof wasmBinaryFile === 'undefined') {
  var wasmBinaryFile = 'denoise_ulp_08182020_nosimd.wasm';
}

//------------------------------------------------------
//------------------------------------------------------
//
//  Javascript code genertaed from emcc
//
//------------------------------------------------------
var Module = typeof Module !== 'undefined' ? Module : {};
let moduleOverrides = {};
let key;

for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}
let arguments_ = [];
const ENVIRONMENT_IS_WEB = typeof window === 'object';

if (!ENVIRONMENT_IS_WEB) {
  abort('can only run from web');
}
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
moduleOverrides = null;
if (Module.arguments) arguments_ = Module.arguments;
if (typeof WebAssembly !== 'object') {
  abort('no native wasm support detected');
}
let wasmMemory;
const wasmTable = new WebAssembly.Table({
  initial: 1,
  maximum: 1 + 0,
  element: 'anyfunc'
});


function getCFunc(ident) {
  const func = Module[`_${ident}`];

  if (!func) throw `Cannot call unknown function ${ident}, make sure it is exported`;

  return func;
}

function ccall(ident, returnType, argTypes, args, opts) {
  const toC = {
    string(str) {
      let ret = 0;

      if (str !== null && str !== undefined && str !== 0) {
        const len = (str.length << 2) + 1;

        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }

      return ret;
    },
    array(arr) {
      const ret = stackAlloc(arr.length);

      writeArrayToMemory(arr, ret);

      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);

    return ret;
  }
  const func = getCFunc(ident);
  const cArgs = [];
  let stack = 0;

  if (args) {
    for (let i = 0; i < args.length; i++) {
      const converter = toC[argTypes[i]];

      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      }
      else {
        cArgs[i] = args[i];
      }
    }
  }
  let ret = func.apply(null, cArgs);

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);

  return ret;
}

function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  const numericArgs = argTypes.every((type) => type === 'number');
  const numericRet = returnType !== 'string';

  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }

  return function () {
    return ccall(ident, returnType, argTypes, arguments, opts);
  };
}
const UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  const endIdx = idx + maxBytesToRead;
  let endPtr = idx;

  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  }
  let str = '';

  while (idx < endPtr) {
    let u0 = heap[idx++];

    if (!(u0 & 128)) {
      str += String.fromCharCode(u0);
      continue;
    }
    const u1 = heap[idx++] & 63;

    if ((u0 & 224) == 192) {
      str += String.fromCharCode((u0 & 31) << 6 | u1);
      continue;
    }
    const u2 = heap[idx++] & 63;

    if ((u0 & 240) == 224) {
      u0 = (u0 & 15) << 12 | u1 << 6 | u2;
    }
    else {
      u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
    }
    if (u0 < 65536) {
      str += String.fromCharCode(u0);
    }
    else {
      const ch = u0 - 65536;

      str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
    }
  }

  return str;
}

function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) return 0;
  const startIdx = outIdx;
  const endIdx = outIdx + maxBytesToWrite - 1;

  for (let i = 0; i < str.length; ++i) {
    let u = str.charCodeAt(i);

    if (u >= 55296 && u <= 57343) {
      const u1 = str.charCodeAt(++i);

      u = 65536 + ((u & 1023) << 10) | u1 & 1023;
    }
    if (u <= 127) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    }
    else if (u <= 2047) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 192 | u >> 6;
      heap[outIdx++] = 128 | u & 63;
    }
    else if (u <= 65535) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 224 | u >> 12;
      heap[outIdx++] = 128 | u >> 6 & 63;
      heap[outIdx++] = 128 | u & 63;
    }
    else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 240 | u >> 18;
      heap[outIdx++] = 128 | u >> 12 & 63;
      heap[outIdx++] = 128 | u >> 6 & 63;
      heap[outIdx++] = 128 | u & 63;
    }
  }
  heap[outIdx] = 0;

  return outIdx - startIdx;
}

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}
const WASM_PAGE_SIZE = 65536;
let buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module.HEAP8 = HEAP8 = new Int8Array(buf);
  Module.HEAP16 = HEAP16 = new Int16Array(buf);
  Module.HEAP32 = HEAP32 = new Int32Array(buf);
  Module.HEAPU8 = HEAPU8 = new Uint8Array(buf);
  Module.HEAPU16 = HEAPU16 = new Uint16Array(buf);
  Module.HEAPU32 = HEAPU32 = new Uint32Array(buf);
  Module.HEAPF32 = HEAPF32 = new Float32Array(buf);
  Module.HEAPF64 = HEAPF64 = new Float64Array(buf);
}
const DYNAMIC_BASE = 5920624;
const DYNAMICTOP_PTR = 677584;
let INITIAL_INITIAL_MEMORY = Module.INITIAL_MEMORY || 16777216;

if (Module.wasmMemory) {
  wasmMemory = Module.wasmMemory;
}
else {
  wasmMemory = new WebAssembly.Memory({
    initial: INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
    maximum: INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
  });
}
if (wasmMemory) {
  buffer = wasmMemory.buffer;
}
INITIAL_INITIAL_MEMORY = buffer.byteLength;
updateGlobalBufferAndViews(buffer);
HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;

function callRuntimeCallbacks(callbacks) {
  while (callbacks.length > 0) {
    const callback = callbacks.shift();

    if (typeof callback === 'function') {
      callback(Module);
      continue;
    }
    const {func} = callback;

    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module.dynCall_v(func);
      }
      else {
        Module.dynCall_vi(func, callback.arg);
      }
    }
    else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}
const __ATPRERUN__ = [];
const __ATINIT__ = [];
const __ATMAIN__ = [];
const __ATPOSTRUN__ = [];
const runtimeInitialized = false;

let runDependencies = 0;
let runDependencyWatcher = null;

function addRunDependency(id) {
  runDependencies++;
  if (Module.monitorRunDependencies) {
    Module.monitorRunDependencies(runDependencies);
  }
}

function removeRunDependency(id) {
  runDependencies--;
  if (Module.monitorRunDependencies) {
    Module.monitorRunDependencies(runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
  }
}
Module.preloadedImages = {};
Module.preloadedAudios = {};

function abort(what) {
  what += '';
  what = `abort(${what}). Build with -s ASSERTIONS=1 for more info.`;
  const e = new WebAssembly.RuntimeError(what);

  throw e;
}

function getBinaryPromise() {
  return fetch(wasmBinaryFile, {
    credentials: 'same-origin'
  }).then((response) => {
    if (!response.ok) {
      throw `failed to load wasm binary file at ${wasmBinaryFile}`;
    }

    return response.arrayBuffer();
  }).catch(() => {
    throw `failed to load wasm binary file at ${wasmBinaryFile}`;
  });
}

function createWasm(test_action) {
  const info = {
    a: asmLibraryArg
  };

  function receiveInstance(instance, module) {
    Module.asm = instance.exports;
    removeRunDependency('wasm-instantiate');
    test_action();
  }
  addRunDependency('wasm-instantiate');

  function receiveInstantiatedSource(output) {
    receiveInstance(output.instance);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then((binary) => WebAssembly.instantiate(binary, info)).then(receiver, (reason) => {
      throw 'failed to create WASM';
    });
  }

  instantiateArrayBuffer(receiveInstantiatedSource);

  return {};
}
__ATINIT__.push({
  func() {
    ___wasm_call_ctors();
  }
});

function _emscripten_date_now() {
  return Date.now();
}

function _emscripten_memcpy_big(dest, src, num) {
  HEAPU8.copyWithin(dest, src, src + num);
}

function abortOnCannotGrowMemory(requestedSize) {
  abort('OOM');
}

function _emscripten_resize_heap(requestedSize) {
  requestedSize >>>= 0;
  abortOnCannotGrowMemory(requestedSize);
}
var asmLibraryArg = {
  c: _emscripten_date_now,
  a: _emscripten_memcpy_big,
  b: _emscripten_resize_heap,
  memory: wasmMemory,
  table: wasmTable
};
/*
function action()
{
        versionBtn();
        initBtn();
        processBtn();
}
window.addEventListener('load', (event) => {
   var asm = createWasm(action);
});
*/
var ___wasm_call_ctors = Module.___wasm_call_ctors = function () {
  return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.d).apply(null, arguments);
};
var _Initialize = Module._Initialize = function () {
  return (_Initialize = Module._Initialize = Module.asm.e).apply(null, arguments);
};
var _Process_Block = Module._Process_Block = function () {
  return (_Process_Block = Module._Process_Block = Module.asm.f).apply(null, arguments);
};
var _Destroy = Module._Destroy = function () {
  return (_Destroy = Module._Destroy = Module.asm.g).apply(null, arguments);
};
var _Clearedge_Version = Module._Clearedge_Version = function () {
  return (_Clearedge_Version = Module._Clearedge_Version = Module.asm.h).apply(null, arguments);
};
var _ClearEdgeMalloc = Module._ClearEdgeMalloc = function () {
  return (_ClearEdgeMalloc = Module._ClearEdgeMalloc = Module.asm.i).apply(null, arguments);
};
var _ClearEdgeFree = Module._ClearEdgeFree = function () {
  return (_ClearEdgeFree = Module._ClearEdgeFree = Module.asm.j).apply(null, arguments);
};
var stackSave = Module.stackSave = function () {
  return (stackSave = Module.stackSave = Module.asm.k).apply(null, arguments);
};
var stackRestore = Module.stackRestore = function () {
  return (stackRestore = Module.stackRestore = Module.asm.l).apply(null, arguments);
};
var stackAlloc = Module.stackAlloc = function () {
  return (stackAlloc = Module.stackAlloc = Module.asm.m).apply(null, arguments);
};

Module.cwrap = cwrap;

//----------------------------------------------------
// ClearEdge APIS
//---------------------------------------------------
if (typeof ClearEdgeAPIDefined === 'undefined') {
  var ClearEdgeAPIDefined = true;
  // functions defined in WASM
  const bblWasmClearEdgeVersion = Module.cwrap('Clearedge_Version', 'string', []);
  const bblWasmDestroy = Module.cwrap('Destroy', null, ['number']);
  const bblWasmInitialize = Module.cwrap('Initialize', 'number', ['number', 'number']);
  const bblWasmProcessBlock = Module.cwrap('Process_Block', null, ['number', 'number', 'number']);
  const bblWasmMalloc = Module.cwrap('ClearEdgeMalloc', 'number', ['number']);
  const bblWasmFree = Module.cwrap('ClearEdgeFree', 'number', ['number']);

  // API functions
  // returns a string -- Clear Edge version description
  function Clearedge_Version() {
    return bblWasmClearEdgeVersion();
  }
  // cleanup - completes silently
  function Clearedge_Destroy(handle) {
    if (handle) {
      if (handle.handle) bblWasmDestroy(handle.handle);
      if (handle.input_buffer) bblWasmFree(handle.input_buffer);
      if (handle.output_buffer) bblWasmFree(handle.output_buffer);
      handle.handle = null;
      handle.input_buffer = null;
      handle.output_buffer = null;
    }
  }
  // Initialize network
  // return Babblelabs Handle Object
  //    { handle :         --- WASM pipe
  //      input_buffer:    --- float[]
  //      output_buffer:   --- float[]
  //      frame_size:      --- number
  //      sample_rate:     --- number
  //      nbytes:          --- per sample data
  //    }
  function Clearedge_Initialize(sample_rate, frame_size) {
    const nBytes = 4;

    if (sample_rate != 16000 && sample_rate != 32000 && sample_rate != 48000) {
      console.log(`sample_rate (${sample_rate}) must be one of (16000, 32000, 48000)`);

      return null;
    }
    if (false && frame_size < 128) {
      console.log(`frame_size(${frame_size}) must be at least 128`);

      return null;
    }
    const INPUT_BUFFER = bblWasmMalloc(frame_size * nBytes);
    const OUTPUT_BUFFER = bblWasmMalloc(frame_size * nBytes);
    const HANDLE = bblWasmInitialize(sample_rate, frame_size);

    return {
      handle: HANDLE, input_buffer: INPUT_BUFFER, output_buffer: OUTPUT_BUFFER, frame_size, sample_rate, nbytes: nBytes
    };
  }
  // Process
  // in_buf & out_buf can be null
  function Clearedge_Process_Block(handle, in_buf, out_buf) {
    if (handle) {
      // copy input buffer
      if (in_buf) Module.HEAPF32.set(in_buf, handle.input_buffer / handle.nbytes);
      bblWasmProcessBlock(handle.handle, handle.input_buffer, handle.output_buffer);
      // copy output buffer
      if (out_buf) {
        out_arr = new Float32Array(Module.HEAPF32.buffer, handle.output_buffer, handle.frame_size);
        for (let i = 0; i < handle.frame_size; ++i) out_buf[i] = out_arr[i];
      }
    }
  }
}

