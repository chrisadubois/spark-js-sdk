// import RingBuffer from "./ring-buffer";
function lcd(x, y) {
  return Math.abs((x * y) / gcd(x, y));
}

function gcd(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  while (y) {
    const t = y;

    y = x % y;
    x = t;
  }

  return x;
}

class RingBuffer {
  buffer = 0;

  chunkSize = 0;

  readOffset = 0;

  writeOffset = 0;

  available = 0;

  writeSize = 0;

  readSize = 0;

  constructor(
    writeSize,
    readSize,
    length
  ) {
    this.writeSize = writeSize;
    this.readSize = readSize;
    this.chunkSize = lcd(writeSize, readSize);
    this.buffer = new Float32Array(this.chunkSize * length);
  }

  write(data) {
    this.buffer.set(data, this.writeOffset);
    this.writeOffset = (this.writeOffset + this.writeSize) % this.buffer.length;
    this.available += this.writeSize;
  }

  read() {
    const readView = this.buffer.subarray(
      this.readOffset,
      this.readOffset + this.readSize
    );

    this.available -= this.readSize;
    this.readOffset = (this.readOffset + this.readSize) % this.buffer.length;

    return readView;
  }

  get readsAvailable() {
    return Math.trunc(this.available / this.readSize);
  }
}
//-----
window.onload = function () {
  const frameLenMs = 20;
  const sampleRate = 48000;
  const frameSize = (sampleRate / 1000) * frameLenMs; // samples @16000 samples/sec

  console.log(`frameSize=${frameSize}`);
  const bufferSize = 512;
  const floatConversionBuffer = new Float32Array(frameSize);
  const inputRing = new RingBuffer(bufferSize, frameSize, 4);
  const outputRing = new RingBuffer(frameSize, bufferSize, 4);

  console.log(inputRing);
  console.log(outputRing);
  const removeNoiseCheckbox = document.getElementById('remove-noise-checkbox');
  const startButton = document.getElementById('start');
  const inputDeviceSelect = document.getElementById('input-device');
  const outputDeviceSelect = document.getElementById('output-device');
  const sampleRateDiv = document.getElementById('sample-rate');
  const timingDiv = document.getElementById('timing');

  let outPCM;
  let wasm;
  let removeNoise = removeNoiseCheckbox.checked;
  let processTime = 0;
  let wasmTime = 0;
  let reportedSampleRate = 0;
  const defaultSampleRate = new AudioContext().sampleRate;

  removeNoiseCheckbox.addEventListener('change', () => {
    removeNoise = removeNoiseCheckbox.checked;
  });

  startButton.addEventListener('click', () => {
    startButton.disabled = true;
    start();
  });

  setInterval(() => {
    timingDiv.innerHTML = `WASM: ${wasmTime}, TOTAL: ${processTime}`;
    sampleRateDiv.innerHTML = `DefaultSampleRate: ${defaultSampleRate} SampleRate: ${reportedSampleRate}`;
  }, 200);

  async function loadWebAssembly(fileName) {
    const response = await fetch(fileName);
    const wasm = await WebAssembly.instantiate(await response.arrayBuffer());

    return wasm.instance.exports;
  }

  stopit = false;
  function processAudio(event) {
    const startTime = performance.now();

    try {
      const input = event.inputBuffer.getChannelData(0);
      const output = event.outputBuffer.getChannelData(0);

      inputRing.write(input);
      if (!stopit) {
        stopit = true;
        console.log(inputRing);
      }
      while (inputRing.readsAvailable) {
        const frameBuffer = inputRing.read();

        if (removeNoise) {
          const wasmStart = performance.now();

          Clearedge_Process_Block(HANDLEP, frameBuffer, outPCM);
          wasmTime = performance.now() - wasmStart;
        }
        else {
          wasmTime = 0;
        }
        outputRing.write(removeNoise ? outPCM : frameBuffer);
      }

      if (outputRing.readsAvailable) {
        output.set(outputRing.read());
      }

      processTime = performance.now() - startTime;
    }
    catch (e) {
      console.error(e);
    }
  }

  async function start_test() {
    HANDLEP = Clearedge_Initialize(sampleRate, frameSize);
    console.log(HANDLEP);
    outPCM = new Float32Array(frameSize);
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        deviceId: {exact: inputDeviceSelect.value},
        sampleRate: 48000,
        channelCount: 1
      }
    });

    const ac = window.AudioContext || window.webkitAudioContext;
    let audioContext;
    let srcNode;

    try {
      audioContext = new ac({sampleRate});
      srcNode = audioContext.createMediaStreamSource(stream);
    }
    catch (_) {
      audioContext = new ac();
      srcNode = audioContext.createMediaStreamSource(stream);
    }

    reportedSampleRate = audioContext.sampleRate;
    const audio = document.createElement('audio');

    srcNode = audioContext.createMediaStreamSource(stream);
    const processorNode = audioContext.createScriptProcessor(bufferSize, 1, 1);
    const dstNode = audioContext.createMediaStreamDestination();

    processorNode.addEventListener('audioprocess', processAudio);

    srcNode.connect(processorNode);
    processorNode.connect(dstNode);
    audio.srcObject = dstNode.stream;
    if ('setSinkId' in audio) audio.setSinkId(outputDeviceSelect.value);
    audio.play();
  }

  async function start() {
    const asm = createWasm(start_test);
  }

  async function main() {
    const stream = await navigator.mediaDevices.getUserMedia({audio: true});

    stream.getTracks((t) => {
      stream.removeTrack(t);
      t.stop();
    });

    const devices = await navigator.mediaDevices.enumerateDevices();

    // console.log(devices);
    devices
      .filter((d) => d.kind === 'audiooutput')
      .forEach((d) => {
        const option = document.createElement('option');

        option.value = d.deviceId;
        option.text = d.label;
        outputDeviceSelect.appendChild(option);
      });
    devices
      .filter((d) => d.kind === 'audioinput')
      .forEach((d) => {
        const option = document.createElement('option');

        option.value = d.deviceId;
        option.text = d.label;
        inputDeviceSelect.appendChild(option);
      });


    startButton.removeAttribute('disabled');
  }
  main();
};
