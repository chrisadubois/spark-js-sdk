!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? e(exports) : typeof define === 'function' && define.amd ? define(['exports'], e) : e(t.faceapi = t.faceapi || {}); }(this, (t) => {
  const r = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); };

  function s(t, e) { function n() { this.constructor = t; }r(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n()); } const n = Object.assign || function (t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) for (const o in e = arguments[n])Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);

    return t;
  };

  function m(i, a, s, u) {
    return new (s || (s = Promise))(((t, e) => {
      function n(t) {
        try { o(u.next(t)); }
        catch (t) { e(t); }
      } function r(t) {
        try { o(u.throw(t)); }
        catch (t) { e(t); }
      } function o(e) { e.done ? t(e.value) : new s(((t) => { t(e.value); })).then(n, r); }o((u = u.apply(i, a || [])).next());
    }));
  } function S(n, r) {
    let o; let i; let a; let t; let s = {
      label: 0,
      sent() {
        if (1 & a[0]) throw a[1];

        return a[1];
      },
      trys: [],
      ops: []
    };

    return t = {next: e(0), throw: e(1), return: e(2)}, typeof Symbol === 'function' && (t[Symbol.iterator] = function () { return this; }), t; function e(e) {
      return function (t) {
        return (function (e) {
          if (o) throw new TypeError('Generator is already executing.'); for (;s;) {
            try { if (o = 1, i && (a = 2 & e[0] ? i.return : e[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, e[1])).done) return a; switch (i = 0, a && (e = [2 & e[0], a.value]), e[0]) { case 0: case 1: a = e; break; case 4: return s.label++, {value: e[1], done: !1}; case 5: s.label++, i = e[1], e = [0]; continue; case 7: e = s.ops.pop(), s.trys.pop(); continue; default: if (!(a = (a = s.trys).length > 0 && a[a.length - 1]) && (e[0] === 6 || e[0] === 2)) { s = 0; continue; } if (e[0] === 3 && (!a || e[1] > a[0] && e[1] < a[3])) { s.label = e[1]; break; } if (e[0] === 6 && s.label < a[1]) { s.label = a[1], a = e; break; } if (a && s.label < a[2]) { s.label = a[2], s.ops.push(e); break; }a[2] && s.ops.pop(), s.trys.pop(); continue; }e = r.call(n, s); }
            catch (t) { e = [6, t], i = 0; }
            finally { o = a = 0; }
          } if (5 & e[0]) throw e[1];

          return {value: e[0] ? e[1] : void 0, done: !0};
        }([e, t]));
      };
    }
  } function o(t) { for (let e = t.length, n = 0, r = 0; e > 0;)r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n; } function u(t, e, n) { return Math.max(t, Math.min(e, n)); } function _(t) { return t % 2 == 0 ? t : t + 1; } function c(t) {
    for (var e = 0, n = 0; n < t.length; n++)e += t[n];

    return e;
  } function a(t, e) {
    const n = Math.random();

    return e * n + (1 - n) * t;
  } function D(t, e) { if (!t) throw new Error(typeof e === 'string' ? e : e()); } function f(t, e, n) { void 0 === n && (n = ''), D(T(t, e), `${n} Shapes ${t} and ${e} must match`); } function i(t) { D(t != null, 'The input to the tensor constructor must be a non-null value.'); } function l(t, e) {
    if (void 0 === e && (e = []), Array.isArray(t)) for (let n = 0; n < t.length; ++n)l(t[n], e); else e.push(t);

    return e;
  } function B(t) {
    if (t.length === 0) return 1; for (var e = t[0], n = 1; n < t.length; n++)e *= t[n];

    return e;
  } function T(t, e) {
    if (t === e) return !0; if (t == null || e == null) return !1; if (t.length !== e.length) return !1; for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;

    return !0;
  } function N(t) { return t % 1 == 0; } function h(t) {
    if (Math.tanh != null) return Math.tanh(t); if (t === 1 / 0) return 1; if (t === -1 / 0) return -1; const e = Math.exp(2 * t);

    return (e - 1) / (e + 1);
  } function p(t) {
    for (let e = Math.floor(Math.sqrt(t)); e > 1; --e) if (t % e == 0) return [e, t / e];

    return [1, t];
  } function d(t, e) { return e <= t.length ? t : t + ' '.repeat(e - t.length); } function v(i, a, s) {
    return void 0 === a && (a = function (t) { return 0; }), new Promise(((e, n) => {
      let r = 0; var o = function () {
        if (i())e(); else {
          const t = a(++r);

          s != null && s <= r ? n() : setTimeout(o, t);
        }
      };

      o();
    }));
  } function g(t, e) {
    for (var n = 1, r = -1, o = 0; o < t.length; ++o) {
      if (t[o] >= 0)n *= t[o]; else if (t[o] === -1) { if (r !== -1) throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`); r = o; }
      else if (t[o] < 0) throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);
    } if (r === -1) {
      if (e > 0 && e !== n) throw Error(`Size(${e}) must match the product of shape ${t}`);

      return t;
    } if (n === 0) throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`); if (e % n != 0) throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`); const i = t.slice();

    return i[r] = e / n, i;
  } function y(t, e) {
    for (var n = [], r = [], o = 0, i = 0; i < t.length; ++i) { if (e != null) { if (e[o] === i && t[i] !== 1) throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`); (e[o] == null || e[o] > i) && t[i] === 1 && (n.push(t[i]), r.push(i)), e[o] <= i && o++; }t[i] !== 1 && (n.push(t[i]), r.push(i)); }

    return {newShape: n, keptDims: r};
  } function b(t, e) {
    let n = null;

    if (t == null || t === 'float32')n = new Float32Array(e); else if (t === 'int32')n = new Int32Array(e); else { if (t !== 'bool') throw new Error(`Unknown data type ${t}`); n = new Uint8Array(e); }

    return n;
  } function x(t, e, n) { if (e === 'float32') for (let r = 0; r < t.length; r++) if (isNaN(t[r])) throw Error(`The result of the '${n}' has NaNs.`); } function w(t, e) { if (e !== 'float32') for (let n = 0; n < t.length; n++) if (isNaN(t[n])) throw Error(`NaN is not a valid value for dtype: '${e}'.`); } function E(t, e) { return !(e === 'complex64' || e === 'float32' && t !== 'complex64' || e === 'int32' && t !== 'float32' && t !== 'complex64' || e === 'bool' && t === 'bool'); } function C(t) { return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array; } function R(t) { if (t === 'float32' || t === 'int32') return 4; if (t === 'complex64') return 8; if (t === 'bool') return 1; throw new Error(`Unknown dtype ${t}`); } function k(t) { return !!(t && t.constructor && t.call && t.apply); } function I(t, e) {
    for (let n = e; n < t; ++n) if (t % n == 0) return n;

    return t;
  } function A(t) {
    const e = t.length;

    if (e < 2) return []; const n = new Array(e - 1);

    n[e - 2] = t[e - 1]; for (let r = e - 3; r >= 0; --r)n[r] = n[r + 1] * t[r + 1];

    return n;
  } function M(t, e, n) {
    return o = e, (r = t) instanceof Float32Array && o === 'float32' || r instanceof Int32Array && o === 'int32' || r instanceof Uint8Array && o === 'bool' ? t : (Array.isArray(t) && (t = l(t)), (function (t, e, n) {
      if (e == null || e === 'float32' || e === 'complex64') return new Float32Array(t); if (e === 'int32') return n && w(t, e), new Int32Array(t); if (e !== 'bool') throw new Error(`Unknown data type ${e}`); for (var r = new Uint8Array(t.length), o = 0; o < r.length; ++o)Math.round(t[o]) !== 0 && (r[o] = 1);

      return r;
    }(t, e, n))); let r, o;
  } function O(t, e) {
    for (var n = P(t, e), r = 0; r < n.length; r++)n[r] = 1;

    return n;
  } function P(t, e) { if (e == null || e === 'float32' || e === 'complex64') return new Float32Array(t); if (e === 'int32') return new Int32Array(t); if (e === 'bool') return new Uint8Array(t); throw new Error(`Unknown data type ${e}`); } function F() {
    if (typeof performance !== 'undefined') return performance.now(); if (typeof process === 'undefined') throw new Error('Cannot measure time in this environment. You should run tf.js in the browser or in Node.js'); const t = process.hrtime();

    return 1e3 * t[0] + t[1] / 1e6;
  } const L = Object.freeze({
    shuffle: o,
    clamp: u,
    nearestLargerEven: _,
    sum: c,
    randUniform: a,
    distSquared(t, e) {
      for (var n = 0, r = 0; r < t.length; r++) {
        const o = Number(t[r]) - Number(e[r]);

        n += o * o;
      }

      return n;
    },
    assert: D,
    assertShapesMatch: f,
    assertNonNull: i,
    flatten: l,
    sizeFromShape: B,
    isScalarShape(t) { return t.length === 0; },
    arraysEqual: T,
    isInt: N,
    tanh: h,
    sizeToSquarishShape: p,
    createShuffledIndices(t) {
      for (var e = new Uint32Array(t), n = 0; n < t; ++n)e[n] = n;

      return o(e), e;
    },
    rightPad: d,
    repeatedTry: v,
    inferFromImplicitShape: g,
    squeezeShape: y,
    getTypedArrayFromDType: b,
    checkComputationForNaN: x,
    checkConversionForNaN: w,
    hasEncodingLoss: E,
    isTypedArray: C,
    bytesPerElement: R,
    isFunction: k,
    nearestDivisor: I,
    computeStrides: A,
    toTypedArray: M,
    makeOnesTypedArray: O,
    makeZerosTypedArray: P,
    now: F
  }); const z = (function () {
    function t(t, e) { this.backendTimer = t, (this.logger = e) == null && (this.logger = new W()); }

    return t.prototype.profileKernel = function (o, t) {
      let e; const i = this; const a = this.backendTimer.time(() => { e = t(); });

      return (Array.isArray(e) ? e : [e]).forEach((n) => {
        const r = n.dataSync();

        x(r, n.dtype, o), a.then((t) => {
          let e = '';

          t.getExtraProfileInfo != null && (e = t.getExtraProfileInfo()), i.logger.logKernelProfile(o, n, r, t.kernelMs, e);
        });
      }), e;
    }, t;
  }()); var W = (function () {
    function t() {}

    return t.prototype.logKernelProfile = function (t, e, n, r, o) {
      const i = d(`${r}ms`, 9); const a = d(t, 25); const s = e.rank; const u = e.size; const c = d(e.shape.toString(), 14);

      console.log(`%c${a}\t%c${i}\t%c${s}D ${c}\t%c${u}\t%c${o}`, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange', 'color: green');
    }, t;
  }()); const U = 20; const V = 3; const G = 7;

  function e(t, e, n, r) {
    const o = A(e); const i = (function (t, e, n, r) {
      const o = B(e); const i = r[r.length - 1]; const a = new Array(i).fill(0); const s = e.length; const u = n === 'complex64' ? j(t) : t;

      if (s > 1) for (let c = 0; c < o / i; c++) for (let l = c * i, h = 0; h < i; h++)a[h] = Math.max(a[h], q(u[l + h], 0).length);

      return a;
    }(t, e, n, o)); const a = e.length; const s = (function t(e, n, r, o, i, a) {
      void 0 === a && (a = !0); const s = r === 'complex64' ? 2 : 1; const u = n[0]; const c = n.length;

      if (c === 0) return r === 'complex64' ? [q(j(e)[0], 0)] : [e[0].toString()]; if (c === 1) {
        if (U < u) {
          const l = V * s; let h = Array.from(e.subarray(0, l)); let p = Array.from(e.subarray(u - V * s, u));

          return r === 'complex64' && (h = j(h), p = j(p)), [`[${h.map((t, e) => q(t, i[e])).join(', ')}, ..., ${p.map((t, e) => q(t, i[u - V + e])).join(', ')}]`];
        }

        return [`[${(r === 'complex64' ? j(e) : Array.from(e)).map((t, e) => q(t, i[e])).join(', ')}]`];
      } const f = n.slice(1); const d = o.slice(1); const m = o[0] * s; const v = [];

      if (U < u) {
        for (var g = 0; g < V; g++) {
          var y = (x = g * m) + m;

          v.push.apply(v, t(e.subarray(x, y), f, r, d, i, !1));
        } for (v.push('...'), g = u - V; g < u; g++)y = (x = g * m) + m, v.push.apply(v, t(e.subarray(x, y), f, r, d, i, g === u - 1));
      }
      else {
        for (g = 0; g < u; g++) {
          var x;

          y = (x = g * m) + m, v.push.apply(v, t(e.subarray(x, y), f, r, d, i, g === u - 1));
        }
      } const b = c === 2 ? ',' : '';

      v[0] = `[${v[0]}${b}`; for (g = 1; g < v.length - 1; g++)v[g] = ` ${v[g]}${b}`; let w = ',\n';

      for (g = 2; g < c; g++)w += '\n';

      return v[v.length - 1] = ` ${v[v.length - 1]}]${a ? '' : w}`, v;
    }(t, e, n, o, i)); const u = ['Tensor'];

    return r && (u.push(`  dtype: ${n}`), u.push(`  rank: ${a}`), u.push(`  shape: [${e}]`), u.push('  values:')), u.push(s.map((t) => `    ${t}`).join('\n')), u.join('\n');
  } function q(t, e) { return d(Array.isArray(t) ? `${parseFloat(t[0].toFixed(G))} + ${parseFloat(t[1].toFixed(G))}j` : parseFloat(t.toFixed(G)).toString(), e); } function j(t) {
    for (var e = [], n = 0; n < t.length; n += 2)e.push([t[n], t[n + 1]]);

    return e;
  } const H = (function () {
    function t(t, e, n) {
      if (this.dtype = e, this.shape = t.slice(), this.size = B(t), n != null) {
        const r = n.length;

        D(r === this.size, `Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`);
      } if (e === 'complex64') throw new Error('complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).'); this.values = n || b(e, B(this.shape)), this.strides = A(t);
    }

    return t.prototype.set = function (t) {
      for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; e.length === 0 && (e = [0]), D(e.length === this.rank, `The number of provided coordinates (${e.length}) must match the rank (${this.rank})`); const r = this.locToIndex(e);

      this.values[r] = t;
    }, t.prototype.get = function () {
      for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; t.length === 0 && (t = [0]); for (var n = t[t.length - 1], r = 0; r < t.length - 1; ++r)n += this.strides[r] * t[r];

      return this.values[n];
    }, t.prototype.locToIndex = function (t) {
      if (this.rank === 0) return 0; if (this.rank === 1) return t[0]; for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n)e += this.strides[n] * t[n];

      return e;
    }, t.prototype.indexToLoc = function (t) {
      if (this.rank === 0) return []; if (this.rank === 1) return [t]; for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n)e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];

      return e[e.length - 1] = t, e;
    }, Object.defineProperty(t.prototype, 'rank', {get() { return this.shape.length; }, enumerable: !0, configurable: !0}), t.prototype.toTensor = function () { return Y.make(this.shape, {values: this.values}, this.dtype); }, t;
  }()); let $ = null; let K = null;

  function X(t) { $ = t; } var Y = (function () {
    function o(t, e, n, r) { this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || 'float32', this.size = B(t), n != null && D(this.size === n.length, `Based on the provided shape, [${t}], and dtype ${this.dtype}, the tensor should have ${this.size} values but has ${n.length}`), this.strides = A(t), this.dataId = r != null ? r : {}, this.id = o.nextId++, this.rankType = this.rank < 5 ? this.rank.toString() : 'higher', $().registerTensor(this), n != null && $().write(this.dataId, n); }

    return o.make = function (t, e, n) { return new o(t, n, e.values, e.dataId); }, o.prototype.flatten = function () { return this.throwIfDisposed(), this.as1D(); }, o.prototype.asScalar = function () { return this.throwIfDisposed(), D(this.size === 1, 'The array must have only 1 element.'), this.reshape([]); }, o.prototype.as1D = function () { return this.throwIfDisposed(), this.reshape([this.size]); }, o.prototype.as2D = function (t, e) { return this.throwIfDisposed(), this.reshape([t, e]); }, o.prototype.as3D = function (t, e, n) { return this.throwIfDisposed(), this.reshape([t, e, n]); }, o.prototype.as4D = function (t, e, n, r) { return this.throwIfDisposed(), this.reshape([t, e, n, r]); }, o.prototype.asType = function (t) { return this.throwIfDisposed(), K.cast(this, t); }, Object.defineProperty(o.prototype, 'rank', {get() { return this.shape.length; }, enumerable: !0, configurable: !0}), o.prototype.get = function () {
      for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; D(t.length === this.rank, 'Number of coordinates in get() must match the rank of the tensor'), D(this.dtype !== 'complex64', 'Tensor.get() is not supported for complex64 tensors yet.'), this.throwIfDisposed(), t.length === 0 && (t = [0]); for (var n = t[t.length - 1], r = 0; r < t.length - 1; ++r)n += this.strides[r] * t[r];

      return this.dataSync()[n];
    }, o.prototype.buffer = function () { return K.buffer(this.shape, this.dtype, this.dataSync()); }, o.prototype.data = function () { return m(this, void 0, void 0, function () { return S(this, function (t) { return this.throwIfDisposed(), [2, $().read(this.dataId)]; }); }); }, o.prototype.dataSync = function () { return this.throwIfDisposed(), $().readSync(this.dataId); }, o.prototype.dispose = function () { this.isDisposed || ($().disposeTensor(this), this.isDisposedInternal = !0); }, Object.defineProperty(o.prototype, 'isDisposed', {get() { return this.isDisposedInternal; }, enumerable: !0, configurable: !0}), o.prototype.throwIfDisposed = function () { if (this.isDisposed) throw new Error('Tensor is disposed.'); }, o.prototype.toFloat = function () { return this.asType('float32'); }, o.prototype.toInt = function () { return this.asType('int32'); }, o.prototype.toBool = function () { return this.asType('bool'); }, o.prototype.print = function (t) { return void 0 === t && (t = !1), K.print(this, t); }, o.prototype.reshape = function (t) { return this.throwIfDisposed(), K.reshape(this, t); }, o.prototype.reshapeAs = function (t) { return this.throwIfDisposed(), this.reshape(t.shape); }, o.prototype.expandDims = function (t) { return void 0 === t && (t = 0), K.expandDims(this, t); }, o.prototype.cumsum = function (t, e, n) { return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), K.cumsum(this, t, e, n); }, o.prototype.squeeze = function (t) { return this.throwIfDisposed(), K.squeeze(this, t); }, o.prototype.clone = function () { return this.throwIfDisposed(), K.clone(this); }, o.prototype.toString = function (t) { return void 0 === t && (t = !1), e(this.dataSync(), this.shape, this.dtype, t); }, o.prototype.tile = function (t) { return this.throwIfDisposed(), K.tile(this, t); }, o.prototype.gather = function (t, e) { return void 0 === e && (e = 0), this.throwIfDisposed(), K.gather(this, t, e); }, o.prototype.matMul = function (t, e, n) { return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), K.matMul(this, t, e, n); }, o.prototype.dot = function (t) { return this.throwIfDisposed(), K.dot(this, t); }, o.prototype.norm = function (t, e, n) { return void 0 === t && (t = 'euclidean'), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), K.norm(this, t, e, n); }, o.prototype.slice = function (t, e) { return this.throwIfDisposed(), K.slice(this, t, e); }, o.prototype.reverse = function (t) { return this.throwIfDisposed(), K.reverse(this, t); }, o.prototype.concat = function (t, e) { return void 0 === e && (e = 0), this.throwIfDisposed(), K.concat([this, t], e); }, o.prototype.split = function (t, e) { return void 0 === e && (e = 0), this.throwIfDisposed(), K.split(this, t, e); }, o.prototype.stack = function (t, e) { return void 0 === e && (e = 0), K.stack([this, t], e); }, o.prototype.unstack = function (t, e) { return void 0 === e && (e = 0), K.unstack(this, e); }, o.prototype.pad = function (t, e) { return void 0 === e && (e = 0), K.pad(this, t, e); }, o.prototype.batchNormalization = function (t, e, n, r, o) { return void 0 === n && (n = 0.001), this.throwIfDisposed(), K.batchNormalization(this, t, e, n, r, o); }, o.prototype.all = function (t, e) { return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), K.all(this, t, e); }, o.prototype.any = function (t, e) { return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), K.any(this, t, e); }, o.prototype.logSumExp = function (t, e) { return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), K.logSumExp(this, t, e); }, o.prototype.sum = function (t, e) { return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), K.sum(this, t, e); }, o.prototype.prod = function (t, e) { return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), K.prod(this, t, e); }, o.prototype.mean = function (t, e) { return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), K.mean(this, t, e); }, o.prototype.min = function (t, e) { return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), K.min(this, t, e); }, o.prototype.max = function (t, e) { return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), K.max(this, t, e); }, o.prototype.argMin = function (t) { return void 0 === t && (t = null), this.throwIfDisposed(), K.argMin(this, t); }, o.prototype.argMax = function (t) { return void 0 === t && (t = null), this.throwIfDisposed(), K.argMax(this, t); }, o.prototype.cast = function (t) { return this.throwIfDisposed(), K.cast(this, t); }, o.prototype.add = function (t) { return this.throwIfDisposed(), K.add(this, t); }, o.prototype.addStrict = function (t) { return this.throwIfDisposed(), K.addStrict(this, t); }, o.prototype.atan2 = function (t) { return this.throwIfDisposed(), K.atan2(this, t); }, o.prototype.sub = function (t) { return this.throwIfDisposed(), K.sub(this, t); }, o.prototype.subStrict = function (t) { return this.throwIfDisposed(), K.subStrict(this, t); }, o.prototype.pow = function (t) { return this.throwIfDisposed(), K.pow(this, t); }, o.prototype.powStrict = function (t) { return this.throwIfDisposed(), K.powStrict(this, t); }, o.prototype.mul = function (t) { return this.throwIfDisposed(), K.mul(this, t); }, o.prototype.mulStrict = function (t) { return this.throwIfDisposed(), K.mulStrict(this, t); }, o.prototype.div = function (t) { return this.throwIfDisposed(), K.div(this, t); }, o.prototype.floorDiv = function (t) { return this.throwIfDisposed(), K.floorDiv(this, t); }, o.prototype.divStrict = function (t) { return this.throwIfDisposed(), K.divStrict(this, t); }, o.prototype.minimum = function (t) { return this.throwIfDisposed(), K.minimum(this, t); }, o.prototype.minimumStrict = function (t) { return this.throwIfDisposed(), K.minimumStrict(this, t); }, o.prototype.maximum = function (t) { return this.throwIfDisposed(), K.maximum(this, t); }, o.prototype.maximumStrict = function (t) { return this.throwIfDisposed(), K.maximumStrict(this, t); }, o.prototype.mod = function (t) { return this.throwIfDisposed(), K.mod(this, t); }, o.prototype.modStrict = function (t) { return this.throwIfDisposed(), K.modStrict(this, t); }, o.prototype.squaredDifference = function (t) { return this.throwIfDisposed(), K.squaredDifference(this, t); }, o.prototype.squaredDifferenceStrict = function (t) { return this.throwIfDisposed(), K.squaredDifferenceStrict(this, t); }, o.prototype.transpose = function (t) { return this.throwIfDisposed(), K.transpose(this, t); }, o.prototype.notEqual = function (t) { return this.throwIfDisposed(), K.notEqual(this, t); }, o.prototype.notEqualStrict = function (t) { return this.throwIfDisposed(), K.notEqualStrict(this, t); }, o.prototype.less = function (t) { return this.throwIfDisposed(), K.less(this, t); }, o.prototype.lessStrict = function (t) { return this.throwIfDisposed(), K.lessStrict(this, t); }, o.prototype.equal = function (t) { return this.throwIfDisposed(), K.equal(this, t); }, o.prototype.equalStrict = function (t) { return this.throwIfDisposed(), K.equalStrict(this, t); }, o.prototype.lessEqual = function (t) { return this.throwIfDisposed(), K.lessEqual(this, t); }, o.prototype.lessEqualStrict = function (t) { return this.throwIfDisposed(), K.lessEqualStrict(this, t); }, o.prototype.greater = function (t) { return this.throwIfDisposed(), K.greater(this, t); }, o.prototype.greaterStrict = function (t) { return this.throwIfDisposed(), K.greaterStrict(this, t); }, o.prototype.greaterEqual = function (t) { return this.throwIfDisposed(), K.greaterEqual(this, t); }, o.prototype.greaterEqualStrict = function (t) { return this.throwIfDisposed(), K.greaterEqualStrict(this, t); }, o.prototype.logicalAnd = function (t) { return this.throwIfDisposed(), K.logicalAnd(this, t); }, o.prototype.logicalOr = function (t) { return this.throwIfDisposed(), K.logicalOr(this, t); }, o.prototype.logicalNot = function () { return this.throwIfDisposed(), K.logicalNot(this); }, o.prototype.logicalXor = function (t) { return this.throwIfDisposed(), K.logicalXor(this, t); }, o.prototype.where = function (t, e) { return this.throwIfDisposed(), K.where(t, this, e); }, o.prototype.neg = function () { return this.throwIfDisposed(), K.neg(this); }, o.prototype.ceil = function () { return this.throwIfDisposed(), K.ceil(this); }, o.prototype.floor = function () { return this.throwIfDisposed(), K.floor(this); }, o.prototype.sign = function () { return this.throwIfDisposed(), K.sign(this); }, o.prototype.exp = function () { return this.throwIfDisposed(), K.exp(this); }, o.prototype.expm1 = function () { return this.throwIfDisposed(), K.expm1(this); }, o.prototype.log = function () { return this.throwIfDisposed(), K.log(this); }, o.prototype.log1p = function () { return this.throwIfDisposed(), K.log1p(this); }, o.prototype.sqrt = function () { return this.throwIfDisposed(), K.sqrt(this); }, o.prototype.rsqrt = function () { return this.throwIfDisposed(), K.rsqrt(this); }, o.prototype.square = function () { return this.throwIfDisposed(), K.square(this); }, o.prototype.reciprocal = function () { return this.throwIfDisposed(), K.reciprocal(this); }, o.prototype.abs = function () { return this.throwIfDisposed(), K.abs(this); }, o.prototype.clipByValue = function (t, e) { return this.throwIfDisposed(), K.clipByValue(this, t, e); }, o.prototype.relu = function () { return this.throwIfDisposed(), K.relu(this); }, o.prototype.elu = function () { return this.throwIfDisposed(), K.elu(this); }, o.prototype.selu = function () { return this.throwIfDisposed(), K.selu(this); }, o.prototype.leakyRelu = function (t) { return void 0 === t && (t = 0.2), this.throwIfDisposed(), K.leakyRelu(this, t); }, o.prototype.prelu = function (t) { return this.throwIfDisposed(), K.prelu(this, t); }, o.prototype.sigmoid = function () { return this.throwIfDisposed(), K.sigmoid(this); }, o.prototype.logSigmoid = function () { return this.throwIfDisposed(), K.logSigmoid(this); }, o.prototype.softplus = function () { return this.throwIfDisposed(), K.softplus(this); }, o.prototype.zerosLike = function () { return this.throwIfDisposed(), K.zerosLike(this); }, o.prototype.onesLike = function () { return this.throwIfDisposed(), K.onesLike(this); }, o.prototype.sin = function () { return this.throwIfDisposed(), K.sin(this); }, o.prototype.cos = function () { return this.throwIfDisposed(), K.cos(this); }, o.prototype.tan = function () { return this.throwIfDisposed(), K.tan(this); }, o.prototype.asin = function () { return this.throwIfDisposed(), K.asin(this); }, o.prototype.acos = function () { return this.throwIfDisposed(), K.acos(this); }, o.prototype.atan = function () { return this.throwIfDisposed(), K.atan(this); }, o.prototype.sinh = function () { return this.throwIfDisposed(), K.sinh(this); }, o.prototype.cosh = function () { return this.throwIfDisposed(), K.cosh(this); }, o.prototype.tanh = function () { return this.throwIfDisposed(), K.tanh(this); }, o.prototype.asinh = function () { return this.throwIfDisposed(), K.asinh(this); }, o.prototype.acosh = function () { return this.throwIfDisposed(), K.acosh(this); }, o.prototype.atanh = function () { return this.throwIfDisposed(), K.atanh(this); }, o.prototype.erf = function () { return this.throwIfDisposed(), K.erf(this); }, o.prototype.round = function () { return this.throwIfDisposed(), K.round(this); }, o.prototype.step = function (t) { return void 0 === t && (t = 0), this.throwIfDisposed(), K.step(this, t); }, o.prototype.softmax = function (t) { return void 0 === t && (t = -1), this.throwIfDisposed(), K.softmax(this, t); }, o.prototype.resizeBilinear = function (t, e) { return void 0 === e && (e = !1), this.throwIfDisposed(), K.image.resizeBilinear(this, t, e); }, o.prototype.resizeNearestNeighbor = function (t, e) { return void 0 === e && (e = !1), this.throwIfDisposed(), K.image.resizeNearestNeighbor(this, t, e); }, o.prototype.conv1d = function (t, e, n, r, o, i) { return void 0 === r && (r = 'NWC'), void 0 === o && (o = 1), this.throwIfDisposed(), K.conv1d(this, t, e, n, r, o, i); }, o.prototype.conv2d = function (t, e, n, r, o, i) { return void 0 === r && (r = 'NHWC'), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), K.conv2d(this, t, e, n, r, o, i); }, o.prototype.conv2dTranspose = function (t, e, n, r, o) { return this.throwIfDisposed(), K.conv2dTranspose(this, t, e, n, r, o); }, o.prototype.depthwiseConv2D = function (t, e, n, r, o, i) { return void 0 === r && (r = 'NHWC'), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), K.depthwiseConv2d(this, t, e, n, r, o, i); }, o.prototype.separableConv2d = function (t, e, n, r, o, i) { return void 0 === o && (o = [1, 1]), void 0 === i && (i = 'NHWC'), this.throwIfDisposed(), K.separableConv2d(this, t, e, n, r, o, i); }, o.prototype.avgPool = function (t, e, n, r) { return this.throwIfDisposed(), K.avgPool(this, t, e, n, r); }, o.prototype.maxPool = function (t, e, n, r) { return this.throwIfDisposed(), K.maxPool(this, t, e, n, r); }, o.prototype.localResponseNormalization = function (t, e, n, r) { return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = 0.5), K.localResponseNormalization(this, t, e, n, r); }, o.prototype.pool = function (t, e, n, r, o) { return this.throwIfDisposed(), K.pool(this, t, e, n, r, o); }, o.prototype.variable = function (t, e, n) { return void 0 === t && (t = !0), this.throwIfDisposed(), Q.variable(this, t, e, n); }, o.prototype.unsortedSegmentSum = function (t, e) { return this.throwIfDisposed(), K.unsortedSegmentSum(this, t, e); }, o.prototype.batchToSpaceND = function (t, e) { return this.throwIfDisposed(), K.batchToSpaceND(this, t, e); }, o.prototype.spaceToBatchND = function (t, e) { return this.throwIfDisposed(), K.spaceToBatchND(this, t, e); }, o.prototype.topk = function (t, e) { return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), K.topk(this, t, e); }, o.prototype.stridedSlice = function (t, e, n, r, o) { return void 0 === r && (r = 0), void 0 === o && (o = 0), this.throwIfDisposed(), K.stridedSlice(this, t, e, n, r, o); }, o.prototype.depthToSpace = function (t, e) { return this.throwIfDisposed(), K.depthToSpace(this, t, e); }, o.prototype.fft = function () { return this.throwIfDisposed(), K.spectral.fft(this); }, o.nextId = 0, o;
  }());

  Object.defineProperty(Y, Symbol.hasInstance, {value(t) { return !!t && t.shape != null && t.dtype != null; }}); var Q = (function (o) {
    function i(t, e, n) {
      void 0 === e && (e = !0); const r = o.call(this, t.shape, t.dtype, null, t.dataId) || this;

      r.trainable = e, r.name = n, r.name == null && (r.name = i.nextVarId.toString(), i.nextVarId++); try { $().registerVariable(r); }
      catch (t) { throw $().disposeTensor(r), t; }

      return r;
    }

    return s(i, o), i.variable = function (t, e, n, r) { return void 0 === e && (e = !0), r != null && r !== t.dtype && (t = t.asType(r)), new i(t, e, n); }, i.prototype.assign = function (t) { if (t.dtype !== this.dtype) throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`); if (!T(t.shape, this.shape)) throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`); $().disposeTensor(this), this.dataId = t.dataId, $().registerTensor(this); }, i.nextVarId = 0, i;
  }(Y));

  Object.defineProperty(Q, Symbol.hasInstance, {value(t) { return t instanceof Y && t.assign != null && t.assign instanceof Function; }}); const J = Q.variable;

  function Z(t, e) { D(t.dtype === e.dtype, `The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`); } function tt(t) {
    const e = [];

    return (function t(e, n, r) {
      if (e != null) {
        if (e instanceof Y)n.push(e); else if (s = e, Array.isArray(s) || typeof s === 'object') {
          const o = e;

          for (const i in o) {
            const a = o[i];

            r.has(a) || (r.add(a), t(a, n, r));
          }
        }
      } let s;
    }(t, e, new Set())), e;
  } let et; let nt; const rt = (function () {
    function t(t, e, n) {
      this.backend = t, this.safeMode = e, this.debugMode = n, this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numDataBuffers = 0, this.profiling = !1, this.gradientScopeCount = 0, this.customGradientDepth = 0, this.keepTensors = new Set(), this.tensorInfo = new WeakMap(), this.activeScope = {track: [], name: 'default scope'}, this.scopeStack = [this.activeScope], this.profiler = new z(t), this.activeProfile = {
        newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null
      };
    }

    return t.prototype.moveData = function (t) { this.write(t, this.readSync(t)); }, t.prototype.tidy = function (t, e, n) {
      const r = this;

      void 0 === n && (n = !1); let o; let i = null;

      if (e == null) { if (typeof t !== 'function') throw new Error('Please provide a function to tidy()'); e = t; }
      else { if (typeof t !== 'string' && !(t instanceof String)) throw new Error('When calling with two arguments, the first argument to tidy() must be a string'); if (typeof e !== 'function') throw new Error('When calling with two arguments, the 2nd argument to tidy() must be a function'); i = t; }

      return this.scopedRun(() => r.startScope(i, n), () => r.endScope(o, n), () => (o = e()) instanceof Promise && console.error('Cannot return a Promise inside of tidy.'), o);
    }, t.prototype.scopedRun = function (t, e, n) {
      t(); try {
        const r = n();

        return e(), r;
      }
      catch (t) { throw e(), t; }
    }, t.prototype.runKernel = function (t, e, n) {
      let r; const o = this; const i = []; const a = function (t) { return i.push(t), t; }; const s = this.activeScope.name; const u = this.numBytes; const c = this.numTensors;

      if (this.scopedRun(() => o.customGradientDepth++, () => o.customGradientDepth--, () => { r = o.debugMode() ? o.profiler.profileKernel(s, () => t(o.backend, a)) : t(o.backend, a); }), this.shouldRecord()) {
        const l = {
          id: this.nextTapeNodeId++, name: s, inputs: e, outputs: Array.isArray(r) ? r : [r]
        };

        n != null && (l.gradient = function (t) { return n(t, i); }), this.activeTape.push(l);
      }

      return this.profiling && this.activeProfile.kernels.push({
        name: s, bytesAdded: this.numBytes - u, totalBytesSnapshot: this.numBytes, tensorsAdded: this.numTensors - c, totalTensorsSnapshot: this.numTensors, inputShapes: Object.keys(e).map((t) => e[t].shape), outputShape: Array.isArray(r) ? r.map((t) => t.shape) : r.shape
      }), r;
    }, t.prototype.registerTensor = function (t) {
      const e = this.tensorInfo.has(t.dataId) ? this.tensorInfo.get(t.dataId).refCount : 0;

      this.numTensors++, e === 0 && (this.numDataBuffers++, t.dtype !== 'complex64' && (this.numBytes += B(t.shape) * R(t.dtype)), this.tensorInfo.set(t.dataId, {
        backend: this.backend, dtype: t.dtype, shape: t.shape, refCount: 0
      }), this.backend.register(t.dataId, t.shape, t.dtype)), this.tensorInfo.get(t.dataId).refCount++, t instanceof Q || this.track(t);
    }, t.prototype.registerVariable = function (t) { if (this.registeredVariables[t.name] != null) throw new Error(`Variable with name ${t.name} was already registered`); this.registeredVariables[t.name] = t; }, t.prototype.disposeTensor = function (t) { this.tensorInfo.has(t.dataId) && (this.keepTensors.has(t.id) && this.keepTensors.delete(t.id), this.numTensors--, this.tensorInfo.get(t.dataId).refCount <= 1 ? (this.tensorInfo.get(t.dataId).backend.disposeData(t.dataId), this.numDataBuffers--, t.dtype !== 'complex64' && (this.numBytes -= B(t.shape) * R(t.dtype)), this.tensorInfo.delete(t.dataId)) : this.tensorInfo.get(t.dataId).refCount--); }, t.prototype.disposeVariables = function () {
      for (const t in this.registeredVariables) {
        const e = this.registeredVariables[t];

        this.disposeTensor(e), delete this.registeredVariables[t];
      }
    }, t.prototype.memory = function () {
      const t = this.backend.memory();

      return t.numTensors = this.numTensors, t.numDataBuffers = this.numDataBuffers, t.numBytes = this.numBytes, t;
    }, t.prototype.profile = function (r) {
      return m(this, void 0, void 0, function () {
        let e, n;

        return S(this, function (t) { return this.profiling = !0, e = this.numBytes, n = this.numTensors, this.activeProfile.kernels = [], this.activeProfile.result = r(), this.profiling = !1, this.activeProfile.peakBytes = Math.max.apply(Math, this.activeProfile.kernels.map((t) => t.totalBytesSnapshot)), this.activeProfile.newBytes = this.numBytes - e, this.activeProfile.newTensors = this.numTensors - n, [2, this.activeProfile]; });
      });
    }, t.prototype.shouldRecord = function () { return this.activeTape != null && this.customGradientDepth === 0; }, t.prototype.addTapeNode = function (t, e, r) {
      const n = {};

      t.forEach((t, e) => { n[e] = t; }); const o = {
        id: this.nextTapeNodeId++,
        name: this.activeScope.name,
        inputs: n,
        outputs: [e],
        gradient(t) {
          const n = {};

          return r(t).forEach((t, e) => { n[e] = function () { return t; }; }), n;
        }
      };

      this.activeTape.push(o);
    }, t.prototype.keep = function (t) {
      if (this.scopeStack.length === 1 && this.safeMode) throw new Error('Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {...}) to avoid memory leaks.');

      return this.keepTensors.add(t.id), t;
    }, t.prototype.startScope = function (t, e) {
      void 0 === e && (e = !1), e && this.gradientScopeCount === 0 && (this.activeTape = []), e && this.gradientScopeCount++; const n = {track: [], name: 'unnamed scope'};

      t && (n.name = t), this.scopeStack.push(n), this.activeScope = n;
    }, t.prototype.endScope = function (t, e) {
      const n = this;

      void 0 === e && (e = !1), e && (this.gradientScopeCount--, this.gradientScopeCount === 0 && (this.activeTape = null)); const r = new Set(this.keepTensors); const o = tt(t);

      o.forEach((t) => r.add(t.id)); for (let i = 0; i < this.activeScope.track.length; i++) {
        const a = this.activeScope.track[i];

        r.has(a.id) || (this.activeTape != null ? o.push(a) : a.dispose());
      } const s = this.scopeStack.pop();

      this.activeScope = this.scopeStack.length === 0 ? {track: [], name: 'default scope'} : this.scopeStack[this.scopeStack.length - 1], o.forEach((t) => {
        !n.keepTensors.has(t.id) && (function (t, e) {
          for (let n = 0; n < e.length; n++) if (e[n].id === t.id) return !0;

          return !1;
        }(t, s.track)) && n.track(t);
      });
    }, t.prototype.gradients = function (i, a, s, u) {
      const c = this;

      return void 0 === u && (u = !1), D(a.length > 0, 'gradients() received an empty list of xs.'), this.tidy('gradients', () => {
        const t = i();

        D(t instanceof Y, 'The result y returned by f() must be a tensor.'); const e = (function (t, e, n) {
          for (var r = {}, o = {}, i = 0; i < e.length; i++)r[e[i].id] = !0; for (i = 0; i < t.length; i++) {
            var a = (d = t[i]).inputs;

            for (var s in a) { for (var u = a[s], c = !1, l = 0; l < e.length; l++) if (r[u.id]) { d.outputs.forEach((t) => r[t.id] = !0), c = !0, o[d.id] = !0; break; } if (c) break; }
          } const h = {};

          h[n.id] = !0; const p = {};

          for (i = t.length - 1; i >= 0; i--) for (a = (d = t[i]).inputs, l = 0; l < d.outputs.length; l++) if (h[d.outputs[l].id]) { for (var s in a)h[a[s].id] = !0, p[d.id] = !0; break; } const f = [];

          for (i = 0; i < t.length; i++) {
            var d;

            if (o[(d = t[i]).id] && p[d.id]) {
              const m = {};

              for (var s in d.inputs) {
                const v = d.inputs[s];

                r[v.id] && (m[s] = v);
              } const g = Object.assign({}, d);

              g.inputs = m, g.outputs = d.outputs, f.push(g);
            }
          }

          return f;
        }(c.activeTape, a, t));

        if (!u && e.length === 0 && a.length > 0) throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.'); let n; let r; const o = {};

        return o[t.id] = s == null ? (n = t.shape, r = O(B(n), 'float32'), Y.make(n, {values: r})) : s, (function (u, c) {
          for (let t = function (t) {
              const e = c[t]; const r = [];

              if (e.outputs.forEach((t) => {
                const e = u[t.id];

                if (e != null)r.push(e); else {
                  const n = Y.make(t.shape, {values: P(t.size, t.dtype)}, t.dtype);

                  r.push(n);
                }
              }), e.gradient == null) throw new Error(`Cannot compute gradient: gradient function not found for ${e.name}.`); const n = e.gradient(e.outputs.length === 1 ? r[0] : r);

              for (const o in e.inputs) {
                if (!(o in n)) throw new Error(`Cannot backprop through input ${o}. Available gradients found: ${Object.keys(n)}.`); const i = n[o](); const a = e.inputs[o];

                if (!T(i.shape, a.shape)) throw new Error(`Error in gradient for op ${e.name}. The gradient of input '${o}' has shape '${i.shape}', which does not match the shape of the input '${a.shape}'`); if (u[a.id] == null)u[a.id] = i; else {
                  const s = u[a.id];

                  u[a.id] = s.add(i), s.dispose();
                }
              }
            }, e = c.length - 1; e >= 0; e--)t(e);
        }(o, e)), {value: t, grads: a.map((t) => o[t.id])};
      }, !0);
    }, t.prototype.customGrad = function (i) {
      const n = this;

      return D(k(i), 'The f passed in customGrad(f) must be a function.'), function () {
        for (var r, t, o = [], e = 0; e < arguments.length; e++)o[e] = arguments[e];

        return D(o.every((t) => t instanceof Y), 'The args passed in customGrad(f)(x1, x2,...) must all be tensors'), n.scopedRun(() => n.customGradientDepth++, () => n.customGradientDepth--, () => {
          t = n.tidy(i.name, () => {
            const t = i.apply(void 0, o); const e = t.value; const n = t.gradFunc;

            return D(e instanceof Y, 'The function f passed in customGrad(f) must return an object where `obj.value` is a tensor'), D(k(n), 'The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.'), r = n, e;
          }, !0);
        }), n.shouldRecord() && n.addTapeNode(o, t, (t) => {
          const e = r(t); const n = Array.isArray(e) ? e : [e];

          return D(n.length === o.length, 'The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).'), D(n.every((t) => t instanceof Y), 'The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.'), n;
        }), t;
      };
    }, t.prototype.write = function (t, e) {
      const n = this.tensorInfo.get(t);

      this.backend !== n.backend && (n.backend.disposeData(t), n.backend = this.backend, this.backend.register(t, n.shape, n.dtype)), this.backend.write(t, e);
    }, t.prototype.readSync = function (t) { return this.tensorInfo.get(t).backend.readSync(t); }, t.prototype.read = function (t) { return this.tensorInfo.get(t).backend.read(t); }, t.prototype.fromPixels = function (t, e) { return this.backend.fromPixels(t, e); }, t.prototype.time = function (r) {
      return m(this, void 0, void 0, function () {
        let e, n;

        return S(this, function (t) { switch (t.label) { case 0: return e = F(), [4, this.backend.time(r)]; case 1: return (n = t.sent()).wallMs = F() - e, [2, n]; } });
      });
    }, t.prototype.track = function (t) {
      if (this.scopeStack.length === 1 && this.safeMode) throw new Error('Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {op();...}); to avoid memory leaks.');

      return this.activeScope.track.push(t), t;
    }, t;
  }());

  (nt = et || (et = {}))[nt.NUMBER = 0] = 'NUMBER', nt[nt.BOOLEAN = 1] = 'BOOLEAN', nt[nt.STRING = 2] = 'STRING'; let ot; const it = [{name: 'DEBUG', type: et.BOOLEAN}, {name: 'IS_BROWSER', type: et.BOOLEAN}, {name: 'WEBGL_PACK_BATCHNORMALIZATION', type: et.BOOLEAN}, {name: 'WEBGL_CONV_IM2COL', type: et.BOOLEAN}, {name: 'WEBGL_MAX_TEXTURE_SIZE', type: et.NUMBER}, {name: 'WEBGL_PAGING_ENABLED', type: et.BOOLEAN}, {name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', type: et.NUMBER}, {name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: et.BOOLEAN}, {name: 'WEBGL_VERSION', type: et.NUMBER}, {name: 'WEBGL_RENDER_FLOAT32_ENABLED', type: et.BOOLEAN}, {name: 'WEBGL_DOWNLOAD_FLOAT_ENABLED', type: et.BOOLEAN}, {name: 'WEBGL_FENCE_API_ENABLED', type: et.BOOLEAN}, {name: 'WEBGL_SIZE_UPLOAD_UNIFORM', type: et.NUMBER}, {name: 'BACKEND', type: et.STRING}, {name: 'EPSILON', type: et.NUMBER}, {name: 'PROD', type: et.BOOLEAN}, {name: 'TENSORLIKE_CHECK_SHAPE_CONSISTENCY', type: et.BOOLEAN}];

  function at(t, e) {
    let n;

    try { n = lt(t, e); }
    catch (t) { return !1; }

    return n != null && (ht(n), !0);
  } const st = 'tfjsflags';

  function ut() {
    const e = {};

    if (typeof window === 'undefined' || void 0 === window.location) return e; let t; let a; const n = (t = window.location.search, a = {}, t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (t) {
      for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n];

      return r = a, o = e[0], i = e[1], r[decodeURIComponent(o)] = decodeURIComponent(i || ''), e.join('='); let r, o, i;
    }), a);

    if (st in n) {
      const o = {};

      n[st].split(',').forEach((t) => {
        const e = t.split(':'); const n = e[0]; const r = e[1];

        o[n] = r;
      }), it.forEach((t) => { t.name in o && (console.log(`Setting feature override from URL ${t.name}: ${o[t.name]}`), t.type === et.NUMBER ? e[t.name] = +o[t.name] : t.type === et.BOOLEAN ? e[t.name] = o[t.name] === 'true' : t.type === et.STRING ? e[t.name] = o[t.name] : console.warn(`Unknown URL param: ${t.name}.`)); });
    }

    return e;
  } function ct(t, e) { return t.getExtension(e) != null; } function lt(t, e) {
    if (t === 0 || !e) throw new Error('Cannot get WebGL rendering context, WebGL is disabled.'); const n = document.createElement('canvas');

    return t === 1 ? n.getContext('webgl') || n.getContext('experimental-webgl') : n.getContext('webgl2');
  } function ht(t) {
    if (t != null) {
      const e = t.getExtension('WEBGL_lose_context');

      if (e == null) throw new Error('Extension WEBGL_lose_context not supported on this browser.'); e.loseContext();
    }
  } function pt(t, e) {
    const n = t.createFramebuffer(); const r = t.createTexture();

    t.bindTexture(t.TEXTURE_2D, r); const o = e === 2 ? t.RGBA32F : t.RGBA;

    t.texImage2D(t.TEXTURE_2D, 0, o, 1, 1, 0, t.RGBA, t.FLOAT, null), t.bindFramebuffer(t.FRAMEBUFFER, n), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0); const i = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;

    return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(n), i;
  } const ft = (function () {
    function t(t) { this.features = {}, this.registry = {}, t != null && (this.features = t), this.get('DEBUG') && console.warn('Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.'); }

    return t.setBackend = function (t, e) { if (void 0 === e && (e = !1), !(t in mt.registry)) throw new Error(`Backend name '${t}' not found in registry`); mt.engine.backend = mt.findBackend(t), mt.backendName = t; }, t.getBackend = function () { return mt.initEngine(), mt.backendName; }, t.disposeVariables = function () { mt.engine.disposeVariables(); }, t.memory = function () { return mt.engine.memory(); }, t.profile = function (t) { return mt.engine.profile(t); }, t.tidy = function (t, e, n) { return void 0 === n && (n = !1), mt.engine.tidy(t, e, n); }, t.dispose = function (t) { tt(t).forEach((t) => t.dispose()); }, t.keep = function (t) { return mt.engine.keep(t); }, t.time = function (t) { return mt.engine.time(t); }, t.prototype.get = function (t) { return t in this.features || (this.features[t] = this.evaluateFeature(t)), this.features[t]; }, t.prototype.getFeatures = function () { return this.features; }, t.prototype.set = function (t, e) { this.features[t] = e; }, t.prototype.getBestBackendName = function () {
      const e = this;

      if (Object.keys(this.registry).length === 0) throw new Error('No backend found in registry.');

      return Object.keys(this.registry).map((t) => ({name: t, entry: e.registry[t]})).sort((t, e) => e.entry.priority - t.entry.priority)[0].name;
    }, t.prototype.evaluateFeature = function (t) {
      if (t === 'DEBUG') return !1; if (t === 'IS_BROWSER') return typeof window !== 'undefined'; if (t === 'IS_NODE') return typeof process !== 'undefined' && void 0 !== process.versions.node; if (t === 'IS_CHROME') return typeof navigator !== 'undefined' && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor); if (t === 'WEBGL_PACK_BATCHNORMALIZATION') return !1; if (t === 'WEBGL_CONV_IM2COL') return !1; if (t === 'WEBGL_PAGING_ENABLED') return this.get('IS_BROWSER') && !this.get('PROD'); if (t === 'WEBGL_MAX_TEXTURE_SIZE') {
        return (function (t, e) {
          if (ot == null) {
            const n = lt(t, e);

            ot = n.getParameter(n.MAX_TEXTURE_SIZE);
          }

          return ot;
        }(this.get('WEBGL_VERSION'), this.get('IS_BROWSER')));
      } if (t === 'IS_TEST') return !1; if (t === 'BACKEND') return this.getBestBackendName(); if (t === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') {
        const e = this.get('WEBGL_VERSION');

        return e === 0 ? 0 : (function (t, e) {
          if (t === 0) return 0; let n; const r = lt(t, e);

          return n = ct(r, 'EXT_disjoint_timer_query_webgl2') && t === 2 ? 2 : ct(r, 'EXT_disjoint_timer_query') ? 1 : 0, r != null && ht(r), n;
        }(e, this.get('IS_BROWSER')));
      } if (t === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 && (n = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0, 4)))); let n;

      if (t === 'HAS_WEBGL') return this.get('WEBGL_VERSION') > 0; if (t === 'WEBGL_VERSION') return at(2, this.get('IS_BROWSER')) ? 2 : at(1, this.get('IS_BROWSER')) ? 1 : 0; if (t === 'WEBGL_RENDER_FLOAT32_ENABLED') {
        return (function (t, e) {
          if (t === 0) return !1; const n = lt(t, e);

          if (t === 1) { if (!ct(n, 'OES_texture_float')) return !1; }
          else if (!ct(n, 'EXT_color_buffer_float')) return !1; const r = pt(n, t);

          return ht(n), r;
        }(this.get('WEBGL_VERSION'), this.get('IS_BROWSER')));
      } if (t === 'WEBGL_DOWNLOAD_FLOAT_ENABLED') {
        return (function (t, e) {
          if (t === 0) return !1; const n = lt(t, e);

          if (t === 1) { if (!ct(n, 'OES_texture_float')) return !1; if (!ct(n, 'WEBGL_color_buffer_float')) return !1; }
          else if (!ct(n, 'EXT_color_buffer_float')) return !1; const r = pt(n, t);

          return ht(n), r;
        }(this.get('WEBGL_VERSION'), this.get('IS_BROWSER')));
      } if (t === 'WEBGL_FENCE_API_ENABLED') {
        return (function (t, e) {
          if (t !== 2) return !1; const n = lt(t, e); const r = n.fenceSync != null;

          return ht(n), r;
        }(this.get('WEBGL_VERSION'), this.get('IS_BROWSER')));
      } if (t === 'WEBGL_SIZE_UPLOAD_UNIFORM') return this.get('WEBGL_RENDER_FLOAT32_ENABLED') ? 4 : 0; if (t === 'TEST_EPSILON') return this.backend.floatPrecision() === 32 ? 0.001 : 0.1; if (t === 'EPSILON') return this.backend.floatPrecision() === 32 ? 1e-7 : 0.001; if (t === 'PROD') return !1; if (t === 'TENSORLIKE_CHECK_SHAPE_CONSISTENCY') return !this.get('PROD'); throw new Error(`Unknown feature ${t}.`);
    }, t.prototype.setFeatures = function (t) { this.features = Object.assign({}, t); }, t.prototype.reset = function () { this.features = ut(), this.globalEngine != null && (this.globalEngine = null); }, Object.defineProperty(t.prototype, 'backend', {get() { return this.engine.backend; }, enumerable: !0, configurable: !0}), t.prototype.findBackend = function (t) { return t in this.registry ? this.registry[t].backend : null; }, t.prototype.registerBackend = function (t, e, n, r) {
      const o = this;

      if (void 0 === n && (n = 1), t in this.registry) return console.warn(`${t} backend was already registered. Reusing existing backend`), r != null && r(() => o.engine), !1; try {
        const i = e();

        return i.setDataMover({moveData(t) { return o.engine.moveData(t); }}), this.registry[t] = {backend: i, priority: n}, !0;
      }
      catch (e) { return console.warn(`Registration of backend ${t} failed`), console.warn(e.stack || e.message), !1; }
    }, t.prototype.removeBackend = function (t) { if (!(t in this.registry)) throw new Error(`${t} backend not found in registry`); this.registry[t].backend.dispose(), delete this.registry[t]; }, Object.defineProperty(t.prototype, 'engine', {get() { return this.initEngine(), this.globalEngine; }, enumerable: !0, configurable: !0}), t.prototype.initEngine = function () {
      const t = this;

      if (this.globalEngine == null) {
        this.backendName = this.get('BACKEND'); const e = this.findBackend(this.backendName);

        this.globalEngine = new rt(e, !1, (() => t.get('DEBUG')));
      }
    }, t;
  }()); let dt; var mt = ((dt = (function () {
    let t;

    if (typeof window !== 'undefined')t = window; else { if (typeof process === 'undefined') throw new Error('Could not find a global object'); t = process; }

    return t;
  }())).ENV == null && (dt.ENV = new ft(ut()), X(() => dt.ENV.engine)), dt.ENV); const vt = Object.freeze({Environment: ft, ENV: mt});

  function gt(t, e) {
    if (D(k(t), 'The f passed in variableGrads(f) must be a function'), D(e == null || Array.isArray(e) && e.every((t) => t instanceof Q), 'The varList passed in variableGrads(f, varList) must be an array of variables'), e == null) for (const n in e = [], mt.engine.registeredVariables)e.push(mt.engine.registeredVariables[n]); const r = e.length;

    D((e = e.filter((t) => t.trainable)).length > 0, `variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`); const o = mt.engine.gradients(t, e, null, !0); const i = o.value; const a = o.grads;

    D(a.some((t) => t != null), 'Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().'), D(i.rank === 0, `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`); const s = {};

    return e.forEach((t, e) => { a[e] != null && (s[t.name] = a[e]); }), {value: i, grads: s};
  } function yt(t) { return mt.engine.customGrad(t); } function xt(t) { if (t.filter((t) => t == null).length > 0) throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.'); } const bt = ft.tidy; const wt = ft.keep; const Et = ft.dispose; const St = ft.time; const _t = ft.profile;

  function Ct() { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; mt.get('IS_TEST') || console.warn.apply(console, t); } function Rt(t, e, n, r) {
    void 0 === r && (r = !0); let o = [];

    if (r)(o = o.concat(e.slice(0))).push(t[0] / n), o = o.concat(t.slice(1)); else { o = o.concat(t[0]); for (var i = e.length, a = 0; a < i; ++a)o = o.concat([t[a + 1] / e[a], e[a]]); o = o.concat(t.slice(i + 1)); }

    return o;
  } function Tt(t, e, n) {
    void 0 === n && (n = !0); const r = [];

    if (n) { r.push(e); for (var o = e + 1; o < t; ++o)o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o); }
    else {
      const i = []; const a = [];

      for (o = 1; o < t; ++o)2 * e + 1 <= o || o % 2 == 1 ? a.push(o) : i.push(o); r.push.apply(r, i), r.push(0), r.push.apply(r, a);
    }

    return r;
  } function kt(t, e, n, r) {
    void 0 === r && (r = !0); const o = [];

    r ? o.push(t[0] / n) : o.push(t[0] * n); for (let i = 1; i < t.length; ++i)i <= e.length ? r ? o.push(e[i - 1] * t[i]) : o.push(t[i] / e[i - 1]) : o.push(t[i]);

    return o;
  } function It(t, e) {
    for (var n = [0], r = 0; r < e; ++r)n.push(t[r][0]);

    return n;
  } function Dt(t, e, n) {
    for (var r = t.slice(0, 1), o = 0; o < n; ++o)r.push(t[o + 1] - e[o][0] - e[o][1]);

    return r;
  } function Nt(t, e) {
    for (let n = 0; n < t.length; ++n) if (t[t.length - n - 1] !== e - 1 - n) return !1;

    return !0;
  } function At(e, t) {
    for (var n = [], r = e.length, o = 0; o < r; o++)t.indexOf(o) === -1 && n.push(e[o]);

    return [n, t.map((t) => e[t])];
  } function Mt(t, e) {
    return (function (t, e, n) {
      for (var r = t.length + e.length, o = [], i = 0, a = 0, s = 0; s < r; s++)n.indexOf(s) === -1 ? o.push(t[i++]) : o.push(e[a++]);

      return o;
    }(t, e.map((t) => 1), e));
  } function Ot(t, e) {
    const n = e.length;

    return D((t = t == null ? e.map((t, e) => e) : [].concat(t)).every((t) => -n <= t && t < n), `All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`), D(t.every((t) => N(t)), `All values in axis param must be integers but got axis ${t}`), t.map((t) => (t < 0 ? n + t : t));
  } function Pt(t, e, n) { D(Nt(e, n), `${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`); } function Ft(t, e) {
    if (Nt(t, e)) return null; for (var n = [], r = 0; r < e; ++r)t.indexOf(r) === -1 && n.push(r);

    return t.forEach((t) => n.push(t)), n;
  } function Lt(t) { return t.map((t, e) => [e, t]).sort((t, e) => t[1] - e[1]).map((t) => t[0]); } function Bt(t, e) {
    for (var n = [], r = e - t; r < e; ++r)n.push(r);

    return n;
  } function zt(t, e) {
    for (var n = t[0].slice(), r = 1; r < t.length; r++)n[e] += t[r][e];

    return n;
  } function Wt(t, e) {
    if (t.rank < 1) throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t.rank}.`); if (e.rank < 1) throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`); if (e.dtype !== 'int32') throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`); if (e.shape[e.rank - 1] > t.rank) throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[e.rank - 1]} vs. ${t.rank}`); if (t.size === 0) throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`); for (var n = e.shape, r = n[n.length - 1], o = 1, i = 0; i < n.length - 1; ++i)o *= n[i]; const a = t.shape; const s = n.slice();

    s.pop(); let u = 1;

    for (i = r; i < t.rank; ++i)u *= a[i], s.push(a[i]); const c = A(t.shape).map((t) => t / u).concat([1]).slice(0, r);

    return [s, o, u, c];
  } function Ut(t) { return t <= 30 ? t : I(t, Math.floor(Math.sqrt(t))); } function Vt(t, e, n) {
    if (e.rank < 1) throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`); if (t.rank < 1) throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`); if (e.dtype !== 'int32') throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`); if (n.length < 1) throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`); if (n.length === 0) { if (e.size === 0) throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`); if (t.size === 0) throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`); }!(function (t, e, n) {
      const r = e.rank > 1 ? e.shape[e.rank - 1] : 1; const o = e.rank > 1 ? e.rank - 1 : 1; const i = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${o}.`;

      if (n.rank < o) throw new Error(`${i} update.rank < ${o}. `); if (t.length < r + (n.rank - o)) throw new Error(`${i} Output shape length < ${r + (n.rank - o)}`); if (n.rank !== o + t.length - r) throw new Error(`${i} update.rank != ${o + t.length - r}`); for (var a = 0; a < o; ++a) if (n.shape[a] !== e.shape[a]) throw new Error(`${i} updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`); for (a = 0; a < n.rank - o; ++a) if (n.shape[a + o] !== t[a + r]) throw new Error(`${i} updates.shape[${a + o}] (${n.shape[a + o]}) != shape[${a + o}] (${t[a + o]})`);
    }(n, e, t));
  } function Gt(t, e, n) {
    for (var r = e.rank > 1 ? e.shape[e.rank - 1] : 1, o = n.length, i = 1, a = r; a < o; ++a)i *= n[a]; const s = r < 1 ? 1 : r; const u = e.size / s; const c = A(n).concat([1]);

    return {
      sliceRank: r, numUpdates: u, sliceSize: i, strides: c.slice(c.length - r, c.length), outputSize: B(n)
    };
  } function qt(t, e, n, o, r, i, a, s, u) {
    if (void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), a !== 0) throw new Error('ellipsis mask is not yet supported'); if (s !== 0) throw new Error('new axis mask is not yet supported'); for (var c = [], l = [], h = [], p = 0; p < t.length; p++)c[p] = jt(r, e, o, t, p), l[p] = Ht(i, n, o, t, p), u & 1 << p && (l[p] = c[p] + 1, h.push(p)); let f = new Array(t.length).fill(0);

    return f = f.map((t, e) => {
      for (var n = 0, r = c[e]; !(o[e] > 0 ? r >= l[e] : r <= l[e]); r += o[e])n += 1;

      return n;
    }), [c, f, h];
  } function jt(t, e, n, r, o) {
    let i = e[o];

    t & 1 << o && (i = n[o] > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER); const a = r[o];

    return i < 0 && (i += a), u(0, i, a - 1);
  } function Ht(t, e, n, r, o) {
    let i = e[o];

    t & 1 << o && (i = n[o] > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER); const a = r[o];

    return i < 0 && (i += a), n[o] > 0 ? u(0, i, a) : u(-1, i, a - 1);
  } function $t(t) {
    let e = t;

    if (C(t)) return [t.length]; if (!Array.isArray(t)) return []; for (var n = []; e instanceof Array;)n.push(e.length), e = e[0];

    return t instanceof Array && mt.get('TENSORLIKE_CHECK_SHAPE_CONSISTENCY') && (function t(e, n, r) {
      if (r = r || [], e instanceof Array) { D(n.length > 0, () => `Element arr[${r.join('][')}] should be a primitive, but is an array of ${e.length} elements`), D(e.length === n[0], () => `Element arr[${r.join('][')}] should have ${n[0]} elements, but has ${e.length} elements`); for (let o = n.slice(1), i = 0; i < e.length; ++i)t(e[i], o, r.concat(i)); }
      else D(n.length === 0, () => `Element arr[${r.join('][')}] is a primitive, but should be an array of ${n[0]} elements`);
    }(t, n, [])), n;
  } function Kt(t, e, n, r) {
    if (void 0 === r && (r = 'float32'), r = r || 'float32', t instanceof Y) return t; if (!C(t) && !Array.isArray(t) && typeof t !== 'number' && typeof t !== 'boolean') throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got ${t.constructor.name}`); const o = $t(t);

    return C(t) || Array.isArray(t) || (t = [t]), Y.make(o, {values: M(t, r, mt.get('DEBUG'))}, r);
  } function Xt(t, n, r) {
    if (!Array.isArray(t)) throw new Error(`Argument ${n} passed to ${r} must be a \`Tensor[]\` or \`TensorLike[]\``);

    return t.map((t, e) => Kt(t, `${n}[${e}]`, r));
  } function Yt(t) {
    const e = Object.keys(t);

    if (e.length !== 1) throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`); let r = e[0]; const o = t[r];

    r.endsWith('_') && (r = r.substring(0, r.length - 1)); const n = function () {
      for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; mt.engine.startScope(r); try {
        const n = o.apply(void 0, t);

        return n instanceof Promise && console.error('Cannot return a Promise inside of tidy.'), mt.engine.endScope(n), n;
      }
      catch (t) { throw mt.engine.endScope(null), t; }
    };

    return Object.defineProperty(n, 'name', {value: r, configurable: !0}), n;
  } const Qt = Yt({
    softmax_(t, r) {
      void 0 === r && (r = -1); const e = Kt(t, 'logits', 'softmax');

      if (r === -1 && (r = e.rank - 1), r !== e.rank - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${r}`);

      return yt((t) => {
        const e = t.logSumExp([r], !0); const n = t.toFloat().sub(e).exp();

        return {
          value: n,
          gradFunc(t) {
            const e = t.mul(n);

            return e.sub(e.sum([r], !0).mul(n));
          }
        };
      })(e);
    }
  }); const Jt = Yt({
    complex_(t, e) {
      const n = Kt(t, 'real', 'complex'); const r = Kt(e, 'imag', 'complex');

      return f(n.shape, r.shape, `real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`), mt.engine.runKernel((t) => t.complex(n, r), {$real: n, $imag: r});
    }
  }); const Zt = Yt({
    real_(t) {
      const e = Kt(t, 'input', 'real');

      return mt.engine.runKernel((t) => t.real(e), {$input: e});
    }
  }); const te = Yt({
    imag_(t) {
      const e = Kt(t, 'input', 'imag');

      return mt.engine.runKernel((t) => t.imag(e), {$input: e});
    }
  });

  function ee(t, e, n) {
    if (void 0 === n && (n = 'float32'), n === 'complex64') throw new Error('Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).'); if (!C(t) && !Array.isArray(t) && typeof t !== 'number' && typeof t !== 'boolean') throw new Error('values passed to tensor(values) must be an array of numbers or booleans, or a TypedArray'); const r = $t(t);

    return e != null && r.length !== 1 && f(e, r, `Error creating a new Tensor. Inferred shape (${r}) does not match the provided shape (${e}). `), C(t) || Array.isArray(t) || (t = [t]), e = e || r, Y.make(e, {values: M(t, n, mt.get('DEBUG'))}, n);
  } function ne(t, e) {
    if (void 0 === e && (e = 'float32'), (C(t) || Array.isArray(t)) && e !== 'complex64') throw new Error('Error creating a new Scalar: value must be a primitive (number|boolean)');

    return ee(t, [], e);
  } function re(t, e) {
    void 0 === e && (e = 'float32'), i(t); const n = $t(t);

    if (n.length !== 1) throw new Error('tensor1d() requires values to be a flat/TypedArray');

    return ee(t, n, e);
  } function oe(t, e, n) {
    if (void 0 === n && (n = 'float32'), i(t), e != null && e.length !== 2) throw new Error('tensor2d() requires shape to have two numbers'); const r = $t(t);

    if (r.length !== 2 && r.length !== 1) throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray'); if (r.length === 1 && e == null) throw new Error('tensor2d() requires shape to be provided when `values` are a flat/TypedArray');

    return ee(t, e = e || r, n);
  } function ie(t, e, n) {
    if (void 0 === n && (n = 'float32'), i(t), e != null && e.length !== 3) throw new Error('tensor3d() requires shape to have three numbers'); const r = $t(t);

    if (r.length !== 3 && r.length !== 1) throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray'); if (r.length === 1 && e == null) throw new Error('tensor3d() requires shape to be provided when `values` are a flat array');

    return ee(t, e = e || r, n);
  } function ae(t, e, n) {
    if (void 0 === n && (n = 'float32'), i(t), e != null && e.length !== 4) throw new Error('tensor4d() requires shape to have four numbers'); const r = $t(t);

    if (r.length !== 4 && r.length !== 1) throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray'); if (r.length === 1 && e == null) throw new Error('tensor4d() requires shape to be provided when `values` are a flat array');

    return ee(t, e = e || r, n);
  } function se(t, e, n) {
    if (void 0 === n && (n = 'float32'), i(t), e != null && e.length !== 5) throw new Error('tensor5d() requires shape to have five numbers'); const r = $t(t);

    if (r.length !== 5 && r.length !== 1) throw new Error('tensor5d() requires values to be number[][][][][] or flat/TypedArray'); if (r.length === 1 && e == null) throw new Error('tensor5d() requires shape to be provided when `values` are a flat array');

    return ee(t, e = e || r, n);
  } function ue(t, e, n) {
    if (void 0 === n && (n = 'float32'), i(t), e != null && e.length !== 6) throw new Error('tensor6d() requires shape to have six numbers'); const r = $t(t);

    if (r.length !== 6 && r.length !== 1) throw new Error('tensor6d() requires values to be number[][][][] or flat/TypedArray'); if (r.length === 1 && e == null) throw new Error('tensor6d() requires shape to be provided when `values` are a flat array');

    return ee(t, e = e || r, n);
  } function ce(t, e) {
    if (void 0 === e && (e = 'float32'), e === 'complex64') {
      const n = ce(t, 'float32'); const r = ce(t, 'float32');

      return Jt(n, r);
    } const o = O(B(t), e);

    return Y.make(t, {values: o}, e);
  } function le(t, e) {
    if (void 0 === e && (e = 'float32'), e === 'complex64') {
      const n = le(t, 'float32'); const r = le(t, 'float32');

      return Jt(n, r);
    } const o = P(B(t), e);

    return Y.make(t, {values: o}, e);
  } function he(t, e, n) {
    void 0 === n && (n = 'float32'); const r = b(n, B(t));

    return r.fill(e), Y.make(t, {values: r}, n);
  } function pe(t, e, n) {
    if (n === 0) throw new Error('Cannot request zero samples'); const r = (e - t) / (n - 1); const o = P(n, 'float32');

    o[0] = t; for (let i = 1; i < o.length; i++)o[i] = o[i - 1] + r;

    return re(o, 'float32');
  } function fe(t, e, n, r) {
    if (void 0 === n && (n = 1), void 0 === r && (r = 'float32'), n === 0) throw new Error('Cannot have a step of zero'); if (t === e || t < e && n < 0 || e < t && n > 1) return le([0], r); const o = P(Math.abs(Math.ceil((e - t) / n)), r);

    e < t && n === 1 && (n = -1), o[0] = t; for (let i = 1; i < o.length; i++)o[i] = o[i - 1] + n;

    return re(o, r);
  } let de; let me; let ve; let ge; let ye; let xe; let be; let we; let Ee; let Se; let _e; let Ce; const Re = Yt({
    onesLike_(t) {
      const e = Kt(t, 'x', 'onesLike');

      return ce(e.shape, e.dtype);
    }
  }); const Te = Yt({
    zerosLike_(t) {
      const e = Kt(t, 'x', 'zerosLike');

      return le(e.shape, e.dtype);
    }
  });

  (Ce = de || (de = {})).float32 = 'float32', Ce.int32 = 'int32', Ce.bool = 'bool', (_e = me || (me = {})).R0 = 'R0', _e.R1 = 'R1', _e.R2 = 'R2', _e.R3 = 'R3', _e.R4 = 'R4', _e.R5 = 'R5', _e.R6 = 'R6', (Se = ve || (ve = {})).float32 = 'float32', Se.int32 = 'int32', Se.bool = 'int32', Se.complex64 = 'complex64', (Ee = ge || (ge = {})).float32 = 'float32', Ee.int32 = 'int32', Ee.bool = 'bool', Ee.complex64 = 'complex64', (we = ye || (ye = {})).float32 = 'float32', we.int32 = 'float32', we.bool = 'float32', we.complex64 = 'complex64', (be = xe || (xe = {})).float32 = 'complex64', be.int32 = 'complex64', be.bool = 'complex64', be.complex64 = 'complex64'; const ke = {
    float32: ye, int32: ve, bool: ge, complex64: xe
  };

  function Ie(t, e) { return ke[t][e]; } function De(t) { return Ie(t, 'int32'); } const Ne = (function () {
    function t(t) { this.dataMover = t, this.data = new WeakMap(); }

    return t.prototype.get = function (t) { return this.data.has(t) || this.dataMover.moveData(t), this.data.get(t); }, t.prototype.set = function (t, e) { this.data.set(t, e); }, t.prototype.has = function (t) { return this.data.has(t); }, t.prototype.delete = function (t) { return this.data.delete(t); }, t;
  }());

  function Ae(t, e, n) {
    if (e === 'complex64') {
      if (t.dtype === 'complex64') return t.clone(); const r = le(t.shape); const o = t.toFloat(); var i = n.complex(o, r);

      return r.dispose(), o.dispose(), i;
    } if (!E(t.dtype, e)) return Y.make(t.shape, {dataId: t.dataId}, e); if (t.dtype === 'complex64') {
      const a = n.real(t);

      return i = a.cast(e), a.dispose(), i;
    } if (e === 'int32') return n.int(t); if (e !== 'bool') throw new Error(`Error in Cast: unknown dtype argument (${e})`); const s = ne(0, t.dtype);

    return i = n.notEqual(t, s), s.dispose(), i;
  } function Me(t, e) { return Y.make(e, {dataId: t.dataId}, t.dtype); } function Oe(t, e) {
    if (t.length !== e.length) throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`); for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2)n[r] = t[r / 2], n[r + 1] = e[r / 2];

    return n;
  } function Pe(t, e, n, r, o) {
    for (var i = Array.from(e).map((t, e) => ({score: t, boxIndex: e})).filter((t) => t.score > o).sort((t, e) => e.score - t.score), a = [], s = 0; s < i.length; s++) {
      const u = i[s]; const c = u.score; const l = u.boxIndex;

      if (c < o) break; for (var h = !1, p = a.length - 1; p >= 0; --p) if (Fe(t, l, a[p]) >= r) { h = !0; break; } if (!h && (a.push(l), a.length >= n)) break;
    }

    return re(a, 'int32');
  } function Fe(t, e, n) {
    const r = t.subarray(4 * e, 4 * e + 4); const o = t.subarray(4 * n, 4 * n + 4); const i = Math.min(r[0], r[2]); const a = Math.min(r[1], r[3]); const s = Math.max(r[0], r[2]); const u = Math.max(r[1], r[3]); const c = Math.min(o[0], o[2]); const l = Math.min(o[1], o[3]); const h = Math.max(o[0], o[2]); const p = Math.max(o[1], o[3]); const f = (s - i) * (u - a); const d = (h - c) * (p - l);

    if (f <= 0 || d <= 0) return 0; const m = Math.max(i, c); const v = Math.max(a, l); const g = Math.min(s, h); const y = Math.min(u, p); const x = Math.max(g - m, 0) * Math.max(y - v, 0);

    return x / (f + d - x);
  } function Le(n, t, r) {
    const o = Array(n.rank).fill(0); const i = n.shape.slice();

    return t.map((t) => {
      i[r] = t; const e = n.slice(o, i);

      return o[r] += t, e;
    });
  } function Be(t, e, n, r, o) {
    for (var i = e[e.length - 1], a = [t.length / i, i], s = a[0], u = a[1], c = b(n, s * r), l = b('int32', s * r), h = 0; h < s; h++) {
      for (var p = h * u, f = t.subarray(p, p + u), d = [], m = 0; m < f.length; m++)d.push({value: f[m], index: m}); d.sort((t, e) => e.value - t.value); const v = h * r; const g = c.subarray(v, v + r); const y = l.subarray(v, v + r);

      for (m = 0; m < r; m++)g[m] = d[m].value, y[m] = d[m].index;
    } const x = e.slice();

    return x[x.length - 1] = r, [ee(c, x, n), ee(l, x, 'int32')];
  } const ze = function (t, e, n) {
    this.variableNames = ['A']; const r = t.windowSize; const o = t.batchSize; const i = t.inSize; const a = Math.ceil(i / r);

    n || this.variableNames.push('bestIndicesA'), this.outputShape = [o, a]; const s = e === 'max' ? '>' : '<';
    const u = n ? 'inOffset + i;' : 'round(getBestIndicesA(batch, inOffset + i));';

    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${u};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${s} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;
  }; const We = function (t) {
    this.variableNames = ['dy'], this.outputShape = t.inShape; const e = t.filterHeight; const n = t.filterWidth; const r = t.strideHeight; const o = t.strideWidth; const i = t.dilationHeight; const a = t.dilationWidth; const s = t.effectiveFilterHeight; const u = t.effectiveFilterWidth; const c = s - 1 - t.padInfo.top; const l = u - 1 - t.padInfo.left; const h = 1 / (e * n);

    this.userCode = `\n      const ivec2 pads = ivec2(${c}, ${l});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
  };

  function Ue(t, e) {
    for (var n = t.length, r = [], o = 0; o < n; o++) {
      const i = n - 1 - o; const a = t[i] || 1;

      (e[e.length - 1 - o] || 1) > 1 && a === 1 && r.unshift(i);
    }

    return r;
  } function Ve(t, e) {
    for (var n = [], r = 0; r < e.length; r++) {
      const o = t[t.length - r - 1]; const i = e.length - r - 1; const a = e[i];

      (o == null || o === 1 && a > 1) && n.unshift(i);
    }

    return n;
  } function Ge(t, e) {
    for (var n = [], r = Math.max(t.length, e.length), o = 0; o < r; o++) {
      let i = t[t.length - o - 1];

      i == null && (i = 1); let a = e[e.length - o - 1];

      if (a == null && (a = 1), i === 1)n.unshift(a); else if (a === 1)n.unshift(i); else { if (i !== a) throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`); n.unshift(i); }
    }

    return n;
  } const qe = function (t, e, n, r, o, i) {
    this.outputShape = [], this.supportsBroadcasting = !0, this.variableNames = ['x', 'mean', 'variance'], Ge(t, e), Ge(t, n); let a = '0.0';

    r != null && (Ge(t, r), this.variableNames.push('offset'), a = 'getOffsetAtOutCoords()'); let s = '1.0';

    o != null && (Ge(t, o), this.variableNames.push('scale'), s = 'getScaleAtOutCoords()'), this.outputShape = t, this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${s};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `;
  }; const je = function (t, e, n, r, o, i) {
    this.supportsBroadcasting = !0, this.usesPackedTextures = !0, this.variableNames = ['x', 'mean', 'variance'], Ge(t, e), Ge(t, n); const a = He('mean', e.length); const s = He('variance', n.length); let u = 'vec4 offset = vec4(0.0)';

    r != null && (Ge(t, r), this.variableNames.push('offset'), u = He('offset', r.length)); let c = 'vec4 scale = vec4(1.0)';

    o != null && (Ge(t, o), this.variableNames.push('scale'), c = He('scale', o.length)), this.outputShape = t, this.userCode = `\n      void main() {\n        ivec4 rc = getOutputCoords();\n\n        ${u};\n        ${c};\n\n        vec4 x = getX(rc.x, rc.y, rc.z, rc.w);\n        ${a};\n        ${s};\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `;
  };

  function He(t, e) {
    const n = `get${t.charAt(0).toUpperCase()}${t.slice(1)}`;

    return e === 1 ? `\n      vec4 ${t}Sample = ${n}(rc.w);\n      vec4 ${t} = vec4(${t}Sample.xy, ${t}Sample.xy);\n    ` : `vec4 ${t} = ${n}(rc.x, rc.y, rc.z, rc.w)`;
  } const $e = 'return areal * breal - aimag * bimag;'; const Ke = 'return areal * bimag + aimag * breal;'; const Xe = function (t, e, n) { this.variableNames = ['AReal', 'AImag', 'BReal', 'BImag'], this.supportsBroadcasting = !0, this.outputShape = Ge(e, n), this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `; }; const Ye = 'return a + b;'; const Qe = 'return a - b;'; const Je = (function () {
    function t(t, e, n) { this.variableNames = ['A', 'B'], this.supportsBroadcasting = !0, this.outputShape = Ge(e, n), this.userCode = `\n      uniform float NAN;\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `; }

    return t.prototype.getCustomSetupFunc = function () {
      const n = this;

      return function (t, e) { n.startLoc == null && (n.startLoc = t.getUniformLocationNoThrow(e, 'NAN'), n.startLoc == null) || t.gl.uniform1f(n.startLoc, NaN); };
    }, t;
  }()); const Ze = function (t, e, n) { this.variableNames = ['A'], this.outputShape = t, this.userCode = `\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, float(${e}), float(${n})));\n      }\n    `; }; const tn = function (t) { this.variableNames = ['real', 'imag'], this.outputShape = t, this.userCode = '\n      void main() {\n        float real = getRealAtOutCoords();\n        float imag = getImagAtOutCoords();\n        vec2 v = vec2(real, imag);\n\n        setOutput(sqrt(dot(v, v)));\n      }\n    '; }; const en = function (t, e) { this.variableNames = ['A', 'B'], this.outputShape = [], this.outputShape = zt([t, e], 1), this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < ${t[1]}) {\n          value = getA(yR, yC);\n        } else {\n          yC -= ${t[1]};\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    `; }; const nn = function (t) {
    this.variableNames = ['x', 'dy'], this.outputShape = t.filterShape; const e = t.strideHeight; const n = t.strideWidth; const r = t.padInfo.top; const o = t.padInfo.left;

    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
  }; const rn = function (t) {
    this.variableNames = ['dy', 'W'], this.outputShape = t.inShape; const e = t.filterHeight; const n = t.filterWidth; const r = t.strideHeight; const o = t.strideWidth; const i = e - 1 - t.padInfo.top; const a = n - 1 - t.padInfo.left;

    this.userCode = `\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
  }; const on = function (t) {
    this.variableNames = ['x', 'dy'], this.outputShape = t.filterShape; const e = t.strideHeight; const n = t.strideWidth; const r = t.padInfo.top; const o = t.padInfo.left; const i = t.outChannels / t.inChannels;

    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
  }; const an = function (t) {
    this.variableNames = ['dy', 'W'], this.outputShape = t.inShape; const e = t.filterHeight; const n = t.filterWidth; const r = t.strideHeight; const o = t.strideWidth; const i = e - 1 - t.padInfo.top; const a = n - 1 - t.padInfo.left; const s = t.outChannels / t.inChannels;

    this.userCode = `\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
  }; const sn = function (t) {
    this.variableNames = ['x', 'W'], this.outputShape = t.outShape; const e = t.padInfo.top; const n = t.padInfo.left; const r = t.strideHeight; const o = t.strideWidth; const i = t.dilationHeight; const a = t.dilationWidth; const s = t.filterHeight; const u = t.filterWidth; const c = 4 * Math.floor(t.inChannels / 4); const l = t.inChannels % 4;

    this.userCode = `\n      const ivec2 strides = ivec2(${r}, ${o});\n      const ivec2 pads = ivec2(${e}, ${n});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * ${i};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${u}; wC++) {\n            int xC = xCCorner + wC * ${a};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${c}; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (${l === 1}) {\n              dotProd +=\n                getX(batch, xR, xC, ${c}) *\n                getW(wR, wC, ${c}, d2);\n            } else if (${l === 2}) {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, ${c}),\n                getX(batch, xR, xC, ${c} + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, ${c}, d2),\n                getW(wR, wC, ${c} + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (${l === 3}) {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, ${c}),\n                getX(batch, xR, xC, ${c} + 1),\n                getX(batch, xR, xC, ${c} + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, ${c}, d2),\n                getW(wR, wC, ${c} + 1, d2),\n                getW(wR, wC, ${c} + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
  }; const un = function (t) {
    this.variableNames = ['x', 'W'], this.outputShape = t.outShape; const e = t.inHeight; const n = t.inWidth; const r = t.padInfo.top; const o = t.padInfo.left; const i = t.strideHeight; const a = t.strideWidth; const s = t.dilationHeight; const u = t.dilationWidth; const c = t.filterHeight; const l = t.filterWidth; const h = t.outChannels / t.inChannels;

    this.userCode = `\n      const ivec2 strides = ivec2(${i}, ${a});\n      const ivec2 pads = ivec2(${r}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${h};\n        int q = d2 - d1 * ${h};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${s};\n\n          if (xR < 0 || xR >= ${e}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${l}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${n}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
  }; const cn = function (t, e, n, r, o) {
    this.variableNames = ['Image', 'Boxes', 'BoxInd'], this.outputShape = []; const i = t[0]; const a = t[1]; const s = t[2]; const u = t[3]; const c = e[0]; const l = n[0]; const h = n[1];

    this.outputShape = [c, l, h, u]; const p = r === 'bilinear' ? 1 : 0; const f = [`${a - 1}.0`, `${s - 1}.0`]; const d = f[0]; const m = f[1]; const v = l > 1 ? [`${(a - 1) / (l - 1)}`, '(y2-y1) * height_ratio', `y1*${d} + float(y)*(height_scale)`] : ['0.0', '0.0', `0.5 * (y1+y2) * ${d}`]; const g = v[0]; const y = v[1]; const x = v[2]; const b = h > 1 ? [`${(s - 1) / (h - 1)}`, '(x2-x1) * width_ratio', `x1*${m} + float(x)*(width_scale)`] : ['0.0', '0.0', `0.5 * (x1+x2) * ${m}`]; const w = b[0]; const E = b[1]; const S = b[2];

    this.userCode = `\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${w});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${E};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${d} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${S};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\n\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          float newValue = top + (bottom - top) * fracRC.x;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestRC = ivec2(floor(\n            sourceFracIndexRC + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\n          setOutput(newValue);\n        }\n      }\n    `;
  };

  function ln(t, i, e, a) {
    let n = t.map((t) => {
      const e = B(t.shapeInfo.logicalShape);

      return t.shapeInfo.isUniform ? `uniform float ${t.name}${e > 1 ? `[${e}]` : ''};` : `uniform sampler2D ${t.name};`;
    });

    n = n.join('\n'); let r; let o; const s = t.map((t) => {
      return n = i, r = a, o = (function (t) {
        const e = t.name; const n = `get${e.charAt(0).toUpperCase() }${e.slice(1)}Flat`; const r = B(t.shapeInfo.logicalShape);

        if (t.shapeInfo.isUniform) return r === 1 ? `float ${n}(int index) {return ${e};}` : `\n      float ${n}(int index) {\n        for (int i = 0; i < ${r}; i++) {\n          if (i == index) {\n            return ${e}[i];\n          }\n        }\n      }\n    `; const o = t.shapeInfo.texShape; const i = o[0]; const a = o[1];

        return a === 1 && i === 1 ? `\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    ` : a === 1 ? `\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / ${i}.0);\n        return sampleTexture(${e}, uv);\n      }\n    ` : i === 1 ? `\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    ` : `\n    float ${n}(int index) {\n      vec2 uv = UVfrom1D(${i}, ${a}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `;
      }(e = t)), e.shapeInfo.isPacked ? o += (function (t) {
        let e; let n; let r; let o; let i; let a; let s; let u; let c; let l; let h; let p; let f; let d; let m; const v = t.shapeInfo.logicalShape;

        switch (v.length) {
          case 1: return p = (h = t).name, f = `get${p.charAt(0).toUpperCase()}${p.slice(1)}`, d = h.shapeInfo.texShape, m = [Math.ceil(d[0] / 2), Math.ceil(d[1] / 2)], `\n    vec4 ${f}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${m[0]}, ${m[1]}, index);\n      return texture2D(${p}, uv);\n    }\n  `; case 2: return (function (t) {
            const e = t.shapeInfo.logicalShape; const n = t.name; const r = `get${  n.charAt(0).toUpperCase()  }${n.slice(1)}`; const o = t.shapeInfo.texShape; const i = o[0]; const a = o[1];

            if (o != null && T(e, o)) return `\n      vec4 ${ r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${ i }.0);\n\n        return texture2D(${ n}, uv);\n      }\n    `; const s = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];

            return `\n    vec4 ${ r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${ Math.ceil(e[1] / 2)}, ${s[0] }, ${ s[1]}, row, col);\n      return texture2D(${ n }, uv);\n    }\n  `; 
          }(t)); case 4: return n = (e = t).shapeInfo.logicalShape, r = e.name, o = `get${r.charAt(0).toUpperCase()}${r.slice(1)}`, i = e.shapeInfo.texShape, a = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)], s = a[0], u = a[1], c = Math.ceil(n[3] / 2), l = c * Math.ceil(n[2] / 2), `\n    vec4 ${o}(int b2, int b, int row, int col) {\n      vec2 uv = packedUVfrom4D(\n        ${s}, ${u}, ${l * n[1]},\n        ${l}, ${c}, b2, b, row, col);\n      return texture2D(${r}, uv);\n    }\n  `; default: throw new Error(`Packed ${v.length}-D input sampling is not yet supported`);
        }
      }(e)) : o += hn(e), (r || T(e.shapeInfo.logicalShape, n.logicalShape)) && (o += (function (t, e, n) {
        const r = t.name; const o = r.charAt(0).toUpperCase() + r.slice(1); const i = `get${o}AtOutCoords`; const a = Ue(t.shapeInfo.logicalShape, e.logicalShape); const s = t.shapeInfo.logicalShape.length; const u = e.logicalShape.length; const c = n && (s < u || a.length > 0); const l = (function (t) {
          for (let e = 0; e < t.length; e++) if (t[e] !== e) return !1;

          return !0;
        }(a)); const h = t.shapeInfo.isUniform;

        if (c && !l) {
          return (function (t, e, n, r) {
            let o = t.shapeInfo.logicalShape.length; const i = e.logicalShape.length; let a = 'int';

            2 === i ? a = 'ivec2' : i === 3 ? a = 'ivec3' : i === 4 && (a = 'ivec4'); const s = Ue(t.shapeInfo.logicalShape, e.logicalShape); const u = i - o;

            return `\n    float ${  r  }() {\n      ${  a  } coords = getOutputCoords();\n      ${  o === 0 ? '':i < 2 && s.length >= 1 ? 'coords = 0;':s.map((t) => "coords["+(t+u)+"] = 0;").join('\n')  }\n      return get${  n  }(${  i < 2 && o > 0 ? 'coords':t.shapeInfo.logicalShape.map((t, e) => "coords["+(e+u)+"]").join(', ')  });\n    }\n  ` 
          }(t, e, o, i));
        } const p = B(t.shapeInfo.logicalShape); let f = '';

        c && l && (f = `\n        int mainPart = index / ${p};\n        index -= mainPart * ${p};\n      `); const d = e.texShape;

        if (h) return p === 1 ? `float ${i}() {return ${r};}` : `\n      float ${i}() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                              vec2(${d[0]}, ${d[1]}));\n        int index = resTexRC.x * ${d[1]} + resTexRC.y;\n        ${f}\n        return get${o}Flat(index);\n      }\n    `; const m = t.shapeInfo.texShape;

        return T(m, d) ? `\n      float ${i}() {\n        return sampleTexture(${r}, resultUV);\n      }\n    ` : `\n    float ${i}() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${d[0]}, ${d[1]}));\n      int index = resTexRC.x * ${d[1]} + resTexRC.y;\n      ${f}\n      int texR = index / ${m[1]};\n      int texC = index - texR * ${m[1]};\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(${m[1]}.0, ${m[0]}.0);\n\n      return sampleTexture(${r}, uv);\n    }\n  `;
      }(e, n, r))), o; let e, n, r, o;
    }).join('\n'); const u = i.texShape;

    return i.isPacked ? (r = (function (t, e) {
      switch (t.length) {
        case 0: return '\n    int getOutputCoords() {\n      return 0;\n    }\n  '; case 1: return u = e, c = [Math.ceil(u[0] / 2), Math.ceil(u[1] / 2)], u[0] === 1 ? `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${c[1]}.0);\n      }\n    ` : u[1] === 1 ? `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${c[0]}.0);\n      }\n    ` : `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${c[0]}, ${c[1]}));\n      return resTexRC.x * ${c[1]} + resTexRC.y;\n    }\n  `; case 2: return (function (t, e) {
          const n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];

          if (T(t, e)) return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `; const r = Math.ceil(t[1] / 2);

          return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `;
        }(t, e)); case 4: return n = t, r = e, o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], i = Math.ceil(n[3] / 2), a = i * Math.ceil(n[2] / 2), s = a * n[1], `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n      int index = resTexRC.x * ${o[1]} + resTexRC.y;\n\n      int b2 = index / ${s};\n      index -= b2 * ${s};\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${i});\n      int c = int(mod(float(index), ${i}.)) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  `; default: throw new Error(`${t.length}-D output packed sampling is not yet supported`);
      } let n, r, o, i, a, s; let u, c;
    }(i.logicalShape, u)), o = dn) : (r = (function (t, e) { switch (t.length) { case 0: return '\n    int getOutputCoords() {\n      return 0;\n    }\n  '; case 1: return (R = e)[0] === 1 ? `\n      int getOutputCoords() {\n        return int(resultUV.x * ${R[1]}.0);\n      }\n    ` : R[1] === 1 ? `\n      int getOutputCoords() {\n        return int(resultUV.y * ${R[0]}.0);\n      }\n    ` : `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${R[0]}, ${R[1]}));\n      return resTexRC.x * ${R[1]} + resTexRC.y;\n    }\n  `; case 2: return T(_ = t, C = e) ? `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${C[0]}, ${C[1]}));\n      }\n    ` : _[1] === 1 ? `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${C[0]}, ${C[1]}));\n        int index = resTexRC.x * ${C[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ` : _[0] === 1 ? `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${C[0]}, ${C[1]}));\n        int index = resTexRC.x * ${C[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ` : `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${C[0]}, ${C[1]}));\n      int index = resTexRC.x * ${C[1]} + resTexRC.y;\n      int r = index / ${_[1]};\n      int c = index - r * ${_[1]};\n      return ivec2(r, c);\n    }\n  `; case 3: return w = e, E = (b = t)[1] * b[2], S = b[2], `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${w[0]}, ${w[1]}));\n      int index = resTexRC.x * ${w[1]} + resTexRC.y;\n      int r = index / ${E};\n      index -= r * ${E};\n      int c = index / ${S};\n      int d = index - c * ${S};\n      return ivec3(r, c, d);\n    }\n  `; case 4: return v = e, g = (m = t)[3], y = m[2] * g, x = m[1] * y, `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${v[0]}, ${v[1]}));\n      int index = resTexRC.x * ${v[1]} + resTexRC.y;\n\n      int r = index / ${x};\n      index -= r * ${x};\n\n      int c = index / ${y};\n      index -= c * ${y};\n\n      int d = index / ${g};\n      int d2 = index - d * ${g};\n\n      return ivec4(r, c, d, d2);\n    }\n  `; case 5: return l = e, h = (c = t)[4], p = c[3] * h, f = c[2] * p, d = c[1] * f, `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${l[0]},\n                             ${l[1]}));\n\n      int index = resTexRC.x * ${l[1]} + resTexRC.y;\n\n      int r = index / ${d};\n      index -= r * ${d};\n\n      int c = index / ${f};\n      index -= c * ${f};\n\n      int d = index / ${p};\n      index -= d * ${p};\n\n      int d2 = index  / ${h};\n      int d3 = index - d2 * ${h};\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `; case 6: return r = e, o = (n = t)[5], i = n[4] * o, a = n[3] * i, s = n[2] * a, u = n[1] * s, `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int r = index / ${u};\n      index -= r * ${u};\n\n      int c = index / ${s};\n      index -= c * ${s};\n\n      int d = index / ${a};\n      index -= d * ${a};\n\n      int d2 = index / ${i};\n      index -= d2 * ${i};\n\n      int d3 = index / ${o};\n      int d4 = index - d3 * ${o};\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `; default: throw new Error(`${t.length}-D output sampling is not yet supported`); } let n, r, o, i, a, s, u; let c, l, h, p, f, d; let m, v, g, y, x; let b, w, E, S; let _, C; let R; }(i.logicalShape, u)), o = fn), [mn, pn, o, n, r, s, e].join('\n');
  } function hn(t) {
    let e; let n; let r; let o; let i; const a = t.shapeInfo.logicalShape;

    switch (a.length) {
      case 0: return o = (r = t).name, i = `get${o.charAt(0).toUpperCase()}${o.slice(1)}`, r.shapeInfo.isUniform ? `float ${i}() {return ${o};}` : `\n    float ${i}() {\n      return sampleTexture(${o}, halfCR);\n    }\n  `; case 1: return e = t.name, `\n    float ${n = `get${e.charAt(0).toUpperCase()}${e.slice(1)}`}(int index) {\n      return ${n}Flat(index);\n    }\n  `; case 2: return (function (t) {
        const e = t.shapeInfo.logicalShape; const n = t.name; const r = `get${n.charAt(0).toUpperCase()}${n.slice(1)}`; const o = t.shapeInfo.texShape;

        if (o != null && T(e, o)) {
          const i = o[0];

          return `\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${i}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;
        } const a = y(e); const s = a.newShape; const u = a.keptDims; const c = s;

        if (c.length < e.length) return `\n      ${hn(gn(t, c))}\n      float ${r}(int row, int col) {\n        return ${r}(${yn(['row', 'col'], u)});\n      }\n    `; if (t.shapeInfo.isUniform) return `\n      float ${r}(int row, int col) {\n        float index = dot(vec2(row, col), vec2(${e[1]}, 1));\n        return ${r}Flat(round(index));\n      }\n    `; const l = o[0]; const h = o[1];

        return h === 1 ? `\n    float ${r}(int row, int col) {\n      float index = dot(vec2(row, col), vec2(${e[1]}, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  ` : l === 1 ? `\n    float ${r}(int row, int col) {\n      float index = dot(vec2(row, col), vec2(${e[1]}, 1));\n      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  ` : `\n  float ${r}(int row, int col) {\n    vec2 uv = UVfrom2D(${l}, ${h}, ${e[1]}, row, col);\n    return sampleTexture(${n}, uv);\n  }\n`;
      }(t)); case 3: return (function (t) {
        const e = t.shapeInfo.logicalShape; const n = t.name; const r = `get${n.charAt(0).toUpperCase()}${n.slice(1)}`; const o = e[1] * e[2]; const i = e[2]; const a = y(e); const s = a.newShape; const u = a.keptDims; const c = s;

        if (c.length < e.length) return `\n        ${hn(gn(t, c))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${yn(['row', 'col', 'depth'], u)});\n        }\n      `; if (t.shapeInfo.isUniform) return `\n      float ${r}(int row, int col, int depth) {\n        float index = dot(vec3(row, col, depth),\n                          vec3(${o}, ${i}, 1));\n        return ${r}Flat(round(index));\n      }\n    `; const l = t.shapeInfo.texShape; const h = l[0]; const p = l[1];

        return p === o ? `\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${h}.0);\n          return sampleTexture(${n}, uv);\n        }\n      ` : p === i ? `\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);\n      return sampleTexture(${n}, uv);\n    }\n  ` : `\n      float ${r}(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            ${h}, ${p}, ${o}, ${i}, row, col, depth);\n        return sampleTexture(${n}, uv);\n      }\n  `;
      }(t)); case 4: return (function (t) {
        const e = t.shapeInfo.logicalShape; const n = t.name; const r = `get${n.charAt(0).toUpperCase()}${n.slice(1)}`; const o = e[3]; const i = e[2] * o; const a = e[1] * i; const s = y(e); const u = s.newShape; const c = s.keptDims;

        if (u.length < e.length) return `\n      ${hn(gn(t, u))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${yn(['row', 'col', 'depth', 'depth2'], c)});\n      }\n    `; if (t.shapeInfo.isUniform) return `\n      float ${r}(int row, int col, int depth, int depth2) {\n        float index = dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${o}, 1));\n        return ${r}Flat(round(index));\n      }\n    `; const l = t.shapeInfo.texShape; const h = l[0]; const p = l[1];

        return p === a ? `\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2), vec3(${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    ` : p === o ? `\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1] * e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    ` : `\n    float ${r}(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(${h}, ${p}, ${a}, ${i},\n          ${o}, row, col, depth, depth2);\n      return sampleTexture(${n}, uv);\n    }\n  `;
      }(t)); case 5: return (function (t) {
        const e = t.shapeInfo.logicalShape; const n = t.name; const r = `get${n.charAt(0).toUpperCase()}${n.slice(1)}`; const o = e[4]; const i = e[3] * o; const a = e[2] * i; const s = e[1] * a; const u = y(e); const c = u.newShape; const l = u.keptDims;

        if (c.length < e.length) return `\n      ${hn(gn(t, c))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${yn(['row', 'col', 'depth', 'depth2', 'depth3'], l)});\n      }\n    `; if (t.shapeInfo.isUniform) return `\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${s}, ${a}, ${i}, ${o})) +\n          depth3;\n        return ${r}Flat(index);\n      }\n    `; const h = t.shapeInfo.texShape; const p = h[0]; const f = h[1];

        return f === s ? `\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(\n          vec4(col, depth, depth2, depth3),\n          vec4(${a}, ${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    ` : f === o ? `\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1] * e[2] * e[3]}, ${e[2] * e[3]},\n            ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    ` : `\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      vec2 uv = UVfrom5D(${p}, ${f}, ${s}, ${a},\n          ${i}, ${o}, row, col, depth, depth2, depth3);\n      return sampleTexture(${n}, uv);\n    }\n  `;
      }(t)); case 6: return (function (t) {
        const e = t.shapeInfo.logicalShape; const n = t.name; const r = `get${n.charAt(0).toUpperCase()}${n.slice(1)}`; const o = e[5]; const i = e[4] * o; const a = e[3] * i; const s = e[2] * a; const u = e[1] * s; const c = y(e); const l = c.newShape; const h = c.keptDims;

        if (l.length < e.length) return `\n      ${hn(gn(t, l))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${yn(['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'], h)});\n      }\n    `; if (t.shapeInfo.isUniform) return `\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${s}, ${a}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1));\n        return ${r}Flat(index);\n      }\n    `; const p = t.shapeInfo.texShape; const f = p[0]; const d = p[1];

        return d === u ? `\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(\n          vec4(col, depth, depth2, depth3),\n          vec4(${s}, ${a}, ${i}, ${o})) + depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    ` : d === o ? `\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1] * e[2] * e[3] * e[4]},\n               ${e[2] * e[3] * e[4]},\n               ${e[3] * e[4]},\n               ${e[4]})) + depth3;\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    ` : `\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      vec2 uv = UVfrom6D(${f}, ${d}, ${u}, ${s},\n          ${a}, ${i}, ${o}\n          ,row, col, depth, depth2, depth3, depth4);\n      return sampleTexture(${n}, uv);\n    }\n  `;
      }(t)); default: throw new Error(`${a.length}-D input sampling is not yet supported`);
    }
  } var pn = '\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n'; var fn = '\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n'; var dn = '\n  void setOutput(vec4 val) {\n    gl_FragColor = val;\n  }\n'; var mn = '\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  struct ivec5\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n  };\n\n  struct ivec6\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n    int v;\n  };\n\n  bool isNaN(float val) {\n    return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  \nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n  \nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n  \nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n  \nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom4D(int texNumR, int texNumC, int texelsInBatch2,\n    int texelsInBatch, int texelsInLogicalRow, int b2, int b,\n    int row, int col) {\n  int index = b2 * texelsInBatch2 + b * texelsInBatch +\n    (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n  \nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int row, int col, int depth,\n    int depth2, int depth3) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 +\n              depth * stride2 + depth2 * stride3 + depth3;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n  \nvec2 UVfrom6D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int stride4,\n    int row, int col, int depth, int depth2, int depth3, int depth4) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2 *\n    stride3 + depth3 * stride4 + depth4;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n';

  function vn(t) { if (t <= 1) return 'int'; if (t === 2) return 'ivec2'; if (t === 3) return 'ivec3'; if (t === 4) return 'ivec4'; if (t === 5) return 'ivec5'; if (t === 6) return 'ivec6'; throw Error(`GPU for rank ${t} is not yet supported`); } function gn(t, e) {
    const n = JSON.parse(JSON.stringify(t));

    return n.shapeInfo.logicalShape = e, n;
  } function yn(e, t) { return t.map((t) => e[t]).join(', '); } const xn = function (t, e, n) {
    this.variableNames = ['x']; const r = (this.outputShape = t).length; const o = t[t.length - 1]; const i = n ? '<' : '>';

    this.userCode = `\n      int getIndex(int i) {\n        ${n ? `return ${o} -i - 1;` : 'return i;'}\n      }\n\n      void main() {\n        ${vn(r)} coords = getOutputCoords();\n        int end = ${bn(r, 'coords')};\n        float val = 0.0;\n        for (int i = ${o} - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx ${i} end) {\n            continue;\n          }\n          if (idx == end && ${e}) {\n            continue;\n          }\n          ${bn(r, 'coords')} = idx;\n          val += getX(${(function (t, e) { if (t === 1) return `${e}`; if (t === 2) return `${e}.x, ${e}.y`; if (t === 3) return `${e}.x, ${e}.y, ${e}.z`; if (t === 4) return `${e}.x, ${e}.y, ${e}.z, ${e}.w`; throw Error(`Cumulative sum for rank ${t} is not yet supported`); }(r, 'coords'))});\n        }\n        setOutput(val);\n      }\n    `;
  };

  function bn(t, e) { if (t === 1) return `${e}`; if (t === 2) return `${e}.y`; if (t === 3) return `${e}.z`; if (t === 4) return `${e}.w`; throw Error(`Cumulative sum for rank ${t} is not yet supported`); } const wn = (function () {
    function t(t, e, n) { this.variableNames = ['x'], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `; }

    return t.prototype.getHeightCoordString = function () { return this.dataFormat === 'NHWC' ? 'coords[1]' : 'coords[2]'; }, t.prototype.getWidthCoordString = function () { return this.dataFormat === 'NHWC' ? 'coords[2]' : 'coords[3]'; }, t.prototype.getDepthCoordString = function () { return this.dataFormat === 'NHWC' ? 'coords[3]' : 'coords[1]'; }, t.prototype.getOutputDepthSize = function () { return this.dataFormat === 'NHWC' ? this.outputShape[3] : this.outputShape[1]; }, t.prototype.getInputSamplingString = function () { return this.dataFormat === 'NHWC' ? 'getX(b, in_h, in_w, in_d)' : 'getX(b, in_d, in_h, in_w)'; }, t;
  }()); const En = function (t) { this.variableNames = ['A'], this.outputShape = t, this.userCode = '\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isNaN(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        gl_FragColor = encode_float(x);\n      }\n    '; }; const Sn = 'return real * expR - imag * expI;'; const _n = 'return real * expI + imag * expR;'; const Cn = function (t, e) {
    this.variableNames = ['real', 'imag']; const n = e[1];

    this.outputShape = e, this.userCode = `\n      const float negativeTwoPi = -2.0 * 3.1415926535897932384626433832795;\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${t}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${n});\n        float negativeTwoPiTimesIndexRatio = negativeTwoPi * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${n}; i++) {\n          // x = (-2 * PI / N) * index * i;\n          float x = negativeTwoPiTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result += unaryOpComplex(real, expR, imag, expI);\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;
  }; const Rn = function (t) {
    this.variableNames = ['A']; const e = t[0]; const n = t[1];

    this.outputShape = t, this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}.0, ${e}.0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `;
  }; const Tn = function (t, e, n) {
    this.variableNames = ['A', 'indices']; const r = t.slice();

    r[n] = e, this.outputShape = r, this.rank = r.length; const o = vn(this.rank); const i = (function (t, e) {
      const n = t.length;

      if (n > 4) throw Error(`Gather for rank ${n} is not yet supported`); if (n === 1) return 'int(getIndices(resRC))'; for (var r = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'], o = [], i = 0; i < t.length; i++)i === e ? o.push(`int(getIndices(${r[i]}))`) : o.push(`${r[i]}`);

      return o.join();
    }(t, n));

    this.userCode = `\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `;
  }; let kn; let In; let Dn; let Nn; const An = function (t, e, n) {
    this.sliceDim = t, this.strides = e, this.variableNames = ['x', 'indices'], this.outputShape = n; const r = vn(e.length); const o = vn(n.length); const i = this.sliceDim > 1 ? 'strides[j]' : 'strides';

    this.userCode = `\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${i};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `;
  };

  function Mn(t, e) { return [e, t]; } function On(t, e) { return t * e; } function Pn(t, e, n) {
    const r = (function (t, e) {
      if (t % e != 0) throw new Error(`unpackedSize (${t}) must be a multiple of ${e}`);

      return t / e;
    }(t.length, n));

    if (e.length < r) throw new Error(`matrix length (${e.length}) must be >= ${r}`); for (let o = 0, i = 0; i < t.length; i += n)e[o++] = t[i];
  } function Fn(t, e) { return [Math.ceil(e / 2), Math.ceil(t / 2)]; } function Ln(t, e) {
    const n = Fn(t, e);

    return n[0] * n[1] * 4;
  } function Bn(t) {
    const e = document.createElement('canvas');

    return e.width = 1, e.height = 1, zn(e, t);
  } function zn(t, e) {
    let n; const r = mt.get('WEBGL_VERSION');

    if (r === 2 ? n = t.getContext('webgl2', e) : r === 1 && (n = t.getContext('webgl', e) || t.getContext('experimental-webgl', e)), r === 0 || n == null) throw new Error('This browser does not support WebGL.');

    return n;
  } function Wn(t, e) {
    const n = e();

    return Gn(t), n;
  }(Nn = kn || (kn = {}))[Nn.RENDER = 0] = 'RENDER', Nn[Nn.UPLOAD = 1] = 'UPLOAD', Nn[Nn.PIXELS = 2] = 'PIXELS', Nn[Nn.DOWNLOAD = 3] = 'DOWNLOAD', (Dn = In || (In = {}))[Dn.UNPACKED_FLOAT16 = 0] = 'UNPACKED_FLOAT16', Dn[Dn.UNPACKED_FLOAT32 = 1] = 'UNPACKED_FLOAT32', Dn[Dn.PACKED_4X1_UNSIGNED_BYTE = 2] = 'PACKED_4X1_UNSIGNED_BYTE', Dn[Dn.PACKED_2X2_FLOAT32 = 3] = 'PACKED_2X2_FLOAT32'; let Un = !(Dn[Dn.PACKED_2X2_FLOAT16 = 4] = 'PACKED_2X2_FLOAT16');

  function Vn(t) { Un = t; } function Gn(t) {
    if (Un) {
      const e = t.getError();

      if (e !== t.NO_ERROR) throw new Error(`WebGL Error: ${qn(t, e)}`);
    }
  } function qn(t, e) { switch (e) { case t.NO_ERROR: return 'NO_ERROR'; case t.INVALID_ENUM: return 'INVALID_ENUM'; case t.INVALID_VALUE: return 'INVALID_VALUE'; case t.INVALID_OPERATION: return 'INVALID_OPERATION'; case t.INVALID_FRAMEBUFFER_OPERATION: return 'INVALID_FRAMEBUFFER_OPERATION'; case t.OUT_OF_MEMORY: return 'OUT_OF_MEMORY'; case t.CONTEXT_LOST_WEBGL: return 'CONTEXT_LOST_WEBGL'; default: return `Unknown error code ${e}`; } } function jn(t, e) { return fr(t, () => t.getExtension(e), `Extension "${e}" not supported on this browser.`); } function Hn(t, e) {
    const n = fr(t, () => t.createShader(t.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');

    if (Wn(t, () => t.shaderSource(n, e)), Wn(t, () => t.compileShader(n)), !1 === t.getShaderParameter(n, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(n)), new Error('Failed to compile vertex shader.');

    return n;
  } function $n(t, e) {
    const n = fr(t, () => t.createShader(t.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');

    if (Wn(t, () => t.shaderSource(n, e)), Wn(t, () => t.compileShader(n)), !1 === t.getShaderParameter(n, t.COMPILE_STATUS)) {
      throw (function (t, e) {
        const n = Kn.exec(e);

        if (n == null) return console.log(`Couldn't parse line number in error: ${e}`), console.log(t); for (var r = +n[1], o = t.split('\n'), i = o.length.toString().length + 2, a = o.map((t, e) => d((e + 1).toString(), i) + t), s = 0, u = 0; u < a.length; u++)s = Math.max(a[u].length, s); const c = a.slice(0, r - 1); const l = a.slice(r - 1, r); const h = a.slice(r);

        console.log(c.join('\n')), console.log(e.split('\n')[0]), console.log(`%c ${d(l[0], s)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717'), console.log(h.join('\n'));
      }(e, t.getShaderInfoLog(n))), new Error('Failed to compile fragment shader.');
    }

    return n;
  } var Kn = /ERROR: [0-9]+:([0-9]+):/g;

  function Xn(t) { return fr(t, () => t.createProgram(), 'Unable to create WebGLProgram.'); } function Yn(t, e) { if (Wn(t, () => t.linkProgram(e)), !1 === t.getProgramParameter(e, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(e)), new Error('Failed to link vertex and fragment shaders.'); } function Qn(t, e) { if (Wn(t, () => t.validateProgram(e)), !1 === t.getProgramParameter(e, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(e)), new Error('Shader program validation failed.'); } function Jn(t, e) {
    const n = fr(t, () => t.createBuffer(), 'Unable to create WebGLBuffer');

    return Wn(t, () => t.bindBuffer(t.ARRAY_BUFFER, n)), Wn(t, () => t.bufferData(t.ARRAY_BUFFER, e, t.STATIC_DRAW)), n;
  } function Zn(t, e) {
    const n = fr(t, () => t.createBuffer(), 'Unable to create WebGLBuffer');

    return Wn(t, () => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n)), Wn(t, () => t.bufferData(t.ELEMENT_ARRAY_BUFFER, e, t.STATIC_DRAW)), n;
  } function tr() { return mt.get('WEBGL_VERSION') === 2 ? 1 : 4; } function er(t) { return fr(t, () => t.createTexture(), 'Unable to create WebGLTexture.'); } function nr(t, e) {
    const n = mt.get('WEBGL_MAX_TEXTURE_SIZE');

    if (t <= 0 || e <= 0) {
      var r = `[${t}x${e}]`;

      throw new Error(`Requested texture size ${r} is invalid.`);
    } if (n < t || n < e) throw r = `[${t}x${e}]`, new Error(`Requested texture size ${r} greater than WebGL maximum on this browser / GPU [${n}x${n}].`);
  } function rr(t) { return fr(t, () => t.createFramebuffer(), 'Unable to create WebGLFramebuffer.'); } function or(t, e, n, r, o, i, a) {
    const s = t.getAttribLocation(e, n);

    return s !== -1 && (Wn(t, () => t.bindBuffer(t.ARRAY_BUFFER, r)), Wn(t, () => t.vertexAttribPointer(s, o, t.FLOAT, !1, i, a)), Wn(t, () => t.enableVertexAttribArray(s)), !0);
  } function ir(t, e, n) { dr(t, n), Wn(t, () => t.activeTexture(t.TEXTURE0 + n)), Wn(t, () => t.bindTexture(t.TEXTURE_2D, e)); } function ar(t, e, n) { return fr(t, () => t.getUniformLocation(e, n), `uniform "${n}" not present in program.`); } function sr(t, e, n) { return t.getUniformLocation(e, n); } function ur(t, e, n, r, o) { Wn(t, () => ir(t, n, o)), Wn(t, () => t.uniform1i(r, o)); } function cr(t, e, n) { Wn(t, () => t.bindFramebuffer(t.FRAMEBUFFER, n)), Wn(t, () => t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)); } function lr(t, e) { Wn(t, () => t.bindFramebuffer(t.FRAMEBUFFER, e)), Wn(t, () => t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)); } function hr(t) {
    const e = t.checkFramebufferStatus(t.FRAMEBUFFER);

    if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error(`Error binding framebuffer: ${pr(t, e)}`);
  } function pr(t, e) { switch (e) { case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT: return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT'; case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT'; case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS: return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS'; case t.FRAMEBUFFER_UNSUPPORTED: return 'FRAMEBUFFER_UNSUPPORTED'; default: return `unknown error ${e}`; } } function fr(t, e, n) {
    const r = Wn(t, () => e());

    if (r == null) throw new Error(n);

    return r;
  } function dr(t, e) {
    const n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1; const r = e + t.TEXTURE0;

    if (r < t.TEXTURE0 || n < r) throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`);
  } function mr(n, t) {
    void 0 === t && (t = !1); let e = mt.get('WEBGL_MAX_TEXTURE_SIZE');

    if (t && (e *= 2, n = n.map((t, e) => (e >= n.length - 2 ? _(n[e]) : n[e]))), n.length !== 2) {
      const r = y(n);

      n = r.newShape;
    } const o = B(n);

    return n.length <= 1 && o <= e ? [o, 1] : n.length === 2 && n[0] <= e && n[1] <= e ? n : n.length === 3 && n[0] * n[1] <= e && n[2] <= e ? [n[0] * n[1], n[2]] : n.length === 3 && n[0] <= e && n[1] * n[2] <= e ? [n[0], n[1] * n[2]] : n.length === 4 && n[0] * n[1] * n[2] <= e && n[3] <= e ? [n[0] * n[1] * n[2], n[3]] : n.length === 4 && n[0] <= e && n[1] * n[2] * n[3] <= e ? [n[0], n[1] * n[2] * n[3]] : p(o);
  } const vr = Object.freeze({
    createWebGLRenderingContext: Bn, createWebGLRenderingContextFromCanvas: zn, callAndCheck: Wn, enableDebugWebGLErrorChecking: Vn, checkWebGLError: Gn, getWebGLErrorMessage: qn, getExtensionOrThrow: jn, createVertexShader: Hn, createFragmentShader: $n, createProgram: Xn, linkProgram: Yn, validateProgram: Qn, createStaticVertexBuffer: Jn, createStaticIndexBuffer: Zn, getNumChannels: tr, createTexture: er, validateTextureSize: nr, createFramebuffer: rr, bindVertexBufferToProgramAttribute: or, bindTextureUnit: ir, unbindTextureUnit(t, e) { dr(t, e), Wn(t, () => t.activeTexture(t.TEXTURE0 + e)), Wn(t, () => t.bindTexture(t.TEXTURE_2D, null)); }, getProgramUniformLocationOrThrow: ar, getProgramUniformLocation: sr, bindTextureToProgramUniformSampler: ur, bindCanvasToFramebuffer(t) { Wn(t, () => t.bindFramebuffer(t.FRAMEBUFFER, null)), Wn(t, () => t.viewport(0, 0, t.canvas.width, t.canvas.height)), Wn(t, () => t.scissor(0, 0, t.canvas.width, t.canvas.height)); }, bindColorTextureToFramebuffer: cr, unbindColorTextureFromFramebuffer: lr, validateFramebuffer: hr, getFramebufferErrorMessage: pr, getTextureShapeFromLogicalShape: mr
  });

  function gr() {
    return {
      alpha: !1, antialias: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !1, depth: !1, stencil: !1, failIfMajorPerformanceCaveat: !0
    };
  } function yr(t) {
    let e; const n = {
      alpha: !1, antialias: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !1, depth: !1, stencil: !1, failIfMajorPerformanceCaveat: !0
    };

    return Wn(e = t != null ? zn(t, n) : Bn(n), () => e.disable(e.DEPTH_TEST)), Wn(e, () => e.disable(e.STENCIL_TEST)), Wn(e, () => e.disable(e.BLEND)), Wn(e, () => e.disable(e.DITHER)), Wn(e, () => e.disable(e.POLYGON_OFFSET_FILL)), Wn(e, () => e.disable(e.SAMPLE_COVERAGE)), Wn(e, () => e.enable(e.SCISSOR_TEST)), Wn(e, () => e.enable(e.CULL_FACE)), Wn(e, () => e.cullFace(e.BACK)), e;
  } function xr(t) { return Hn(t, '\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }'); } function br(t) { return Jn(t, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0])); } function wr(t) { return Zn(t, new Uint16Array([0, 1, 2, 2, 1, 3])); } function Er(t, e) {
    let n; let r; let o; let i; let a; let s; let u; const c = t;

    return mt.get('WEBGL_VERSION') === 2 ? (n = c.R32F, r = c.R16F, o = c.RGBA32F, i = c.RED, a = 4, s = 1, u = c.HALF_FLOAT) : (n = t.RGBA, r = t.RGBA, o = c.RGBA, i = t.RGBA, s = a = 4, u = e != null ? e.HALF_FLOAT_OES : null), {
      internalFormatFloat: n, internalFormatHalfFloat: r, internalFormatPackedFloat: o, textureFormatFloat: i, downloadTextureFormat: t.RGBA, downloadUnpackNumChannels: a, defaultNumChannels: s, textureTypeHalfFloat: u
    };
  } function Sr(t, e, n, r, o, i) {
    nr(e, n); const a = er(t); const s = t.TEXTURE_2D;

    return Wn(t, () => t.bindTexture(s, a)), Wn(t, () => t.texParameteri(s, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE)), Wn(t, () => t.texParameteri(s, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)), Wn(t, () => t.texParameteri(s, t.TEXTURE_MIN_FILTER, t.NEAREST)), Wn(t, () => t.texParameteri(s, t.TEXTURE_MAG_FILTER, t.NEAREST)), Wn(t, () => t.texImage2D(s, 0, r, e, n, 0, o, i, null)), Wn(t, () => t.bindTexture(t.TEXTURE_2D, null)), a;
  } function _r(t, e, n, r) {
    const o = Mn(e, n);

    return Sr(t, o[0], o[1], r.internalFormatFloat, r.textureFormatFloat, t.FLOAT);
  } function Cr(t, e, n, r) {
    const o = Mn(e, n);

    return Sr(t, o[0], o[1], r.internalFormatFloat, r.textureFormatFloat, r.textureTypeHalfFloat);
  } function Rr(t, e, n, r) {
    const o = Mn(e, n);

    return Sr(t, o[0], o[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE);
  } function Tr(t, e, n, r) {
    const o = Fn(e, n);

    return Sr(t, o[0], o[1], r.internalFormatPackedFloat, t.RGBA, t.FLOAT);
  } function kr(t, e, n, r) {
    const o = Fn(e, n);

    return Sr(t, o[0], o[1], r.internalFormatHalfFloat, t.RGBA, r.textureTypeHalfFloat);
  } function Ir(t, e, n) { return Wn(t, () => t.bindBuffer(t.ARRAY_BUFFER, n)), or(t, e, 'clipSpacePos', n, 3, 20, 0) && or(t, e, 'uv', n, 2, 20, 12); } function Dr(t, e, n) { Wn(t, () => t.bindTexture(t.TEXTURE_2D, e)), Wn(t, () => t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, n)), Wn(t, () => t.bindTexture(t.TEXTURE_2D, null)); } function Nr(t, e, n, r, o, i) { nr(n, r), Wn(t, () => t.bindTexture(t.TEXTURE_2D, e)), Wn(t, () => t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, n, r, i, t.FLOAT, o)), Wn(t, () => t.bindTexture(t.TEXTURE_2D, null)); } function Ar(t, e, n, r, o, i, a) {
    let s; const u = Mn(n, r); const c = u[0]; const l = u[1];

    a.defaultNumChannels === 1 ? s = o : (function (t, e, n) {
      const r = On(t.length, n);

      if (e.length < r) throw new Error(`unpackedArray length (${e.length}) must be >= ${r}`); for (let o = 0, i = 0; i < t.length; ++i)e[o] = t[i], o += n;
    }(o, s = new Float32Array(On(o.length, i)), i)), Nr(t, e, c, l, s, a.textureFormatFloat);
  } function Mr(t, e, n, r, o, i, a) {
    const s = Fn(r, o); const u = s[0]; const c = s[1]; const l = new Float32Array(Ln(r, o));

    (function (t, e, n, r, o) {
      const i = Ln(n, r);

      if (o.length < i) throw new Error(`packedRGBA length (${o.length}) must be >=\n        ${i}`); for (let a = r % 2 == 1, s = n % 2 == 1, u = Math.floor(r / 2), c = Math.floor(n / 2), l = Math.ceil(r / 2), h = l * Math.ceil(n / 2), p = _(n) * _(r), f = 0; f < e; f++) {
        for (var d = f * n * r, m = f * p, v = a ? 4 : 0, g = r, y = m, x = 0; x < c; ++x) {
          for (var b = 2 * x * r, w = 0; w < u; ++w) {
            var E = d + b + 2 * w;

            o[y] = t[E], o[y + 1] = t[E + 1], o[y + 2] = t[E + g], o[y + 3] = t[E + g + 1], y += 4;
          }y += v;
        } if (a) {
          E = d + r - 1, y = m + 4 * (l - 1); const S = 2 * r;

          for (v = 4 * l, x = 0; x < c; ++x)o[y] = t[E], o[y + 2] = t[E + r], E += S, y += v;
        } if (s) { for (E = d + (n - 1) * r, y = m + 4 * (h - l), w = 0; w < u; ++w)o[y++] = t[E++], o[y++] = t[E++], y += 2; a && s && (o[m + p - 4] = t[E]); }
      }
    }(i, n, r, o, l)), Nr(t, e, u, c, l, t.RGBA);
  } function Or(t, e, n, r, o) {
    let i = e;

    if (mt.get('WEBGL_VERSION') === 2) {
      const a = t; const s = a.createBuffer();

      Wn(t, () => t.bindBuffer(a.PIXEL_PACK_BUFFER, s)); const u = 4 * On(n * r, o.downloadUnpackNumChannels);

      Wn(t, () => t.bufferData(a.PIXEL_PACK_BUFFER, u, t.STATIC_DRAW)), Wn(t, () => a.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0)), Wn(t, () => t.bindBuffer(a.PIXEL_PACK_BUFFER, null)), i = s;
    }

    return i;
  } function Pr(t, e, n, r, o) {
    const i = t; const a = new Float32Array(On(n * r, o.downloadUnpackNumChannels));

    i.bindBuffer(t.ARRAY_BUFFER, e), i.getBufferSubData(t.ARRAY_BUFFER, 0, a), i.bindBuffer(t.ARRAY_BUFFER, null); const s = new Float32Array(n * r);

    return Pn(a, s, o.downloadUnpackNumChannels), s;
  } function Fr(t, e, n, r) {
    const o = Mn(e, n); const i = o[0]; const a = o[1]; const s = new Float32Array(On(e * n, r.downloadUnpackNumChannels));

    Wn(t, () => t.readPixels(0, 0, i, a, r.downloadTextureFormat, t.FLOAT, s)); const u = new Float32Array(e * n);

    return Pn(s, u, r.downloadUnpackNumChannels), u;
  } function Lr(t, e, n, r) {
    const o = Mn(e, n); const i = o[0]; const a = o[1]; const s = new Uint8Array(On(e * n, 4));

    return Wn(t, () => t.readPixels(0, 0, i, a, r.downloadTextureFormat, t.UNSIGNED_BYTE, s)), new Float32Array(s.buffer);
  } function Br(t, e, n, r, o, i, a) {
    const s = Fn(o, i); const u = s[0]; const c = s[1]; const l = new Float32Array(Ln(o, i));

    Wn(t, () => t.readPixels(0, 0, u, c, t.RGBA, t.FLOAT, l)); const h = new Float32Array(B([e, n, r]));

    return (function (t, e, n, r, o) {
      const i = n * r;

      if (o.length < i) throw new Error(`matrix length (${o.length}) must be >= ${i}`); for (let a = r % 2 == 1, s = n % 2 == 1, u = Math.floor(r / 2), c = Math.floor(n / 2), l = Math.ceil(r / 2), h = l * Math.ceil(n / 2), p = _(n) * _(r), f = 0; f < e; f++) {
        for (var d = f * n * r, m = f * p, v = a ? 4 : 0, g = r + (a ? 1 : 0), y = m, x = d, b = d + r, w = 0; w < c; ++w) { for (var E = 0; E < u; ++E)o[x++] = t[y++], o[x++] = t[y++], o[b++] = t[y++], o[b++] = t[y++]; y += v, x += g, b += g; } if (a) {
          y = m + 4 * (l - 1); var S = d + r - 1;

          for (v = 4 * l, g = 2 * r, w = 0; w < c; ++w)o[S] = t[y], o[S + r] = t[y + 2], y += v, S += g;
        } if (s) { for (y = m + 4 * (h - l), S = d + (n - 1) * r, E = 0; E < u; ++E)o[S++] = t[y++], o[S++] = t[y++], y += 2; a && (o[d + n * r - 1] = t[y]); }
      }

      return o;
    }(l, e, n, r, h));
  } const zr = Object.freeze({
    getWebGLContextAttributes: gr, createWebGLContext: yr, createVertexShader: xr, createVertexBuffer: br, createIndexBuffer: wr, getTextureConfig: Er, createFloat32MatrixTexture: _r, createFloat16MatrixTexture: Cr, createUnsignedBytesMatrixTexture: Rr, createPackedMatrixTexture: Tr, createFloat16PackedMatrixTexture: kr, bindVertexProgramAttributeStreams: Ir, uploadPixelDataToTexture: Dr, uploadMatrixToTexture: Ar, uploadMatrixToPackedTexture: Mr, maybeCreateBufferFromOutputTexture: Or, downloadFloat32MatrixFromBuffer: Pr, downloadFloat32MatrixFromOutputTexture: Fr, downloadByteEncodedFloatMatrixFromOutputTexture: Lr, downloadMatrixFromPackedOutputTexture: Br
  }); const Wr = (function () {
    function t(t) { this.outputTexture = null, this.program = null, this.disposed = !1, this.autoDebugValidate = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [], this.gl = t != null ? t : yr(), mt.get('WEBGL_VERSION') === 1 ? (this.textureFloatExtension = jn(this.gl, 'OES_texture_float'), this.colorBufferFloatExtension = this.gl.getExtension('WEBGL_color_buffer_float'), mt.get('WEBGL_RENDER_FLOAT32_ENABLED') || (this.textureHalfFloatExtension = jn(this.gl, 'OES_texture_half_float'), this.colorBufferHalfFloatExtension = this.gl.getExtension('EXT_color_buffer_half_float'))) : this.colorBufferFloatExtension = jn(this.gl, 'EXT_color_buffer_float'), this.loseContextExtension = jn(this.gl, 'WEBGL_lose_context'), this.vertexBuffer = br(this.gl), this.indexBuffer = wr(this.gl), this.framebuffer = rr(this.gl), this.textureConfig = Er(this.gl, this.textureHalfFloatExtension); }

    return t.prototype.dispose = function () {
      const t = this;

      if (!this.disposed) {
        this.program != null && console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.'), this.outputTexture != null && console.warn('Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.'); const e = this.gl;

        Wn(e, () => e.finish()), Wn(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), Wn(e, () => e.deleteFramebuffer(t.framebuffer)), Wn(e, () => e.bindBuffer(e.ARRAY_BUFFER, null)), Wn(e, () => e.deleteBuffer(t.vertexBuffer)), Wn(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)), Wn(e, () => e.deleteBuffer(t.indexBuffer)), this.loseContextExtension.loseContext(), this.disposed = !0;
      }
    }, t.prototype.enableAutomaticDebugValidation = function (t) { Vn(this.autoDebugValidate = t); }, t.prototype.createFloat32MatrixTexture = function (t, e) { return this.throwIfDisposed(), _r(this.gl, t, e, this.textureConfig); }, t.prototype.createFloat16MatrixTexture = function (t, e) { return this.throwIfDisposed(), Cr(this.gl, t, e, this.textureConfig); }, t.prototype.createUnsignedBytesMatrixTexture = function (t, e) { return this.throwIfDisposed(), Rr(this.gl, t, e, this.textureConfig); }, t.prototype.uploadPixelDataToTexture = function (t, e) { this.throwIfDisposed(), Dr(this.gl, t, e); }, t.prototype.createFloat16PackedMatrixTexture = function (t, e) { return this.throwIfDisposed(), kr(this.gl, t, e, this.textureConfig); }, t.prototype.createPackedMatrixTexture = function (t, e) { return this.throwIfDisposed(), Tr(this.gl, t, e, this.textureConfig); }, t.prototype.deleteMatrixTexture = function (t) {
      const e = this;

      this.throwIfDisposed(), this.outputTexture === t && (lr(this.gl, this.framebuffer), this.outputTexture = null), Wn(this.gl, () => e.gl.deleteTexture(t));
    }, t.prototype.uploadMatrixToTexture = function (t, e, n, r) {
      this.throwIfDisposed(); const o = tr();

      return Ar(this.gl, t, e, n, r, o, this.textureConfig);
    }, t.prototype.uploadMatrixToPackedTexture = function (t, e, n, r, o) { return this.throwIfDisposed(), Mr(this.gl, t, e, n, r, o, this.textureConfig); }, t.prototype.downloadFloat32MatrixFromOutputTexture = function (t, e, n) {
      const r = this;

      return this.downloadMatrixDriver(t, () => Fr(r.gl, e, n, r.textureConfig));
    }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (t, e, n) {
      const r = this;

      return this.downloadMatrixDriver(t, () => Lr(r.gl, e, n, r.textureConfig));
    }, t.prototype.downloadFloat32MatrixFromBuffer = function (t, e, n) { return Pr(this.gl, t, e, n, this.textureConfig); }, t.prototype.maybeCreateBufferFromTexture = function (t, e, n) {
      this.bindTextureToFrameBuffer(t); const r = Or(this.gl, t, e, n, this.textureConfig);

      return this.unbindTextureToFrameBuffer(), r;
    }, t.prototype.createAndWaitForFence = function () {
      const t = this.createFence(this.gl);

      return this.pollFence(t);
    }, t.prototype.createFence = function (t) {
      let e; let n; const r = this;

      if (mt.get('WEBGL_FENCE_API_ENABLED')) {
        const o = t; const i = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);

        t.flush(), n = function () {
          const t = o.clientWaitSync(i, 0, 0);

          return t === o.ALREADY_SIGNALED || t === o.CONDITION_SATISFIED;
        }, e = i;
      }
      else mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 ? (e = this.beginQuery(), this.endQuery(), n = function () { return r.isQueryAvailable(e, mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')); }) : n = function () { return !0; };

      return {query: e, isFencePassed: n};
    }, t.prototype.downloadMatrixFromPackedTexture = function (t, e, n, r, o, i) {
      const a = this;

      return this.downloadMatrixDriver(t, () => Br(a.gl, e, n, r, o, i, a.textureConfig));
    }, t.prototype.createProgram = function (t) {
      this.throwIfDisposed(); const e = this.gl; const n = $n(e, t); const r = xr(e); const o = Xn(e);

      return Wn(e, () => e.attachShader(o, r)), Wn(e, () => e.attachShader(o, n)), Yn(e, o), this.autoDebugValidate && Qn(e, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = Ir(e, this.program, this.vertexBuffer)), o;
    }, t.prototype.deleteProgram = function (t) {
      const e = this;

      this.throwIfDisposed(), t === this.program && (this.program = null), t != null && Wn(this.gl, () => e.gl.deleteProgram(t));
    }, t.prototype.setProgram = function (t) {
      const e = this;

      this.throwIfDisposed(), this.program = t, this.program != null && this.autoDebugValidate && Qn(this.gl, this.program), Wn(this.gl, () => e.gl.useProgram(t));
    }, t.prototype.getUniformLocation = function (t, e, n) { return void 0 === n && (n = !0), this.throwIfDisposed(), n ? ar(this.gl, t, e) : sr(this.gl, t, e); }, t.prototype.getAttributeLocation = function (t, e) {
      const n = this;

      return this.throwIfDisposed(), Wn(this.gl, () => n.gl.getAttribLocation(t, e));
    }, t.prototype.getUniformLocationNoThrow = function (t, e) { return this.throwIfDisposed(), this.gl.getUniformLocation(t, e); }, t.prototype.setInputMatrixTexture = function (t, e, n) { this.throwIfDisposed(), this.throwIfNoProgram(), ur(this.gl, this.program, t, e, n); }, t.prototype.setOutputMatrixTexture = function (t, e, n) { this.setOutputMatrixTextureDriver(t, n, e); }, t.prototype.setOutputPackedMatrixTexture = function (t, e, n) {
      this.throwIfDisposed(); const r = Fn(e, n); const o = r[0]; const i = r[1];

      this.setOutputMatrixTextureDriver(t, o, i);
    }, t.prototype.setOutputMatrixWriteRegion = function (t, e, n, r) { this.setOutputMatrixWriteRegionDriver(n, t, r, e); }, t.prototype.setOutputPackedMatrixWriteRegion = function (t, e, n, r) { throw new Error('setOutputPackedMatrixWriteRegion not implemented.'); }, t.prototype.debugValidate = function () { this.program != null && Qn(this.gl, this.program), hr(this.gl); }, t.prototype.executeProgram = function () {
      this.throwIfDisposed(), this.throwIfNoProgram(); const t = this.gl;

      this.autoDebugValidate && this.debugValidate(), Wn(t, () => t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0));
    }, t.prototype.blockUntilAllProgramsCompleted = function () {
      const t = this;

      this.throwIfDisposed(), Wn(this.gl, () => t.gl.finish());
    }, t.prototype.getQueryTimerExtension = function () { return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = jn(this.gl, mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ? 'EXT_disjoint_timer_query_webgl2' : 'EXT_disjoint_timer_query')), this.disjointQueryTimerExtension; }, t.prototype.getQueryTimerExtensionWebGL2 = function () { return this.getQueryTimerExtension(); }, t.prototype.getQueryTimerExtensionWebGL1 = function () { return this.getQueryTimerExtension(); }, t.prototype.beginQuery = function () {
      if (mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
        const t = this.gl; const e = this.getQueryTimerExtensionWebGL2(); const n = t.createQuery();

        return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;
      } const r = this.getQueryTimerExtensionWebGL1(); const o = r.createQueryEXT();

      return r.beginQueryEXT(r.TIME_ELAPSED_EXT, o), o;
    }, t.prototype.endQuery = function () {
      if (mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') !== 2) {
        const t = this.getQueryTimerExtensionWebGL1();

        t.endQueryEXT(t.TIME_ELAPSED_EXT);
      }
      else {
        const e = this.gl; const n = this.getQueryTimerExtensionWebGL2();

        e.endQuery(n.TIME_ELAPSED_EXT);
      }
    }, t.prototype.waitForQueryAndGetTime = function (n) {
      return m(this, void 0, void 0, function () {
        const e = this;

        return S(this, function (t) { switch (t.label) { case 0: return [4, v(() => e.isQueryAvailable(n, mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')))]; case 1: return t.sent(), [2, this.getQueryTime(n, mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'))]; } });
      });
    }, t.prototype.getQueryTime = function (t, e) {
      if (e === 0) return null; if (e === 2) {
        const n = this.gl;

        return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;
      } const r = this.getQueryTimerExtensionWebGL1();

      return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;
    }, t.prototype.isQueryAvailable = function (t, e) {
      if (e === 0) return !0; if (e !== 2) return o = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT), this.disjoint == null && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint; const n = this.gl; var r = this.getQueryTimerExtensionWebGL2(); var o = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);

      return this.disjoint == null && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;
    }, t.prototype.pollFence = function (e) {
      const n = this;

      return new Promise(((t) => { n.addItemToPoll(() => e.isFencePassed(), () => t()); }));
    }, t.prototype.pollItems = function () {
      for (var t = (function (t) {
          for (var e = 0, n = t.length - 1, r = -1; e <= n;) {
            const o = e + n >> 1;

            t[o]() ? e = (r = o) + 1 : n = o - 1;
          }

          return r;
        }(this.itemsToPoll.map((t) => t.isDoneFn))), e = 0; e <= t; ++e)(0, this.itemsToPoll[e].resolveFn)(); this.itemsToPoll = this.itemsToPoll.slice(t + 1);
    }, t.prototype.addItemToPoll = function (t, e) {
      const n = this;

      this.itemsToPoll.push({isDoneFn: t, resolveFn: e}), this.itemsToPoll.length > 1 || v(() => n.pollItems(), n.itemsToPoll.length === 0);
    }, t.prototype.bindTextureToFrameBuffer = function (t) { this.throwIfDisposed(), cr(this.gl, t, this.framebuffer), this.autoDebugValidate && hr(this.gl); }, t.prototype.unbindTextureToFrameBuffer = function () { this.outputTexture != null ? (cr(this.gl, this.outputTexture, this.framebuffer), this.autoDebugValidate && hr(this.gl)) : lr(this.gl, this.framebuffer); }, t.prototype.downloadMatrixDriver = function (t, e) {
      this.bindTextureToFrameBuffer(t); const n = e();

      return this.unbindTextureToFrameBuffer(), n;
    }, t.prototype.setOutputMatrixTextureDriver = function (t, e, n) {
      this.throwIfDisposed(); const r = this.gl;

      cr(r, t, this.framebuffer), this.autoDebugValidate && hr(r), this.outputTexture = t, Wn(r, () => r.viewport(0, 0, e, n)), Wn(r, () => r.scissor(0, 0, e, n));
    }, t.prototype.setOutputMatrixWriteRegionDriver = function (t, e, n, r) {
      const o = this;

      this.throwIfDisposed(), Wn(this.gl, () => o.gl.scissor(t, e, n, r));
    }, t.prototype.throwIfDisposed = function () { if (this.disposed) throw new Error('Attempted to use disposed GPGPUContext.'); }, t.prototype.throwIfNoProgram = function () { if (this.program == null) throw new Error('No GPU program is currently set.'); }, t;
  }());

  function Ur(t, s) {
    if (t.length !== s.length) throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${s.length} inputs`); t.forEach((t, e) => {
      const n = t.logicalShape; const r = s[e]; const o = r.shape;

      if (!T(n, o)) throw Error(`Binary was compiled with different shapes than the current args. Shapes ${n} and ${o} must match`); if (!t.isUniform || !r.isUniform) {
        const i = t.texShape; const a = r.isUniform ? null : r.texData.texShape;

        if (!T(i, a)) throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${a} must match`);
      }
    });
  } const Vr = function (t, e, n) {
    this.variableNames = ['A'], this.outputShape = t; const r = n.filterWidth; const o = n.inChannels; const i = n.strideWidth; const a = n.strideHeight; const s = n.padInfo; const u = n.outWidth; const c = n.dilationWidth; const l = n.dilationHeight; const h = s.left; const p = s.top; const f = o * r;

    this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            int blockIndex = rc.y + col;\n            int pos = rc.x + row;\n\n            if(blockIndex >= ${t[1]} || pos >= ${t[0]}) continue;\n\n            int offsetY = int(blockIndex / (${u})) * ${a} - ${p};\n            int d0 = offsetY + ${l} * (pos / ${f});\n\n            if(d0 >= ${e[0]} || d0 < 0) continue;\n\n            int offsetX = int(mod(float(blockIndex), ${u}.) * ${i}. - ${h}.);\n            int d1 = offsetX + ${c} * (int(mod(float(pos), ${f}.) / ${o}.));\n\n            if(d1 >= ${e[1]} || d1 < 0) continue;\n\n            result[row * 2 + col] = getA(d0, d1, int(mod(float(pos), ${o}.)));\n          }\n        }\n\n        gl_FragColor = result;\n      }\n    `;
  }; const Gr = function (t, e, n, r, o) {
    this.variableNames = ['x'], this.outputShape = []; let i; const a = e; const s = t[3] - 1;

    this.outputShape = t; const u = `float(${n}) + float(${r}) * sum`;

    i = o === 0.5 ? `inversesqrt(${u})` : o === 1 ? `1.0/(${u})` : `exp(log(${u}) * float(-${o}));`, this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${s}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `;
  }; const qr = function (t, e, n, r, o) { this.variableNames = ['inputImage', 'outputImage', 'dy'], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = o, this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `; }; const jr = function (t) {
    this.variableNames = ['dy', 'maxPos'], this.outputShape = t.inShape; const e = t.strideHeight; const n = t.strideWidth; const r = t.dilationHeight; const o = t.effectiveFilterHeight; const i = t.effectiveFilterWidth; const a = o - 1 - t.padInfo.top; const s = i - 1 - t.padInfo.left; const u = o * i - 1;

    this.userCode = `\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
  }; const Hr = function (t, e, n, r) {
    void 0 === n && (n = !1), void 0 === r && (r = !1), this.variableNames = ['matrixA', 'matrixB']; const o = t[0]; const i = n ? t[2] : t[1]; const a = r ? e[1] : e[2]; const s = n ? t[1] : t[2];

    this.outputShape = [o, i, a]; const u = function (t, e) { return n ? `batch, ${e} + ${t}, aRow` : `batch, aRow, ${e} + ${t}`; }; const c = function (t, e) { return r ? `batch, bCol, ${e} + ${t}` : `batch, ${e} + ${t}, bCol`; }; const l = 4 * Math.floor(s / 4); const h = s % 4;

    this.userCode = ` float dotARowBCol(int batch, int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < ${l}; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(${u(0, 'i')}),\n          getMatrixA(${u(1, 'i')}),\n          getMatrixA(${u(2, 'i')}),\n          getMatrixA(${u(3, 'i')})\n        );\n        vec4 b = vec4(\n          getMatrixB(${c(0, 'i')}),\n          getMatrixB(${c(1, 'i')}),\n          getMatrixB(${c(2, 'i')}),\n          getMatrixB(${c(3, 'i')})\n        );\n\n        result += dot(a, b);\n      }\n\n      if (${h === 1}) {\n        result += getMatrixA(${u(0, l)}) *\n          getMatrixB(${c(0, l)});\n      } else if (${h === 2}) {\n        vec2 a = vec2(\n          getMatrixA(${u(0, l)}),\n          getMatrixA(${u(1, l)})\n        );\n        vec2 b = vec2(\n          getMatrixB(${c(0, l)}),\n          getMatrixB(${c(1, l)})\n        );\n        result += dot(a, b);\n      } else if (${h === 3}) {\n        vec3 a = vec3(\n          getMatrixA(${u(0, l)}),\n          getMatrixA(${u(1, l)}),\n          getMatrixA(${u(2, l)})\n        );\n        vec3 b = vec3(\n          getMatrixB(${c(0, l)}),\n          getMatrixB(${c(1, l)}),\n          getMatrixB(${c(2, l)})\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec3 resBRC = getOutputCoords();\n      setOutput(dotARowBCol(resBRC.x, resBRC.y, resBRC.z));\n    }\n    `;
  }; const $r = function (t, e, n, r, o) {
    void 0 === r && (r = !1), void 0 === o && (o = !1), this.variableNames = ['matrixA', 'matrixB'], this.usesPackedTextures = !0, this.outputShape = n; const i = r ? t[0] : t[1]; const a = Math.ceil(i / 2); const s = r ? 'i * 2, rc.x' : 'rc.x, i * 2'; const u = o ? 'rc.y, i * 2' : 'i * 2, rc.y'; const c = r ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww']; const l = o ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];

    this.userCode = `\n      const float sharedDimension = ${a}.0;\n\n      vec4 dot2x2ARowBCol(ivec2 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${a}; i++) {\n          vec4 a = getMatrixA(${s});\n          vec4 b = getMatrixB(${u});\n\n          result += (${c[0]} * ${l[0]}) + (${c[1]} * ${l[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n        setOutput(dot2x2ARowBCol(rc));\n      }\n    `;
  }; const Kr = (function () {
    function t(t, e, n) { this.variableNames = ['probs'], this.outputShape = [t, n], this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e - 1}));\n      }\n    `; }

    return t.prototype.getCustomSetupFunc = function (n) {
      const r = this;

      return function (t, e) { r.seedLoc == null && (r.seedLoc = t.getUniformLocation(e, 'seed')), t.gl.uniform1f(r.seedLoc, n); };
    }, t;
  }()); const Xr = function (t, e, n, r) { this.variableNames = ['indices'], this.outputShape = [t, e], this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `; };

  function Yr(e) { return ['x', 'y', 'z', 'w'].map((t) => `${e}.${t}`); } function Qr(t, e) { return e.slice(0, t).slice(-2); } const Jr = function (t) {
    this.variableNames = ['A']; let e; let n; let r; let o; const i = (this.outputShape = t).length; const a = Yr('rc'); const s = vn(i); const u = (function (t, e, n) {
      if (t === 1) return `rc > ${e[0]}`; for (var r = '', o = 0; o < t; o++)r += `${n[o]} >= ${e[o]}`, o < t - 1 && (r += '||');

      return r;
    }(i, t, a)); const c = (function (t, e, n, r) {
      if (t === 1) return ''; const o = Qr(t, r);

      return `\n    int r = ${o[0]};\n    int c = ${o[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `;
    }(i, t[t.length - 1], t[t.length - 2], a)); const l = (n = a, r = (e = t).length, o = (function (t, e) {
      for (var n = [], r = 0; r <= 1; r++) for (let o = 0; o <= 1; o++) { for (var i = `${r === 0 ? 'r' : 'rp1'}, ${o === 0 ? 'c' : 'cp1'}`, a = 2; a < t; a++)i = `${e[e.length - 1 - a]},${i}`; n.push(i); }

      return n;
    }(r, n)), r === 1 ? `getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0` : `getA(${o[0]}),\n          cEdge ? 0. : getA(${o[1]}),\n          rEdge ? 0. : getA(${o[2]}),\n          rEdge || cEdge ? 0. : getA(${o[3]})`);

    this.userCode = `\n      void main() {\n        ${s} rc = getOutputCoords();\n\n        if(${u}) {\n          gl_FragColor = vec4(0);\n        } else {\n          ${c}\n\n          setOutput(vec4(${l}));\n        }\n      }\n    `;
  }; const Zr = function (n, t, e) {
    this.variableNames = ['x'], this.outputShape = t.map((t, e) => t[0] + n[e] + t[1]); const r = n.length; const o = vn(r); const i = t.map((t) => t[0]).join(','); const a = t.map((t, e) => t[0] + n[e]).join(','); const s = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, r);

    this.userCode = r !== 1 ? `\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${e}));\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${s}));\n        }\n      }\n    ` : `\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${e}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;
  }; const to = function (t, e, n) {
    if (this.variableNames = ['x'], e === 'avg' && n) throw new Error('Cannot compute positions for average pool.'); const r = t.filterWidth; const o = t.strideHeight; const i = t.strideWidth; const a = t.dilationHeight; const s = t.dilationWidth; const u = t.effectiveFilterHeight; const c = t.effectiveFilterWidth; const l = t.padInfo.top; const h = t.padInfo.left;

    this.outputShape = t.outShape; const p = e === 'avg'; let f = '0.0';

    if (p || (f = '-1.0 / 0.0'), n) this.userCode = `\n        const ivec2 strides = ivec2(${o}, ${i});\n        const ivec2 pads = ivec2(${l}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${a}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c};\n                wC += ${s}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * ${c} + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `; else {
      let d = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;

      e === 'avg' && (d = 'avgValue / count'); const m = 4 * Math.floor(r / 4); const v = r % 4; const g = `\n      if (${p}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;

      this.userCode = `\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${l}, ${h});\n      const float initializationValue = ${f};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${f});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${a}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${m}; wC += 4) {\n            int xC = xCCorner + wC * ${s};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              getValue(batch, xR, xC + 2 * ${s}, d),\n              getValue(batch, xR, xC + 3 * ${s}, d)\n            );\n\n            ${g}\n          }\n\n          int xC = xCCorner + ${m};\n          if (${v === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${g}\n          } else if (${v === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${g}\n          } else if (${v === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              getValue(batch, xR, xC + 2 * ${s}, d),\n              initializationValue\n            );\n\n            ${g}\n          }\n        }\n        setOutput(${d});\n      }\n    `;
    }
  }; const eo = function (t, e) {
    this.variableNames = ['x']; const n = t.windowSize; const r = t.batchSize; const o = t.inSize; const i = Math.ceil(o / n);

    this.outputShape = [r, i]; let a = '0.0'; let s = '';

    e === 'prod' ? a = '1.0' : e === 'min' ? (a = '1.0 / 0.0', s = 'min') : e === 'max' && (a = '-1.0 / 0.0', s = 'max'); let u = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;

    e === 'sum' ? u = 'sumValue' : e === 'prod' ? u = 'prodValue' : e === 'all' ? u = 'allValue' : e === 'any' && (u = 'anyValue'); const c = 4 * Math.floor(n / 4); const l = n % 4; let h = `\n      if (${e === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${e === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${s}(values, minMaxValue);\n      }\n    `; let p = 'vec4';

    e === 'all' ? (a = '1.0', h = '\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ', p = 'bvec4') : e === 'any' && (a = '0.0', h = '\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ', p = 'bvec4'); let f = '';

    o % n > 0 && (f = `\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `), this.userCode = `\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${l === 1}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${l === 2}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${l === 3}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `;
  }; const no = function (t, e, n) {
    this.variableNames = ['dy'], this.outputShape = [], this.outputShape = e.shape; const r = e.shape; const o = r[1]; const i = r[2]; const a = t.shape; const s = a[1]; const u = a[2]; const c = [n && s > 1 ? o - 1 : o, n && u > 1 ? i - 1 : i]; const l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u]; const h = c[0] / l[0]; const p = c[1] / l[1]; const f = 1 / h; const d = 1 / p; const m = 2 * Math.ceil(f) + 2; const v = 2 * Math.ceil(d) + 2;

    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${h});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${f});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${m});\n        const int winWidth = int(${v});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${u}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${o - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;
  }; const ro = function (t, e, n, r) {
    this.variableNames = ['A'], this.outputShape = []; const o = t[0]; const i = t[1]; const a = t[2]; const s = t[3];

    this.outputShape = [o, e, n, s]; const u = [r && e > 1 ? i - 1 : i, r && n > 1 ? a - 1 : a]; const c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];

    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0] / c[0]},\n          ${u[1] / c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;
  }; const oo = function (t, e, n) {
    this.variableNames = ['dy'], this.outputShape = [], this.outputShape = e.shape; const r = e.shape; const o = r[1]; const i = r[2]; const a = t.shape; const s = a[1]; const u = a[2]; const c = [n && s > 1 ? o - 1 : o, n && u > 1 ? i - 1 : i]; const l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u]; const h = c[0] / l[0]; const p = c[1] / l[1]; const f = 1 / h; const d = 1 / p; const m = 2 * Math.ceil(f) + 2; const v = 2 * Math.ceil(d) + 2;

    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${h});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${f});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${m});\n        const int winWidth = int(${v});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${u}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${c[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${c[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${o}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;
  }; const io = function (t, e, n, r) {
    this.variableNames = ['A'], this.outputShape = []; const o = t[0]; const i = t[1]; const a = t[2]; const s = t[3];

    this.outputShape = [o, e, n, s]; const u = [r && e > 1 ? i - 1 : i, r && n > 1 ? a - 1 : a]; const c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n]; const l = r ? '0.5' : '0.0';

    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0] / c[0]},\n          ${u[1] / c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${l})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `;
  }; const ao = function (r, o) {
    this.variableNames = ['x']; const t = r.length;

    if (t > 4) throw new Error(`WebGL backend: Reverse of rank-${t} tensor is not yet supported`); if (this.outputShape = r, t !== 1) {
      const e = r.map((t, e) => { return n = e, o.indexOf(n) !== -1 && r[n] !== 1 ? `${r[n]} - coords[${n}] - 1` : `coords[${n}]`; let n; }).join(','); const n = vn(t);

      this.userCode = `\n      void main() {\n        ${n} coords = getOutputCoords();\n        setOutput(getX(${e}));\n      }\n    `;
    }
    else this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${r[0]} - coord - 1));\n        }\n      `;
  }; const so = function (t, e, n, r, o, i, a) {
    void 0 === a && (a = !0), this.variableNames = ['updates', 'indices', 'defaultValue'], this.outputShape = i; const s = vn(o.length); const u = vn(i.length); let c = '';

    n === 1 ? c = 'i' : n === 2 && (c = 'i, j'); const l = `getIndices(${c})`; let h = '';

    r === 1 ? h = 'i' : r === 2 && (h = 'i, coords[1]'); const p = `getUpdates(${h})`; const f = e > 1 ? 'strides[j]' : 'strides';

    this.userCode = `\n        ${s} strides = ${s}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(${l});\n              flattenedIndex += index * ${f};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `;
  }; const uo = function (t, e) {
    this.variableNames = ['x', 'segmentIds']; const n = t.windowSize; const r = t.batchSize; const o = t.inSize; const i = t.numSegments; const a = i * Math.ceil(o / n);

    this.outputShape = [r, a]; const s = 4 * Math.floor(n / 4); const u = n % 4; const c = '\n        sumValue += dot(values, filter);\n    '; let l = '';

    o % n > 0 && (l = `\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `); let h = '';

    o % n > 0 && (h = `\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `), this.userCode = `\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${u === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${u === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${u === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `;
  }; const co = function (t, e, n) {
    let r, o;

    if (this.variableNames = ['c', 'a', 'b'], this.outputShape = e, n > 4) throw Error(`Where for rank ${n} is not yet supported`); if (n === 1)r = o = 'resRC'; else { for (var i = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'], a = [], s = [], u = 0; u < e.length; u++)s.push(`${i[u]}`), u < t && a.push(`${i[u]}`); r = a.join(), o = s.join(); } const c = vn(n);

    this.userCode = `\n      void main() {\n        ${c} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `;
  }; const lo = (function () {
    function t(t) {
      this.variableNames = ['source'], this.outputShape = t, this.rank = t.length; const e = vn(this.rank); const n = (function (t) { if (t === 1) return 'sourceLoc'; if (t === 2) return 'sourceLoc.x, sourceLoc.y'; if (t === 3) return 'sourceLoc.x, sourceLoc.y, sourceLoc.z'; if (t === 4) return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w'; throw Error(`Slicing for rank ${t} is not yet supported`); }(this.rank));

      this.userCode = `\n      uniform ${e} start;\n\n      void main() {\n        ${e} sourceLoc = start + getOutputCoords();\n        setOutput(getSource(${n}));\n      }\n    `;
    }

    return t.prototype.getCustomSetupFunc = function (n) {
      const r = this;

      if (n.length !== this.rank) throw Error(`The rank (${this.rank}) of the program must match the length of start (${n.length})`);

      return function (t, e) { if (r.startLoc != null || (r.startLoc = t.getUniformLocationNoThrow(e, 'start'), r.startLoc != null)) if (r.rank === 1)t.gl.uniform1i(r.startLoc, n[0]); else if (r.rank === 2)t.gl.uniform2i(r.startLoc, n[0], n[1]); else if (r.rank === 3)t.gl.uniform3i(r.startLoc, n[0], n[1], n[2]); else { if (r.rank !== 4) throw Error(`Slicing for rank ${r.rank} is not yet supported`); t.gl.uniform4i(r.startLoc, n[0], n[1], n[2], n[3]); } };
    }, t;
  }()); const ho = function (t, e, n, r) {
    this.variableNames = ['x']; const o = n.filter((t, e) => r.indexOf(e) === -1);

    this.outputShape = o; const i = n.length; const a = vn(n.length); const s = vn(o.length); let u = '';

    if (i === 1)u = 'coords * strides + begin'; else {
      let c = 0;

      u = n.map((t, e) => (r.indexOf(e) === -1 ? (c++, o.length === 1 ? `coords * strides[${e}] + begin[${e}]` : `coords[${c - 1}] * strides[${e}] + begin[${e}]`) : `begin[${e}]`)).join(',');
    } this.userCode = `\n      ${a} begin = ${a}(${t});\n      ${a} strides = ${a}(${e});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${u}));\n      }\n    `;
  }; const po = (function () {
    function t(t) { this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {}; }

    return t.prototype.acquireTexture = function (t, e, n) {
      let r; const o = fo(e, n); const i = mo(t, o, n);

      if (i in this.freeTextures || (this.freeTextures[i] = []), i in this.usedTextures || (this.usedTextures[i] = []), this.freeTextures[i].length > 0) {
        this.numFreeTextures--, this.numUsedTextures++, this.log(); const a = this.freeTextures[i].shift();

        return this.usedTextures[i].push(a), a;
      }

      return this.numUsedTextures++, this.log(), o === In.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === In.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === In.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === In.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === In.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[i].push(r), r;
    }, t.prototype.releaseTexture = function (t, e, n, r) {
      if (this.freeTextures != null) {
        const o = mo(e, fo(n, r), r);

        o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(t), this.numFreeTextures++, this.numUsedTextures--; const i = this.usedTextures[o]; const a = i.indexOf(t);

        if (a < 0) throw new Error('Cannot release a texture that was never provided by this texture manager'); i.splice(a, 1), this.log();
      }
    }, t.prototype.log = function () {
      if (this.logEnabled) {
        const t = this.numFreeTextures + this.numUsedTextures;

        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${t})`);
      }
    }, t.prototype.getNumUsedTextures = function () { return this.numUsedTextures; }, t.prototype.getNumFreeTextures = function () { return this.numFreeTextures; }, t.prototype.dispose = function () {
      const e = this;

      if (this.freeTextures != null) { for (var t in this.freeTextures) this.freeTextures[t].forEach((t) => { e.gpgpu.deleteMatrixTexture(t); }); for (var t in this.usedTextures) this.usedTextures[t].forEach((t) => { e.gpgpu.deleteMatrixTexture(t); }); this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0; }
    }, t;
  }());

  function fo(t, e) { if (e) return mt.get('WEBGL_RENDER_FLOAT32_ENABLED') ? In.PACKED_2X2_FLOAT32 : In.PACKED_2X2_FLOAT16; if (t === kn.DOWNLOAD || t === kn.PIXELS) return In.PACKED_4X1_UNSIGNED_BYTE; if (t === kn.UPLOAD) return In.UNPACKED_FLOAT32; if (t === kn.RENDER) return mt.get('WEBGL_RENDER_FLOAT32_ENABLED') ? In.UNPACKED_FLOAT32 : In.UNPACKED_FLOAT16; throw new Error(`Unknown logical texture type ${t}`); } function mo(t, e, n) { return `${t[0]}_${t[1]}_${e}_${n}`; } const vo = function (t, e) {
    this.variableNames = ['A']; for (var n = new Array(t.length), r = 0; r < n.length; r++)n[r] = t[r] * e[r]; this.outputShape = n, this.rank = n.length; const o = vn(this.rank); const i = (function (t) {
      const e = t.length;

      if (e > 5) throw Error(`Tile for rank ${e} is not yet supported`); if (e === 1) return `imod(resRC, ${t[0]})`; for (var n = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'], r = [], o = 0; o < t.length; o++)r.push(`imod(${n[o]}, ${t[o]})`);

      return r.join();
    }(t));

    this.userCode = `\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `;
  }; const go = function (t, e) {
    this.variableNames = ['A']; for (var n = new Array(t.length), r = 0; r < n.length; r++)n[r] = t[e[r]]; this.outputShape = n, this.rank = n.length; const o = vn(this.rank); const i = (function (t) {
      const e = t.length;

      if (e > 6) throw Error(`Transpose for rank ${e} is not yet supported`); for (var n = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'], r = new Array(e), o = 0; o < t.length; o++)r[t[o]] = n[o];

      return r.join();
    }(e));

    this.userCode = `\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `;
  }; const yo = 1.7580993408473768; const xo = 1.0507009873554805; const bo = (function () {
    function t(t, e) { this.variableNames = ['A'], this.outputShape = t, this.userCode = `\n      uniform float NAN;\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `; }

    return t.prototype.getCustomSetupFunc = function () {
      const n = this;

      return function (t, e) { n.startLoc == null && (n.startLoc = t.getUniformLocationNoThrow(e, 'NAN'), n.startLoc == null) || t.gl.uniform1f(n.startLoc, NaN); };
    }, t;
  }()); const wo = 'if (isNaN(x)) return x;'; const Eo = function (t) {
    this.variableNames = ['A'], this.usesPackedTextures = !0; const e = (this.outputShape = t).length; const n = Yr('rc'); const r = vn(e); const o = (function (t, e) {
      if (t === 1) return 'rc'; for (var n = '', r = 0; r < t; r++)n += e[r], r < t - 1 && (n += ',');

      return n;
    }(e, n)); const i = Qr(e, n); const a = e === 1 ? 'rc' : i.join(',');

    this.userCode = `\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec2 modCoord = mod(vec2(${a}), 2.);\n        vec4 packedInput = getA(${o});\n\n        setOutput(\n          modCoord.x == 0. ?\n            (modCoord.y == 0. ? packedInput.r : packedInput.g) :\n            (modCoord.y == 0. ? packedInput.b : packedInput.a)\n        );\n      }\n    `;
  }; const So = Yt({
    concat_(t, n) {
      void 0 === n && (n = 0), D(t.length >= 1, 'Pass at least one tensor to concat'); let e = Xt(t, 'tensors', 'concat');

      n = Ot(n, e[0].shape)[0]; const r = zt(e.map((t) => t.shape), n);

      if (B(r) === 0) return ee([], r); if ((e = e.filter((t) => t.size > 0)).length === 1) return e[0]; const o = e.map((t) => t.shape);

      !(function (t, r) {
        const o = t[0].length;

        t.forEach((t, e) => { D(t.length === o, `Error in concat${o}D: rank of tensors[${e}] must be the same as the rank of the rest (${o})`); }), D(r >= 0 && r < o, `Error in concat${o}D: axis must be between 0 and ${o - 1}.`); const i = t[0];

        t.forEach((t, e) => { for (let n = 0; n < o; n++)D(n === r || t[n] === i[n], `Error in concat${o}D: Shape of tensors[${e}] (${t}) does not match the shape of the rest (${i}) along the non-concatenated axis ${e}.`); });
      }(o, n)); const i = e;

      return mt.engine.runKernel((t) => t.concat(e, n), i, (t) => {
        const e = o.map((t) => t[n]);

        return ko(t, e, n).map((t) => function () { return t; });
      });
    }
  }); const _o = Yt({concat1d_(t) { return So(t, 0); }}); const Co = Yt({concat2d_(t, e) { return So(t, e); }}); const Ro = Yt({concat3d_(t, e) { return So(t, e); }}); const To = Yt({concat4d_(t, e) { return So(t, e); }}); var ko = Yt({
    split_(t, e, n) {
      void 0 === n && (n = 0); let r; const o = Kt(t, 'x', 'split');

      return n = Ot(n, o.shape)[0], typeof e === 'number' ? (D(o.shape[n] % e == 0, 'Number of splits must evenly divide the axis.'), r = Array(e).fill(o.shape[n] / e)) : (D(o.shape[n] === e.reduce((t, e) => t + e), 'The sum of sizes must match the size of the axis dimension.'), r = e), mt.engine.runKernel((t) => t.split(o, r, n), {$x: o}, (t) => ({$x() { return So(t, n); }}));
    }
  });

  function Io(t, e) { return t(e = {exports: {}}, e.exports), e.exports; } const Do = Io((t) => {
    !(function (t, e, n) {
      function i(t, e) { return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e; } function r(t, e) {
        const n = new function (t) {
          let r; const e = this; let n = (r = 4022871197, function (t) {
            t = t.toString(); for (let e = 0; e < t.length; e++) {
              let n = 0.02519603282416938 * (r += t.charCodeAt(e));

              n -= r = n >>> 0, r = (n *= r) >>> 0, r += 4294967296 * (n -= r);
            }

            return 2.3283064365386963e-10 * (r >>> 0);
          });

          e.next = function () {
            const t = 2091639 * e.s0 + 2.3283064365386963e-10 * e.c;

            return e.s0 = e.s1, e.s1 = e.s2, e.s2 = t - (e.c = 0 | t);
          }, e.c = 1, e.s0 = n(' '), e.s1 = n(' '), e.s2 = n(' '), e.s0 -= n(t), e.s0 < 0 && (e.s0 += 1), e.s1 -= n(t), e.s1 < 0 && (e.s1 += 1), e.s2 -= n(t), e.s2 < 0 && (e.s2 += 1), n = null;
        }(t); const r = e && e.state; const o = n.next;

        return o.int32 = function () { return 4294967296 * n.next() | 0; }, o.double = function () { return o() + 11102230246251565e-32 * (2097152 * o() | 0); }, o.quick = o, r && (typeof r === 'object' && i(r, n), o.state = function () { return i(n, {}); }), o;
      }e && e.exports ? e.exports = r : this.alea = r;
    }(0, t));
  }); const No = Io((t) => {
    !(function (t, e, n) {
      function i(t, e) { return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e; } function r(t, e) {
        const n = new function (t) {
          const e = this; let n = '';

          e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
            const t = e.x ^ e.x << 11;

            return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;
          }, t === (0 | t) ? e.x = t : n += t; for (let r = 0; r < n.length + 64; r++)e.x ^= 0 | n.charCodeAt(r), e.next();
        }(t); const r = e && e.state; const o = function () { return (n.next() >>> 0) / 4294967296; };

        return o.double = function () {
          do { var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21); } while (t === 0);

          return t;
        }, o.int32 = n.next, o.quick = o, r && (typeof r === 'object' && i(r, n), o.state = function () { return i(n, {}); }), o;
      }e && e.exports ? e.exports = r : this.xor128 = r;
    }(0, t));
  }); const Ao = Io((t) => {
    !(function (t, e, n) {
      function i(t, e) { return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e; } function r(t, e) {
        const n = new function (t) {
          const e = this; let n = '';

          e.next = function () {
            const t = e.x ^ e.x >>> 2;

            return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;
          }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, t === ((e.v = 0) | t) ? e.x = t : n += t; for (let r = 0; r < n.length + 64; r++)e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();
        }(t); const r = e && e.state; const o = function () { return (n.next() >>> 0) / 4294967296; };

        return o.double = function () {
          do { var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21); } while (t === 0);

          return t;
        }, o.int32 = n.next, o.quick = o, r && (typeof r === 'object' && i(r, n), o.state = function () { return i(n, {}); }), o;
      }e && e.exports ? e.exports = r : this.xorwow = r;
    }(0, t));
  }); const Mo = Io((t) => {
    !(function (t, e, n) {
      function i(t, e) { return e.x = t.x.slice(), e.i = t.i, e; } function r(t, e) {
        t == null && (t = +new Date()); const n = new function (t) {
          const o = this;

          o.next = function () {
            let t; let e; const n = o.x; const r = o.i;

            return t = n[r], e = (t ^= t >>> 7) ^ t << 24, e ^= (t = n[r + 1 & 7]) ^ t >>> 10, e ^= (t = n[r + 3 & 7]) ^ t >>> 3, e ^= (t = n[r + 4 & 7]) ^ t << 7, t = n[r + 7 & 7], e ^= (t ^= t << 13) ^ t << 9, n[r] = e, o.i = r + 1 & 7, e;
          }, (function (t, e) {
            let n; const r = [];

            if (e === (0 | e))r[0] = e; else for (e = `${ e}`, n = 0; n < e.length; ++n)r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13; for (;r.length < 8;)r.push(0); for (n = 0; n < 8 && r[n] === 0; ++n);for (n == 8 ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n)t.next();
          }(o, t));
        }(t); const r = e && e.state; const o = function () { return (n.next() >>> 0) / 4294967296; };

        return o.double = function () {
          do { var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21); } while (t === 0);

          return t;
        }, o.int32 = n.next, o.quick = o, r && (r.x && i(r, n), o.state = function () { return i(n, {}); }), o;
      }e && e.exports ? e.exports = r : this.xorshift7 = r;
    }(0, t));
  }); const Oo = Io((t) => {
    !(function (t, e, n) {
      function i(t, e) { return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e; } function r(t, e) {
        t == null && (t = +new Date()); const n = new function (t) {
          const i = this;

          i.next = function () {
            let t; let e; let n = i.w; const r = i.X; let o = i.i;

            return i.w = n = n + 1640531527 | 0, e = r[o + 34 & 127], t = r[o = o + 1 & 127], e ^= e << 13, t ^= t << 17, e ^= e >>> 15, t ^= t >>> 12, e = r[o] = e ^ t, i.i = o, e + (n ^ n >>> 16) | 0;
          }, (function (t, e) {
            let n; let r; let o; let i; let a; const s = []; let u = 128;

            for (e === (0 | e) ? (r = e, e = null) : (e += '\0', r = 0, u = Math.max(u, e.length)), o = 0, i = -32; i < u; ++i)e && (r ^= e.charCodeAt((i + 32) % e.length)), i === 0 && (a = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, i >= 0 && (a = a + 1640531527 | 0, o = (n = s[127 & i] ^= r + a) == 0 ? o + 1 : 0); for (o >= 128 && (s[127 & (e && e.length || 0)] = -1), o = 127, i = 512; i > 0; --i)r = s[o + 34 & 127], n = s[o = o + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[o] = r ^ n; t.w = a, t.X = s, t.i = o;
          }(i, t));
        }(t); const r = e && e.state; const o = function () { return (n.next() >>> 0) / 4294967296; };

        return o.double = function () {
          do { var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21); } while (t === 0);

          return t;
        }, o.int32 = n.next, o.quick = o, r && (r.X && i(r, n), o.state = function () { return i(n, {}); }), o;
      }e && e.exports ? e.exports = r : this.xor4096 = r;
    }(0, t));
  }); const Po = Io((t) => {
    !(function (t, e, n) {
      function i(t, e) { return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e; } function r(t, e) {
        const n = new function (t) {
          const o = this; let e = '';

          o.next = function () {
            let t = o.b; let e = o.c; let n = o.d; let r = o.a;

            return t = t << 25 ^ t >>> 7 ^ e, e = e - n | 0, n = n << 24 ^ n >>> 8 ^ r, r = r - t | 0, o.b = t = t << 20 ^ t >>> 12 ^ e, o.c = e = e - n | 0, o.d = n << 16 ^ e >>> 16 ^ r, o.a = r - t | 0;
          }, o.a = 0, o.b = 0, o.c = -1640531527, o.d = 1367130551, t === Math.floor(t) ? (o.a = t / 4294967296 | 0, o.b = 0 | t) : e += t; for (let n = 0; n < e.length + 20; n++)o.b ^= 0 | e.charCodeAt(n), o.next();
        }(t); const r = e && e.state; const o = function () { return (n.next() >>> 0) / 4294967296; };

        return o.double = function () {
          do { var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21); } while (t === 0);

          return t;
        }, o.int32 = n.next, o.quick = o, r && (typeof r === 'object' && i(r, n), o.state = function () { return i(n, {}); }), o;
      }e && e.exports ? e.exports = r : this.tychei = r;
    }(0, t));
  }); const Fo = Io((e) => {
    !(function (s, u) {
      let c; const l = this; const h = 256; const p = 6; const f = 'random'; const d = u.pow(h, p); const m = u.pow(2, 52); const v = 2 * m; const g = h - 1;

      function t(t, e, n) {
        const r = []; const o = x((function t(e, n) {
          let r; const o = []; const i = typeof e;

          if (n && i == 'object') { for (r in e) {try { o.push(t(e[r], n - 1)); }
 catch (t) {}}}

          return o.length ? o : i == 'string' ? e : `${e}\0`;
        }((e = e == 1 ? {entropy: !0} : e || {}).entropy ? [t, b(s)] : t == null ? (function () {
          try {
            let t;

            return c && (t = c.randomBytes) ? t = t(h) : (t = new Uint8Array(h), (l.crypto || l.msCrypto).getRandomValues(t)), b(t);
          }
          catch (t) {
 const e = l.navigator; const n = e && e.plugins;

            return [+new Date(), l, n, l.screen, b(s)]; 
}
        }()) : t, 3)), r); const i = new function (t) {
          let e; let n = t.length; const a = this; let r = 0; let o = a.i = a.j = 0; const i = a.S = [];

          for (n || (t = [n++]); r < h;)i[r] = r++; for (r = 0; r < h; r++)i[r] = i[o = g & o + t[r % n] + (e = i[r])], i[o] = e; (a.g = function (t) {
            for (var e, n = 0, r = a.i, o = a.j, i = a.S; t--;)e = i[r = g & r + 1], n = n * h + i[g & (i[r] = i[o = g & o + e]) + (i[o] = e)];

            return a.i = r, a.j = o, n;
          })(h);
        }(r); const a = function () {
          for (var t = i.g(p), e = d, n = 0; t < m;)t = (t + n) * h, e *= h, n = i.g(1); for (;v <= t;)t /= 2, e /= 2, n >>>= 1;

          return (t + n) / e;
        };

        return a.int32 = function () { return 0 | i.g(4); }, a.quick = function () { return i.g(4) / 4294967296; }, a.double = a, x(b(i.S), s), (e.pass || n || function (t, e, n, r) { return r && (r.S && y(r, i), t.state = function () { return y(i, {}); }), n ? (u[f] = t, e) : t; })(a, o, 'global' in e ? e.global : this == u, e.state);
      } function y(t, e) { return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e; } function x(t, e) {
        for (var n, r = `${t}`, o = 0; o < r.length;)e[g & o] = g & (n ^= 19 * e[g & o]) + r.charCodeAt(o++);

        return b(e);
      } function b(t) { return String.fromCharCode.apply(0, t); } if (u[`seed${f}`] = t, x(u.random(), s), e.exports) {
        e.exports = t; try { c = require('crypto'); }
        catch (t) {}
      }
    }([], Math));
  });

  Fo.alea = Do, Fo.xor128 = No, Fo.xorwow = Ao, Fo.xorshift7 = Mo, Fo.xor4096 = Oo, Fo.tychei = Po; const Lo = Fo.alea; const Bo = (function () {
    function t(t, e, n, r, o) {
      this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev); const i = o || Math.random();

      this.random = Lo(i.toString());
    }

    return t.prototype.nextValue = function () {
      if (!isNaN(this.nextVal)) {
        const t = this.nextVal;

        return this.nextVal = NaN, t;
      } for (var e, n, r = !1; !r;) {
        for (var o = void 0, i = void 0, a = void 0; (a = (o = 2 * this.random() - 1) * o + (i = 2 * this.random() - 1) * i) >= 1 || a === 0;);const s = Math.sqrt(-2 * Math.log(a) / a);

        e = this.mean + this.stdDev * o * s, n = this.mean + this.stdDev * i * s, this.truncated && !this.isValidTruncated(e) || (r = !0);
      }

      return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e);
    }, t.prototype.convertValue = function (t) { return this.dtype == null || this.dtype === 'float32' ? t : Math.round(t); }, t.prototype.isValidTruncated = function (t) { return t <= this.upper && t >= this.lower; }, t;
  }());

  function zo(w, E) {
    return m(this, void 0, void 0, function () {
      let e, n, r, o, i, a, s, u, c, l, h, p, f, d, m, v, g, y, x, b;

      return S(this, (t) => {
        switch (t.label) {
          case 0: if ((e = Kt(w, 'img', 'toPixels', 'int32')).rank !== 2 && e.rank !== 3) throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`); if (n = e.shape.slice(0, 2), r = n[0], o = n[1], (i = e.rank === 2 ? 1 : e.shape[2]) > 4 || i === 2) throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${i}`);

            return a = e.min(), s = e.max(), [4, a.data()]; case 1: return u = t.sent()[0], [4, s.data()]; case 2: if (c = t.sent()[0], a.dispose(), s.dispose(), e.dtype === 'float32') { if (u < 0 || c > 1) throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [${u} - ${c}].`); }
          else { if (e.dtype !== 'int32') throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`); if (u < 0 || c > 255) throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [${u} - ${c}].`); }

            return [4, e.data()]; case 3: for (l = t.sent(), h = e.dtype === 'float32' ? 255 : 1, p = new Uint8ClampedArray(o * r * 4), f = 0; f < r * o; ++f)g = v = m = d = void 0, i === 1 ? (d = l[f] * h, m = l[f] * h, v = l[f] * h, g = 255) : i === 3 ? (d = l[3 * f] * h, m = l[3 * f + 1] * h, v = l[3 * f + 2] * h, g = 255) : i === 4 && (d = l[4 * f] * h, m = l[4 * f + 1] * h, v = l[4 * f + 2] * h, g = l[4 * f + 3] * h), p[0 + (y = 4 * f)] = Math.round(d), p[y + 1] = Math.round(m), p[y + 2] = Math.round(v), p[y + 3] = Math.round(g);

            return E != null && (E.width = o, E.height = r, x = E.getContext('2d'), b = new ImageData(p, o, r), x.putImageData(b, 0, 0)), e !== w && e.dispose(), [2, p];
        }
      });
    });
  } function Wo(t, e, n) { return void 0 === e && (e = 'float32'), new H(t, e, n); } function Uo(t, e) { void 0 === e && (e = !1), console.log(t.toString(e)); } const Vo = Yt({
    batchToSpaceND_(t, e, n) {
      const r = Kt(t, 'x', 'batchToSpaceND'); const o = e.reduce((t, e) => t * e);

      return D(r.rank >= 1 + e.length, `input rank is ${r.rank} but should be > than blockShape.length ${e.length}`), D(n.length === e.length, `crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`), D(r.shape[0] % o == 0, `input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(' * ')} === ${o}`), mt.engine.runKernel((t) => t.batchToSpaceND(r, e, n), {$x: r}, (t) => ({$x() { return t.spaceToBatchND(e, n); }}));
    }
  }); const Go = Yt({
    cast_(t, e) {
      const n = Kt(t, 'x', 'cast');

      return mt.engine.runKernel((t) => t.cast(n, e), {$x: n}, (t) => ({$x() { return t.clone(); }}));
    }
  }); const qo = Yt({
    clone_(t) {
      const e = Kt(t, 'x', 'clone');

      return mt.engine.runKernel((t) => Y.make(e.shape, {dataId: e.dataId}, e.dtype), {$x: e}, (t) => ({$x() { return t.toFloat(); }}));
    }
  }); const jo = Yt({
    cumsum_(t, e, n, r) {
      void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1); const o = Kt(t, 'x', 'cumsum'); const i = Ft([e |= 0], o.rank); let a = o;

      i != null && (a = o.transpose(i)); const s = Bt(1, o.rank)[0]; let u = mt.engine.runKernel((t) => t.cumsum(a, s, n, r), {permutedX: a}, (t) => ({permutedX() { return t.cumsum(e, n, !r); }}));

      return i != null && (u = u.transpose(i)), u;
    }
  }); const Ho = Yt({
    depthToSpace_(t, e, n) {
      void 0 === n && (n = 'NHWC'); const r = Kt(t, 'x', 'depthToSpace'); const o = n === 'NHWC' ? r.shape[1] : r.shape[2]; const i = n === 'NHWC' ? r.shape[2] : r.shape[3]; const a = n === 'NHWC' ? r.shape[3] : r.shape[1];

      return D(o * e >= 0, `Negative dimension size caused by overflow when multiplying\n      ${o} and ${e}  for depthToSpace with input shape\n      ${r.shape}`), D(i * e >= 0, `Negative dimension size caused by overflow when multiplying\n      ${i} and ${e} for depthToSpace with input shape\n          ${r.shape}`), D(a % (e * e) == 0, `Dimension size must be evenly divisible by ${e * e} but is ${a} for depthToSpace with input shape ${r.shape}`), mt.engine.runKernel((t) => t.depthToSpace(r, e, n), {$x: r});
    }
  }); const $o = Yt({
    expandDims_(t, e) {
      void 0 === e && (e = 0); const n = Kt(t, 'x', 'expandDims');

      D(e <= n.rank, 'Axis must be <= rank of the tensor'); const r = n.shape.slice();

      return e < 0 && (D(-(n.rank + 1) <= e, `Axis must be in the interval [${-(n.rank + 1)}, ${n.rank}]`), e = n.rank + e + 1), r.splice(e, 0, 1), ai(n, r);
    }
  }); const Ko = Yt({
    eye_(t, e, n, r) {
      void 0 === r && (r = 'float32'), e == null && (e = t); for (var o = Wo([t, e], r), i = t <= e ? t : e, a = 0; a < i; ++a)o.set(1, a, a); const s = o.toTensor().as2D(t, e);

      if (n == null) return s; if (n.length === 1) return li($o(s, 0), [n[0], 1, 1]); if (n.length === 2) return li($o($o(s, 0), 0), [n[0], n[1], 1, 1]); if (n.length === 3) return li($o($o($o(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]); throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`);
    }
  }); const Xo = Yt({
    fromPixels_(t, e) {
      if (void 0 === e && (e = 3), e > 4) throw new Error('Cannot construct Tensor with more than 4 channels from pixels.');

      return mt.engine.fromPixels(t, e);
    }
  }); const Yo = Yt({
    multinomial_(t, e, n, r) {
      void 0 === r && (r = !1); const o = Kt(t, 'logits', 'multinomial'); const i = o.size; const a = o.rank;

      if (i < 2) throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`); if (a > 2) throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`); n = n || Math.random(); const s = a === 1 ? o.as2D(1, -1) : o; const u = mt.engine.runKernel((t) => t.multinomial(s, r, e, n), {logits2D: s});

      return a === 1 ? u.as1D() : u;
    }
  }); const Qo = Yt({
    oneHot_(t, e, n, r) {
      void 0 === n && (n = 1), void 0 === r && (r = 0); const o = Kt(t, 'indices', 'oneHot', 'int32');

      if (D(o.dtype === 'int32', 'Indices must be of dtype `int32`'), e < 2) throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);

      return mt.engine.runKernel((t) => t.oneHot(o, e, n, r), {$indices: o}, (t) => ({$indices() { return Te(o); }}));
    }
  }); const Jo = Yt({
    pad_(t, e, n) {
      void 0 === n && (n = 0); const r = Kt(t, 'x', 'pad');

      if (r.rank === 0) throw new Error('pad(scalar) is not defined. Pass non-scalar to pad'); const o = e.map((t) => t[0]);

      return mt.engine.runKernel((t) => t.pad(r, e, n), {$x: r}, (t) => ({$x() { return t.slice(o, r.shape); }}));
    }
  }); const Zo = Yt({pad1d_(t, e, n) { return void 0 === n && (n = 0), D(e.length === 2, 'Invalid number of paddings. Must be length of 2.'), Jo(t, [e], n); }}); const ti = Yt({pad2d_(t, e, n) { return void 0 === n && (n = 0), D(e.length === 2 && e[0].length === 2 && e[1].length === 2, 'Invalid number of paddings. Must be length of 2 each.'), Jo(t, e, n); }}); const ei = Yt({pad3d_(t, e, n) { return void 0 === n && (n = 0), D(e.length === 3 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2, 'Invalid number of paddings. Must be length of 2 each.'), Jo(t, e, n); }}); const ni = Yt({pad4d_(t, e, n) { return void 0 === n && (n = 0), D(e.length === 4 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2 && e[3].length === 2, 'Invalid number of paddings. Must be length of 2 each.'), Jo(t, e, n); }}); const ri = Yt({
    rand_(t, e, n) {
      const r = B(t); let o = null;

      if (n == null || n === 'float32')o = new Float32Array(r); else if (n === 'int32')o = new Int32Array(r); else { if (n !== 'bool') throw new Error(`Unknown data type ${n}`); o = new Uint8Array(r); } for (let i = 0; i < r; i++)o[i] = e();

      return Y.make(t, {values: o}, n);
    }
  }); const oi = Yt({
    randomNormal_(t, e, n, r, o) {
      if (void 0 === e && (e = 0), void 0 === n && (n = 1), r != null && r === 'bool') throw new Error(`Unsupported data type ${r}`); for (var i = new Bo(e, n, r, !1, o), a = Wo(t, r), s = 0; s < a.values.length; s++)a.values[s] = i.nextValue();

      return a.toTensor();
    }
  }); const ii = Yt({
    randomUniform_(t, e, n, r) {
      void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = 'float32'); for (var o = Wo(t, r), i = 0; i < o.values.length; i++)o.values[i] = a(e, n);

      return o.toTensor();
    }
  }); var ai = Yt({
    reshape_(t, e) {
      const n = Kt(t, 'x', 'reshape');

      return e = g(e, n.size), D(n.size === B(e), 'new shape and old shape must have the same number of elements.'), mt.engine.runKernel((t) => t.reshape(n, e), {$x: n}, (t) => ({$x() { return t.reshape(n.shape); }}));
    }
  }); const si = Yt({
    spaceToBatchND_(t, r, o) {
      const e = Kt(t, 'x', 'spaceToBatchND');

      return D(e.rank >= 1 + r.length, `input rank ${e.rank} should be > than [blockShape] ${r.length}`), D(o.length === r.length, `paddings.shape[0] ${o.length} must be equal to [blockShape] ${r.length}`), D(e.shape.reduce((t, e, n) => (n > 0 && n <= r.length ? t && (e + o[n - 1][0] + o[n - 1][1]) % r[n - 1] == 0 : t), !0), `input spatial dimensions ${e.shape.slice(1)} with paddings ${o.toString()} must be divisible by blockShapes ${r.toString()}`), mt.engine.runKernel((t) => t.spaceToBatchND(e, r, o), {$x: e}, (t) => ({$x() { return t.batchToSpaceND(r, o); }}));
    }
  }); const ui = Yt({
    squeeze_(t, e) {
      const n = Kt(t, 'x', 'squeeze');

      return ai(n, y(n.shape, e).newShape);
    }
  }); const ci = Yt({
    stack_(t, e) {
      void 0 === e && (e = 0); const n = Xt(t, 'tensors', 'stack');

      if (D(n.length >= 1, 'Pass at least one tensor to tf.stack'), n.length === 1) return n[0].expandDims(e); const r = n[0].rank; const o = n[0].shape; const i = n[0].dtype;

      D(e <= r, 'Axis must be <= rank of the tensor'), n.forEach((t) => { f(o, t.shape, 'All tensors passed to stack must have matching shapes'); }), n.forEach((t) => { D(i === t.dtype, 'All tensors passed to stack must have matching dtypes'); }); const a = n.map((t) => t.expandDims(e));

      return So(a, e);
    }
  }); var li = Yt({
    tile_(t, a) {
      const s = Kt(t, 'x', 'tile');

      return D(s.rank === a.length, `Error in transpose: rank of input ${s.rank} must match length of reps ${a}.`), mt.engine.runKernel((t) => t.tile(s, a), {$x: s}, (i) => ({
$x() {
 let t = Te(s);

        if (s.rank === 1) for (var e = 0; e < a[0]; ++e)t = t.add(i.slice([e * s.shape[0]], [s.shape[0]])); else if (s.rank === 2) for (e = 0; e < a[0]; ++e) for (var n = 0; n < a[1]; ++n)t = t.add(i.slice([e * s.shape[0], n * s.shape[1]], [s.shape[0], s.shape[1]])); else if (s.rank === 3) for (e = 0; e < a[0]; ++e) for (n = 0; n < a[1]; ++n) for (var r = 0; r < a[2]; ++r)t = t.add(i.slice([e * s.shape[0], n * s.shape[1], r * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]])); else { if (s.rank !== 4) throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`); for (e = 0; e < a[0]; ++e) for (n = 0; n < a[1]; ++n) for (r = 0; r < a[2]; ++r) for (let o = 0; o < a[3]; ++o)t = t.add(i.slice([e * s.shape[0], n * s.shape[1], r * s.shape[2], o * s.shape[3]], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]])); }

        return t; 
}
}));
    }
  }); const hi = Yt({
    truncatedNormal_(t, e, n, r, o) {
      if (void 0 === e && (e = 0), void 0 === n && (n = 1), r != null && r === 'bool') throw new Error(`Unsupported data type ${r}`); for (var i = new Bo(e, n, r, !0, o), a = Wo(t, r), s = 0; s < a.values.length; s++)a.values[s] = i.nextValue();

      return a.toTensor();
    }
  }); const pi = Yt({
    unstack_(t, n) {
      void 0 === n && (n = 0); for (var e, r = Kt(t, 'x', 'unstack'), o = r.shape[n], i = Array(r.rank - 1).fill(0), a = 0, s = 0; s < r.rank; s++)s !== n && (i[a] = r.shape[s], a++); e = Array(o).fill(1); const u = Array(r.rank).fill(0); const c = r.shape.slice();

      return e.map((t) => {
        c[n] = t; const e = r.slice(u, c);

        return u[n] += t, e.reshape(i);
      });
    }
  });

  function fi(t, e) {
    for (var n = [], r = 0; r < e.length; r++)e[r] && n.push(r); const o = Wo(t, 'int32'); const i = Wo([n.length, t.length], 'int32');

    for (r = 0; r < n.length; r++) {
      const a = o.indexToLoc(n[r]); const s = r * t.length;

      i.values.set(a, s);
    }

    return i.toTensor();
  } const di = (function () {
    function t(t, e) { if (void 0 === e && (e = !0), this.gpgpu = t, this.delayedStorage = e, this.pendingRead = new WeakMap(), this.pendingDisposal = new WeakSet(), this.lruDataGPU = [], this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.binaryCache = {}, this.disposed = !1, mt.get('WEBGL_VERSION') < 1) throw new Error('WebGL is not supported on this device'); mt.get('IS_BROWSER') && (this.canvas = document.createElement('canvas')), t == null ? (this.gpgpu = new Wr(yr(this.canvas)), this.gpgpuCreatedLocally = !0) : this.gpgpuCreatedLocally = !1, mt.get('WEBGL_PAGING_ENABLED') && (this.NUM_BYTES_BEFORE_PAGING = window.screen.height * window.screen.width * window.devicePixelRatio * 300), this.textureManager = new po(this.gpgpu); }

    return t.prototype.register = function (t, e, n) {
      if (this.texData.has(t)) throw new Error('Data buffer is already registered'); this.texData.set(t, {
        shape: e, dtype: n, values: null, texture: null, complexTensors: null, texShape: null, usage: kn.RENDER, isPacked: !1
      });
    }, t.prototype.setDataMover = function (t) { this.texData = new Ne(t); }, t.prototype.fromPixels = function (t, e) {
      if (t == null) throw new Error('pixels passed to tf.fromPixels() can not be null'); const n = [t.height, t.width]; const r = [t.height, t.width, e];

      if (!(t instanceof HTMLVideoElement || t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageData)) throw new Error(`pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was ${t.constructor.name}`); if (t instanceof HTMLVideoElement) { if (this.fromPixelsCanvas == null) { if (!mt.get('IS_BROWSER')) throw new Error("Can't read pixels from HTMLImageElement outside the browser."); if (document.readyState !== 'complete') throw new Error('The DOM is not ready yet. Please call tf.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object'); this.fromPixelsCanvas = document.createElement('canvas'); } this.fromPixelsCanvas.width = t.width, this.fromPixelsCanvas.height = t.height, this.fromPixelsCanvas.getContext('2d').drawImage(t, 0, 0, t.width, t.height), t = this.fromPixelsCanvas; } const o = this.makeTensorHandle(n, 'int32');

      this.texData.get(o.dataId).usage = kn.PIXELS, this.gpgpu.uploadPixelDataToTexture(this.getTexture(o.dataId), t); const i = new Rn(r); const a = this.compileAndRun(i, [o]);

      return this.disposeData(o.dataId), a;
    }, t.prototype.makeTensorHandle = function (t, e) {
      const n = {};

      return this.register(n, t, e), {dataId: n, shape: t, dtype: e};
    }, t.prototype.write = function (t, e) {
      if (e == null) throw new Error('MathBackendWebGL.write(): values can not be null'); const n = this.texData.get(t); const r = n.texture; const o = n.texShape; const i = n.usage; const a = n.dtype; const s = n.isPacked;

      if (a === 'complex64') throw new Error('Cannot write to a complex64 dtype. Please use tf.complex(real, imag).'); r != null && (this.releaseTexture(t, r, o, i, s), n.texture = null, n.texShape = null), n.usage = kn.UPLOAD, n.values = e, this.delayedStorage || this.uploadToGPU(t);
    }, t.prototype.readSync = function (t) {
      const e = this.texData.get(t); const n = e.values; const r = e.dtype; const o = e.complexTensors;

      if (n != null) return this.cacheOnCPU(t), n; let i; let a; const s = this.activeTimers != null;

      return s && (i = performance.now()), a = r === 'complex64' ? Oe(o.real.dataSync(), o.imag.dataSync()) : this.getValuesFromTexture(t), s && (this.downloadWaitMs += performance.now() - i), this.cacheOnCPU(t, a), e.values;
    }, t.prototype.read = function (c) {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s, u;

        return S(this, function (t) {
          switch (t.label) {
            case 0: if (this.pendingRead.has(c)) return e = this.pendingRead.get(c), [2, new Promise(((t) => e.push(t)))]; if (n = this.texData.get(c), r = n.texture, o = n.values, i = n.texShape, o != null) return this.cacheOnCPU(c), [2, o]; if (this.pendingRead.set(c, []), !mt.get('WEBGL_DOWNLOAD_FLOAT_ENABLED') && mt.get('WEBGL_VERSION') === 2) throw new Error('tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.');

              return a = this.gpgpu.maybeCreateBufferFromTexture(r, i[0], i[1]), [4, this.gpgpu.createAndWaitForFence()]; case 1: return t.sent(), s = a instanceof WebGLTexture ? this.getValuesFromTexture(c) : this.gpgpu.downloadFloat32MatrixFromBuffer(a, i[0], i[1]), this.cacheOnCPU(c, s), u = this.pendingRead.get(c), this.pendingRead.delete(c), u.forEach((t) => t(s)), this.pendingDisposal.has(c) && (this.pendingDisposal.delete(c), this.disposeData(c)), [2, s];
          }
        });
      });
    }, t.prototype.getValuesFromTexture = function (t) {
      const e = this.texData.get(t); const n = e.shape; const r = e.dtype; const o = e.texture; const i = e.texShape;

      if (mt.get('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {
        if (this.texData.get(t).isPacked) {
          const a = B(n.slice(0, n.length - 2)); const s = n.length > 1 ? n[n.length - 2] : 1; const u = n[n.length - 1];

          return this.gpgpu.downloadMatrixFromPackedTexture(o, a, s, u, i[0], i[1]);
        }

        return this.gpgpu.downloadFloat32MatrixFromOutputTexture(o, i[0], i[1]);
      } const c = this.makeTensorHandle(n, 'float32');

      c.size = B(n), this.texData.get(c.dataId).usage = kn.DOWNLOAD; const l = new En(n);

      this.compileAndRun(l, [{shape: n, dtype: r, dataId: t}], c, null, !1); const h = this.texData.get(c.dataId); const p = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture, h.texShape[0], h.texShape[1]);

      return this.disposeData(c.dataId), p;
    }, t.prototype.time = function (u) {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s;

        return S(this, function (t) {
          switch (t.label) {
            case 0: return e = this.activeTimers, r = !(n = []), this.programTimersStack == null ? (this.programTimersStack = n, r = !0) : this.activeTimers.push(n), this.activeTimers = n, u(), o = l(this.activeTimers.map((t) => t.query)).filter((t) => t != null), i = l(this.activeTimers.map((t) => t.name)).filter((t) => t != null), this.activeTimers = e, r && (this.programTimersStack = null), [4, Promise.all(o)]; case 1: return a = t.sent(), s = {
              uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: c(a), getExtraProfileInfo() { return a.map((t, e) => ({name: i[e], ms: t})).map((t) => `${t.name}: ${t.ms}`).join(', '); }, wallMs: null
            }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s];
          }
        });
      });
    }, t.prototype.memory = function () { return {unreliable: !1, numBytesInGPU: this.numBytesInGPU}; }, t.prototype.startTimer = function () { return mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 ? this.gpgpu.beginQuery() : {startMs: performance.now(), endMs: null}; }, t.prototype.endTimer = function (t) { return mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 ? this.gpgpu.endQuery() : t.endMs = performance.now(), t; }, t.prototype.getQueryTime = function (n) {
      return m(this, void 0, void 0, function () {
        let e;

        return S(this, function (t) { return mt.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(n)] : [2, (e = n).endMs - e.startMs]; });
      });
    }, t.prototype.disposeData = function (t) {
      if (!this.pendingDisposal.has(t)) {
        if (this.pendingRead.has(t)) this.pendingDisposal.add(t); else if (this.texData.has(t)) {
          const e = this.texData.get(t); const n = e.texture; const r = e.texShape; const o = e.usage; const i = e.complexTensors; const a = e.isPacked;

          n != null && this.releaseTexture(t, n, r, o, a), i != null && (i.real.dispose(), i.imag.dispose()), this.texData.delete(t);
        }
      }
    }, t.prototype.getTexture = function (t) { return this.uploadToGPU(t), this.texData.get(t).texture; }, t.prototype.getGPGPUContext = function () { return this.gpgpu; }, t.prototype.getCanvas = function () { return this.canvas; }, t.prototype.complex = function (t, e) {
      const n = this.makeOutputArray(t.shape, 'complex64');

      return this.texData.get(n.dataId).complexTensors = {real: mt.engine.keep(t.clone()), imag: mt.engine.keep(e.clone())}, n;
    }, t.prototype.real = function (t) { return this.texData.get(t.dataId).complexTensors.real.clone(); }, t.prototype.imag = function (t) { return this.texData.get(t.dataId).complexTensors.imag.clone(); }, t.prototype.slice = function (t, e, n) {
      const r = new lo(n); const o = r.getCustomSetupFunc(e);

      return this.compileAndRun(r, [t], null, o);
    }, t.prototype.stridedSlice = function (t, e, n, r, o, i, a, s, u) {
      const c = qt(t.shape, e, n, r, o, i, a, s, u); const l = c[0]; const h = c[1]; const p = c[2]; const f = h.filter((t, e) => p.indexOf(e) === -1);

      if (f.some((t) => t === 0)) return ee([], f); const d = new ho(l, r, h, p);

      return this.compileAndRun(d, [t]);
    }, t.prototype.reverse = function (t, e) {
      const n = new ao(t.shape, e);

      return this.compileAndRun(n, [t]);
    }, t.prototype.concat2Tensors = function (t, e, n) {
      const r = zt([t.shape, e.shape], n); const o = t.as2D(-1, B(t.shape.slice(n))); const i = e.as2D(-1, B(e.shape.slice(n))); const a = new en(o.shape, i.shape);

      return this.compileAndRun(a, [o, i]).reshape(r);
    }, t.prototype.concat = function (t, e) {
      if (t.length === 1) return t[0]; for (var n = t[0], r = 1; r < t.length; ++r)n = this.concat2Tensors(n, t[r], e);

      return n;
    }, t.prototype.neg = function (t) {
      const e = new bo(t.shape, 'return -x;');

      return this.compileAndRun(e, [t]);
    }, t.prototype.batchMatMul = function (t, e, n, r) {
      const o = n ? t.shape[2] : t.shape[1]; const i = r ? e.shape[1] : e.shape[2];

      if (t.shape[0] !== 1 || e.shape[0] !== 1) return this.compileAndRun(new Hr(t.shape, e.shape, n, r), [t, e]); const a = t.as2D(t.shape[1], t.shape[2]); const s = e.as2D(e.shape[1], e.shape[2]); const u = new $r(a.shape, s.shape, [o, i], n, r); const c = this.unpackTensor(this.compileAndRun(u, [a, s], this.makePackedTensor(u.outputShape)));

      return c.reshape([1, c.shape[0], c.shape[1]]);
    }, t.prototype.multiply = function (t, e) {
      if (t.dtype === 'complex64') {
        const n = this.texData.get(t.dataId); const r = this.texData.get(e.dataId); const o = new Xe($e, t.shape, e.shape); const i = new Xe(Ke, t.shape, e.shape); const a = [this.makeComplexComponentTensorHandle(t, n.complexTensors.real), this.makeComplexComponentTensorHandle(t, n.complexTensors.imag), this.makeComplexComponentTensorHandle(e, r.complexTensors.real), this.makeComplexComponentTensorHandle(e, r.complexTensors.imag)]; const s = this.compileAndRun(o, a); const u = this.compileAndRun(i, a); const c = this.complex(s, u);

        return s.dispose(), u.dispose(), c;
      } const l = new Je('return a * b;', t.shape, e.shape); const h = this.makeOutputArray(l.outputShape, t.dtype);

      return this.compileAndRun(l, [t, e], h);
    }, t.prototype.batchNormalization = function (t, e, n, r, o, i) {
      const a = [t, e, n]; let s = null;

      i != null && (s = i.shape, a.push(i)); let u = null;

      o != null && (u = o.shape, a.push(o)); let c = null; let l = qe;

      mt.get('WEBGL_PACK_BATCHNORMALIZATION') && (c = this.makePackedTensor(t.shape), l = je); const h = new l(t.shape, e.shape, n.shape, s, u, r);

      return this.compileAndRun(h, a, c);
    }, t.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
      const i = new Gr(t.shape, e, n, r, o);

      return this.compileAndRun(i, [t]);
    }, t.prototype.LRNGrad = function (t, e, n, r, o, i, a) {
      const s = new qr(e.shape, r, o, i, a);

      return this.compileAndRun(s, [e, n, t]);
    }, t.prototype.tile = function (t, e) {
      const n = new vo(t.shape, e);

      return this.compileAndRun(n, [t]);
    }, t.prototype.pad = function (t, e, n) {
      const r = new Zr(t.shape, e, n);

      return this.compileAndRun(r, [t]);
    }, t.prototype.transpose = function (t, e) {
      const n = new go(t.shape, e);

      return this.compileAndRun(n, [t]);
    }, t.prototype.gather = function (t, e, n) {
      const r = new Tn(t.shape, e.size, n);

      return this.compileAndRun(r, [t, e]);
    }, t.prototype.batchToSpaceND = function (t, e, n) {
      D(t.rank <= 4, 'batchToSpaceND for rank > 4 with a WebGL backend not implemented yet'); const r = e.reduce((t, e) => t * e); const o = Rt(t.shape, e, r); const i = Tt(o.length, e.length); const a = kt(t.shape, e, r); const s = It(n, e.length); const u = Dt(a, n, e.length);

      return t.reshape(o).transpose(i).reshape(a).slice(s, u);
    }, t.prototype.spaceToBatchND = function (t, e, n) {
      D(t.rank <= 4, 'spaceToBatchND for rank > 4 with a WebGL backend not implemented yet'); const r = e.reduce((t, e) => t * e); const o = [[0, 0]];

      o.push.apply(o, n); for (let i = 1 + e.length; i < t.shape.length; ++i)o.push([0, 0]); const a = t.pad(o); const s = Rt(a.shape, e, r, !1); const u = Tt(s.length, e.length, !1); const c = kt(a.shape, e, r, !1);

      return a.reshape(s).transpose(u).reshape(c);
    }, t.prototype.reduce = function (t, e, n) {
      const r = t.shape[0]; const o = t.shape[1]; const i = Ut(o); const a = new eo({windowSize: i, inSize: o, batchSize: r}, e); const s = a.outputShape; const u = s[0]; const c = s[1]; const l = this.makeOutputArray([u, c], n);

      return this.compileAndRun(a, [t], l), l.shape[1] === 1 ? l : this.reduce(l, e, n);
    }, t.prototype.argReduce = function (t, e, n) {
      void 0 === n && (n = null); let r = t.shape[0]; let o = t.shape[1];

      n != null && (r = n.shape[0], o = n.shape[1]); const i = Ut(o); const a = new ze({windowSize: i, inSize: o, batchSize: r}, e, n == null); const s = a.outputShape; const u = s[0]; const c = s[1]; const l = this.makeOutputArray([u, c], 'int32'); const h = [t];

      return n != null && h.push(n), this.compileAndRun(a, h, l), l.shape[1] === 1 ? l : this.argReduce(t, e, l);
    }, t.prototype.sum = function (t, e) {
      Pt('sum', e, t.rank); const n = At(t.shape, e); const r = n[0]; const o = B(n[1]); const i = t.as2D(-1, o); const a = De(t.dtype);

      return this.reduce(i, 'sum', a).reshape(r);
    }, t.prototype.prod = function (t, e) {
      const n = At(t.shape, e); const r = n[0]; const o = B(n[1]); const i = t.as2D(-1, o); const a = De(t.dtype);

      return this.reduce(i, 'prod', a).reshape(r);
    }, t.prototype.unsortedSegmentSum = function (t, e, n) {
      let r = 0; const o = Ft([r], t.rank); let i = t;

      o != null && (i = t.transpose(o), r = Bt(1, t.rank)[0]); const a = (function (t, e, n) {
        for (var r = [], o = t.length, i = 0; i < o; i++)i !== e ? r.push(t[i]) : r.push(n);

        return r;
      }(i.shape, r, n)); const s = B([i.shape[r]]); const u = i.as2D(-1, s); const c = De(t.dtype); let l = this.segOpCompute(u, 'unsortedSegmentSum', e, c, n).reshape(a);

      return o != null && (l = l.transpose(Lt(o))), l;
    }, t.prototype.segOpCompute = function (t, e, n, r, o) {
      const i = t.shape[0]; const a = t.shape[1]; const s = (function (t, e) {
        let n; let r = !1;

        for (t <= 30 ? (n = t, r = !0) : n = I(t, Math.floor(Math.sqrt(t))); !r;) { if (e < n || n === t) { r = !0; break; }n = I(t, n + 1); }

        return n;
      }(a, o)); const u = new uo({
        windowSize: s, inSize: a, batchSize: i, numSegments: o
      }, e); const c = u.outputShape; const l = c[0]; const h = c[1]; const p = this.makeOutputArray([l, h], r);

      return this.compileAndRun(u, [t, n], p), p.shape[1] === o ? p : (n = fe(0, o).tile([a / s]), this.segOpCompute(p, e, n, r, o));
    }, t.prototype.argMin = function (t, e) {
      const n = [e];

      Pt('argMin', n, t.rank); const r = At(t.shape, n); const o = r[0]; const i = B(r[1]); const a = t.as2D(-1, i);

      return this.argReduce(a, 'min').reshape(o);
    }, t.prototype.argMax = function (t, e) {
      const n = [e];

      Pt('argMax', n, t.rank); const r = At(t.shape, n); const o = r[0]; const i = B(r[1]); const a = t.as2D(-1, i);

      return this.argReduce(a, 'max').reshape(o);
    }, t.prototype.cumsum = function (t, e, n, r) {
      if (e !== t.rank - 1) throw new Error(`WebGL cumsum shader expects an inner-most axis=${t.rank - 1} but got axis=${e}`); const o = new xn(t.shape, n, r);

      return this.compileAndRun(o, [t]);
    }, t.prototype.equal = function (t, e) {
      const n = new Je('return float(a == b);', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'bool');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.notEqual = function (t, e) {
      const n = new Je('return float(a != b);', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'bool');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.less = function (t, e) {
      const n = new Je('return float(a < b);', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'bool');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.lessEqual = function (t, e) {
      const n = new Je('return float(a <= b);', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'bool');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.greater = function (t, e) {
      const n = new Je('return float(a > b);', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'bool');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.greaterEqual = function (t, e) {
      const n = new Je('return float(a >= b);', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'bool');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.logicalNot = function (t) {
      const e = new bo(t.shape, 'return float(!(x >= 1.0));');

      return this.compileAndRun(e, [t]);
    }, t.prototype.logicalAnd = function (t, e) {
      const n = new Je('return float(a >= 1.0 && b >= 1.0);', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'bool');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.logicalOr = function (t, e) {
      const n = new Je('return float(a >= 1.0 || b >= 1.0);', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'bool');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.select = function (t, e, n) {
      const r = new co(t.rank, e.shape, e.rank); const o = this.makeOutputArray(r.outputShape, Ie(e.dtype, n.dtype));

      return this.compileAndRun(r, [t, e, n], o);
    }, t.prototype.where = function (t) {
      Ct('tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead'); const e = t.dataSync();

      return fi(t.shape, e);
    }, t.prototype.topk = function (t, e, n) { return Be(t.dataSync(), t.shape, t.dtype, e); }, t.prototype.min = function (t, e) {
      Pt('min', e, t.rank); const n = At(t.shape, e); const r = n[0]; const o = B(n[1]); const i = t.as2D(-1, o);

      return this.reduce(i, 'min', i.dtype).reshape(r);
    }, t.prototype.minimum = function (t, e) {
      const n = new Je('\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n\n  return min(a, b);\n', t.shape, e.shape);

      return this.compileAndRun(n, [t, e]);
    }, t.prototype.mod = function (t, e) {
      const n = new Je('if (b == 0.0) return NAN;\n  return mod(a, b);', t.shape, e.shape); const r = n.getCustomSetupFunc();

      return this.compileAndRun(n, [t, e], null, r);
    }, t.prototype.max = function (t, e) {
      Pt('max', e, t.rank); const n = At(t.shape, e); const r = n[0]; const o = B(n[1]); const i = t.as2D(-1, o);

      return this.reduce(i, 'max', i.dtype).reshape(r);
    }, t.prototype.maximum = function (t, e) {
      const n = new Je('\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n\n  return max(a, b);\n', t.shape, e.shape);

      return this.compileAndRun(n, [t, e]);
    }, t.prototype.all = function (t, e) {
      Pt('all', e, t.rank); const n = At(t.shape, e); const r = n[0]; const o = B(n[1]); const i = t.as2D(-1, o);

      return this.reduce(i, 'all', i.dtype).reshape(r);
    }, t.prototype.any = function (t, e) {
      Pt('any', e, t.rank); const n = At(t.shape, e); const r = n[0]; const o = B(n[1]); const i = t.as2D(-1, o);

      return this.reduce(i, 'any', i.dtype).reshape(r);
    }, t.prototype.squaredDifference = function (t, e) {
      const n = new Je('return (a - b) * (a - b);', t.shape, e.shape);

      return this.compileAndRun(n, [t, e]);
    }, t.prototype.realDivide = function (t, e) {
      const n = new Je('if (a == b) return 1.0;\n  return a / b;', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'float32');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.floorDiv = function (t, e) {
      const n = new Je('\n  float resultSign = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  int result = ia / ib;\n  int amodb = ia - ib * result;\n\n  if (resultSign < 0.0 && amodb != 0) {\n    result -= 1;\n  }\n  return float(result);\n', t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, 'int32');

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.add = function (t, e) {
      if (t.dtype === 'complex64' && e.dtype === 'complex64') return this.complexSeparableBinaryOp(t, e, Ye); const n = new Je(Ye, t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, Ie(t.dtype, e.dtype));

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.complexSeparableBinaryOp = function (s, u, c) {
      const l = this; const t = this.texData.get(s.dataId); const e = this.texData.get(u.dataId); const n = [[t.complexTensors.real, e.complexTensors.real], [t.complexTensors.imag, e.complexTensors.imag]].map((t) => {
        const e = t[0]; const n = t[1]; const r = new Je(c, s.shape, u.shape); const o = l.makeOutputArray(r.outputShape, Ie(e.dtype, n.dtype)); const i = l.makeComplexComponentTensorHandle(s, e); const a = l.makeComplexComponentTensorHandle(u, n);

        return l.compileAndRun(r, [i, a], o);
      }); const r = n[0]; const o = n[1]; const i = this.complex(r, o);

      return r.dispose(), o.dispose(), i;
    }, t.prototype.makeComplexComponentTensorHandle = function (t, e) { return {dataId: e.dataId, dtype: e.dtype, shape: t.shape}; }, t.prototype.addN = function (t) {
      for (var e = t[0], n = 1; n < t.length; n++)e = this.add(e, t[n]);

      return e;
    }, t.prototype.subtract = function (t, e) {
      if (t.dtype === 'complex64' && e.dtype === 'complex64') return this.complexSeparableBinaryOp(t, e, Qe); const n = new Je(Qe, t.shape, e.shape); const r = this.makeOutputArray(n.outputShape, Ie(t.dtype, e.dtype));

      return this.compileAndRun(n, [t, e], r);
    }, t.prototype.pow = function (t, e) {
      const n = new Je('\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nreturn (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n', t.shape, e.shape); const r = n.getCustomSetupFunc(); const o = this.makeOutputArray(n.outputShape, Ie(t.dtype, e.dtype));

      return this.compileAndRun(n, [t, e], o, r);
    }, t.prototype.ceil = function (t) {
      const e = new bo(t.shape, 'return ceil(x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.floor = function (t) {
      const e = new bo(t.shape, 'return floor(x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.sign = function (t) {
      const e = new bo(t.shape, '\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.round = function (t) {
      const e = new bo(t.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");

      return this.compileAndRun(e, [t]);
    }, t.prototype.exp = function (t) {
      const e = new bo(t.shape, 'return exp(x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.expm1 = function (t) {
      const e = new bo(t.shape, 'return exp(x) - 1.0;');

      return this.compileAndRun(e, [t]);
    }, t.prototype.log = function (t) {
      const e = new bo(t.shape, 'if (x < 0.0) return NAN;\n  return log(x);'); const n = e.getCustomSetupFunc();

      return this.compileAndRun(e, [t], null, n);
    }, t.prototype.log1p = function (t) {
      const e = new bo(t.shape, 'return log(1.0 + x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.sqrt = function (t) {
      const e = new bo(t.shape, 'return sqrt(x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.rsqrt = function (t) {
      const e = new bo(t.shape, 'return inversesqrt(x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.square = function (t) {
      const e = new bo(t.shape, 'return x * x;');

      return this.compileAndRun(e, [t]);
    }, t.prototype.reciprocal = function (t) {
      const e = new bo(t.shape, 'return 1.0 / x;');

      return this.compileAndRun(e, [t]);
    }, t.prototype.relu = function (t) {
      const e = new bo(t.shape, 'if (isNaN(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.elu = function (t) {
      const e = new bo(t.shape, 'return (x >= 0.0) ? x : (exp(x) - 1.0);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.eluDer = function (t, e) {
      const n = new Je('return (b >= 1.0) ? a : a * (b + 1.0);', t.shape, e.shape);

      return this.compileAndRun(n, [t, e]);
    }, t.prototype.selu = function (t) {
      const e = new bo(t.shape, '\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.int = function (t) {
      const e = new bo(t.shape, 'return float(int(x));'); const n = this.makeOutputArray(e.outputShape, 'int32');

      return this.compileAndRun(e, [t], n);
    }, t.prototype.clip = function (t, e, n) {
      const r = new Ze(t.shape, e, n);

      return this.compileAndRun(r, [t]);
    }, t.prototype.abs = function (t) {
      if (t.dtype === 'complex64') {
        const e = this.texData.get(t.dataId); const n = new tn(t.shape); const r = [this.makeComplexComponentTensorHandle(t, e.complexTensors.real), this.makeComplexComponentTensorHandle(t, e.complexTensors.imag)];

        return this.compileAndRun(n, r);
      } const o = new bo(t.shape, 'return abs(x);');

      return this.compileAndRun(o, [t]);
    }, t.prototype.sigmoid = function (t) {
      const e = new bo(t.shape, 'return 1.0 / (1.0 + exp(-1.0 * x));');

      return this.compileAndRun(e, [t]);
    }, t.prototype.softplus = function (t) {
      const e = new bo(t.shape, '\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.sin = function (t) {
      const e = new bo(t.shape, 'if (isNaN(x)) return x;\n  return sin(x);\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.cos = function (t) {
      const e = new bo(t.shape, 'if (isNaN(x)) return x;\n  return cos(x);\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.tan = function (t) {
      const e = new bo(t.shape, 'return tan(x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.asin = function (t) {
      const e = new bo(t.shape, 'return asin(x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.acos = function (t) {
      const e = new bo(t.shape, 'return acos(x);');

      return this.compileAndRun(e, [t]);
    }, t.prototype.atan = function (t) {
      const e = new bo(t.shape, 'if (isNaN(x)) return x;\n  return atan(x);\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.atan2 = function (t, e) {
      const n = new Je('\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n\n  return atan(a, b);\n', t.shape, e.shape);

      return this.compileAndRun(n, [t, e]);
    }, t.prototype.sinh = function (t) {
      const e = new bo(t.shape, '\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.cosh = function (t) {
      const e = new bo(t.shape, '\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.tanh = function (t) {
      const e = new bo(t.shape, '\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.asinh = function (t) {
      const e = new bo(t.shape, 'return log(x + sqrt(x * x + 1.0));');

      return this.compileAndRun(e, [t]);
    }, t.prototype.acosh = function (t) {
      const e = new bo(t.shape, 'if (isNaN(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));'); const n = e.getCustomSetupFunc();

      return this.compileAndRun(e, [t], null, n);
    }, t.prototype.atanh = function (t) {
      const e = new bo(t.shape, 'if (isNaN(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;'); const n = e.getCustomSetupFunc();

      return this.compileAndRun(e, [t], null, n);
    }, t.prototype.erf = function (t) {
      const e = new bo(t.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n');

      return this.compileAndRun(e, [t]);
    }, t.prototype.step = function (t, e) {
      let n; const r = new bo(t.shape, (void 0 === (n = e) && (n = 0), `${wo}\n    return x > 0.0 ? 1.0 : float(${n});\n  `));

      return this.compileAndRun(r, [t]);
    }, t.prototype.conv2dWithIm2Row = function (t, e, n) {
      const r = n.filterWidth; const o = n.filterHeight; const i = n.inChannels; const a = n.outWidth; const s = n.outHeight; const u = r * o * i; const c = s * a; const l = [u, c]; const h = t.squeeze([0]); const p = e.reshape([u, -1]); const f = new Vr(l, h.shape, n); const d = this.compileAndRun(f, [h], this.makePackedTensor(l)); const m = new $r(d.shape, p.shape, [c, n.outChannels], !0, !1);

      return this.unpackTensor(this.compileAndRun(m, [d, p], this.makePackedTensor(m.outputShape))).reshape([1, s, a, n.outChannels]);
    }, t.prototype.conv2d = function (t, e, n) {
      if (mt.get('WEBGL_CONV_IM2COL') && t.shape[0] === 1) return this.conv2dWithIm2Row(t, e, n); const r = new sn(n);

      return this.compileAndRun(r, [t, e]);
    }, t.prototype.conv2dDerInput = function (t, e, n) {
      const r = new rn(n);

      return this.compileAndRun(r, [t, e]);
    }, t.prototype.conv2dDerFilter = function (t, e, n) {
      const r = new nn(n);

      return this.compileAndRun(r, [t, e]);
    }, t.prototype.depthwiseConv2D = function (t, e, n) {
      const r = new un(n);

      return this.compileAndRun(r, [t, e]);
    }, t.prototype.depthwiseConv2DDerInput = function (t, e, n) {
      const r = new an(n);

      return this.compileAndRun(r, [t, e]);
    }, t.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
      const r = new on(n);

      return this.compileAndRun(r, [t, e]);
    }, t.prototype.maxPool = function (t, e) {
      const n = new to(e, 'max', !1); const r = this.makeOutputArray(n.outputShape, t.dtype);

      return this.compileAndRun(n, [t], r);
    }, t.prototype.avgPool = function (t, e) {
      const n = new to(e, 'avg', !1); const r = this.makeOutputArray(n.outputShape, 'float32');

      return this.compileAndRun(n, [t], r);
    }, t.prototype.maxPoolBackprop = function (t, e, n, r) {
      const o = new to(r, 'max', !0); const i = this.compileAndRun(o, [e]); const a = new jr(r); const s = this.makeOutputArray(a.outputShape, e.dtype); const u = this.compileAndRun(a, [t, i], s);

      return i.dispose(), u;
    }, t.prototype.avgPoolBackprop = function (t, e, n) {
      const r = new We(n); const o = this.makeOutputArray(r.outputShape, e.dtype);

      return this.compileAndRun(r, [t], o);
    }, t.prototype.cast = function (t, e) { return Ae(t, e, this); }, t.prototype.reshape = function (t, e) { return Me(t, e); }, t.prototype.resizeBilinear = function (t, e, n, r) {
      const o = new ro(t.shape, e, n, r);

      return this.compileAndRun(o, [t]);
    }, t.prototype.resizeBilinearBackprop = function (t, e, n) {
      const r = new no(t, e, n);

      return this.compileAndRun(r, [t]);
    }, t.prototype.resizeNearestNeighbor = function (t, e, n, r) {
      const o = new io(t.shape, e, n, r);

      return this.compileAndRun(o, [t]);
    }, t.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
      const r = new oo(t, e, n);

      return this.compileAndRun(r, [t]);
    }, t.prototype.multinomial = function (t, e, n, r) {
      const o = e ? t : Qt(t); const i = o.shape[0]; const a = o.shape[1]; const s = new Kr(i, a, n); const u = this.makeOutputArray(s.outputShape, 'int32'); const c = s.getCustomSetupFunc(r);

      return this.compileAndRun(s, [o], u, c);
    }, t.prototype.oneHot = function (t, e, n, r) {
      const o = new Xr(t.size, e, n, r);

      return this.compileAndRun(o, [t]);
    }, t.prototype.nonMaxSuppression = function (t, e, n, r, o) { return Ct('tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead'), Pe(t.dataSync(), e.dataSync(), n, r, o); }, t.prototype.cropAndResize = function (t, e, n, r, o, i) {
      const a = new cn(t.shape, e.shape, r, o, i);

      return this.compileAndRun(a, [t, e, n]);
    }, t.prototype.depthToSpace = function (t, e, n) {
      D(e > 1, `blockSize should be > 1 for depthToSpace, but was: ${e}`); const r = t.shape[0]; const o = (n === 'NHWC' ? t.shape[1] : t.shape[2]) * e; const i = (n === 'NHWC' ? t.shape[2] : t.shape[3]) * e; const a = (n === 'NHWC' ? t.shape[3] : t.shape[1]) / (e * e); const s = new wn(n === 'NHWC' ? [r, o, i, a] : [r, a, o, i], e, n);

      return this.compileAndRun(s, [t]);
    }, t.prototype.split = function (t, e, n) { return Le(t, e, n); }, t.prototype.scatterND = function (t, e, n) {
      const r = Gt(0, t, n); const o = r.sliceRank; const i = r.numUpdates; const a = r.sliceSize; const s = r.strides; const u = r.outputSize; const c = [u / a, a]; const l = t.reshape([i, o]); const h = e.reshape([i, a]);

      if (u === 0) return Me(ee([]), n); const p = ne(0); const f = new so(i, o, l.rank, h.rank, s, c);

      return this.compileAndRun(f, [h, l, p]).reshape(n);
    }, t.prototype.sparseToDense = function (t, e, n, r) {
      const o = Gt(0, t, n); const i = o.sliceRank; const a = o.numUpdates; const s = o.strides; const u = o.outputSize; const c = new so(a, i, t.rank, e.rank, s, [u, 1], !1);

      return this.compileAndRun(c, [e, t, r]).reshape(n);
    }, t.prototype.fft = function (t) {
      const e = this.texData.get(t.dataId); const n = new Cn(Sn, t.shape); const r = new Cn(_n, t.shape); const o = [this.makeComplexComponentTensorHandle(t, e.complexTensors.real), this.makeComplexComponentTensorHandle(t, e.complexTensors.imag)]; const i = this.compileAndRun(n, o); const a = this.compileAndRun(r, o); const s = this.complex(i, a).as2D(t.shape[0], t.shape[1]);

      return i.dispose(), a.dispose(), s;
    }, t.prototype.gatherND = function (t, e) {
      const n = e.shape; const r = n[n.length - 1]; const o = Wt(t, e); const i = o[0]; const a = o[1]; const s = o[2]; const u = o[3]; const c = e.reshape([a, r]); const l = t.reshape([t.size / s, s]); const h = new An(r, u, [a, s]);

      return this.compileAndRun(h, [l, c]).reshape(i);
    }, t.prototype.makeOutputArray = function (t, e) { return Y.make(t, {}, e); }, t.prototype.makePackedTensor = function (t) {
      const e = Y.make(t, {});

      return this.texData.get(e.dataId).isPacked = !0, e;
    }, t.prototype.unpackTensor = function (t) {
      const e = new Eo(t.shape);

      return this.compileAndRun(e, [t]);
    }, t.prototype.compileAndRun = function (o, t, e, n, r) {
      const i = this;

      if (void 0 === r && (r = !0), e == null && (e = this.makeOutputArray(o.outputShape, t[0].dtype)), e.size === 0) return this.texData.get(e.dataId).values = b(e.dtype, 0), e; const a = t.map((t) => {
        if (t.dtype === 'complex64') throw new Error('GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.'); let e = i.texData.get(t.dataId);

        if (e.texture == null && (e.isPacked || !o.usesPackedTextures) && B(t.shape) <= mt.get('WEBGL_SIZE_UPLOAD_UNIFORM')) {
          return {
            shape: t.shape, texData: null, isUniform: !0, uniformValues: i.readSync(t.dataId)
          };
        } if (e.isPacked !== !!o.usesPackedTextures) {
          let n = void 0; let r = void 0;

          e.isPacked ? (n = new Eo(t.shape), r = i.compileAndRun(n, [t])) : (n = new Jr(t.shape), r = i.compileAndRun(n, [t], i.makePackedTensor(t.shape))), e = i.texData.get(r.dataId), t = r;
        }

        return i.uploadToGPU(t.dataId), {shape: t.shape, texData: e, isUniform: !1};
      });

      this.uploadToGPU(e.dataId); let s; const u = {shape: e.shape, texData: this.texData.get(e.dataId), isUniform: !1}; const c = (function (t, e, n) {
        let r = '';

        e.concat(n).forEach((t) => { r += `${t.shape}_${t.isUniform ? 'uniform' : t.texData.texShape}`; }); const o = t.userCode; const i = (!0 === t.supportsBroadcasting).toString();

        return `${t.constructor.name}_${i}_${r}_${o}`;
      }(o, a, u)); const l = this.getAndSaveBinary(c, () => (function (t, r, e, n) {
        for (var o = r.userCode, i = e.map((t, e) => {
 let n = {
            logicalShape: t.shape, texShape: t.isUniform ? null : t.texData.texShape, isUniform: t.isUniform, isPacked: !t.isUniform && t.texData.isPacked
          };

 return {name: r.variableNames[e], shapeInfo: n}; 
}), a = i.map((t) => t.shapeInfo), s = {
            logicalShape: n.shape, texShape: n.texData.texShape, isUniform: !1, isPacked: n.texData.isPacked
          }, u = ln(i, s, o, !0 === r.supportsBroadcasting), c = t.createProgram(u), l = {}, h = 0; h < r.variableNames.length; h++) {
 const p = r.variableNames[h];

          l[p] = t.getUniformLocation(c, p, !1); 
}

        return {
          program: r, source: u, webGLProgram: c, uniformLocations: l, gpgpu: t, inShapeInfos: a, outShapeInfo: s
        };
      }(i.gpgpu, o, a, u))); const h = this.activeTimers != null;

      if (h && (s = this.startTimer()), (function (a, t, e, n) {
        Ur(a.inShapeInfos, t), Ur([a.outShapeInfo], [e]); const r = e.texData.texture; const o = e.texData.texShape; const s = a.gpgpu;

        e.texData.isPacked ? s.setOutputPackedMatrixTexture(r, o[0], o[1]) : s.setOutputMatrixTexture(r, o[0], o[1]), s.setProgram(a.webGLProgram), t.forEach((t, e) => {
          const n = a.program.variableNames[e]; const r = a.uniformLocations[n];

          if (r != null) {
            if (t.isUniform) {
              if (B(t.shape) === 1)s.gl.uniform1f(r, t.uniformValues[0]); else {
                let o = t.uniformValues;

                o instanceof Float32Array || (o = new Float32Array(o)), s.gl.uniform1fv(r, o);
              }

              return;
            } const i = t.texData.texture;

            s.setInputMatrixTexture(i, r, e);
          }
        }), n != null && n(s, a.webGLProgram), s.executeProgram();
      }(l, a, u, n)), mt.get('WEBGL_PAGING_ENABLED') && r && this.numBytesInGPU > this.NUM_BYTES_BEFORE_PAGING) {
        for (let p = this.numBytesInGPU - this.NUM_BYTES_BEFORE_PAGING; p > 0 && this.lruDataGPU.length > 0;) {
          const f = this.lruDataGPU.shift(); const d = this.texData.get(f); const m = d.shape; const v = d.dtype;

          p -= this.computeBytes(m, v), this.read(f);
        }
      }

      return h && (s = this.endTimer(s), this.activeTimers.push({name: o.constructor.name, query: this.getQueryTime(s)})), e;
    }, t.prototype.getAndSaveBinary = function (t, e) { return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t]; }, t.prototype.getTextureManager = function () { return this.textureManager; }, t.prototype.dispose = function () { if (!this.disposed) { for (const t in this.binaryCache) this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram); this.textureManager.dispose(), this.canvas.remove(), this.fromPixelsCanvas != null && this.fromPixelsCanvas.remove(), this.gpgpuCreatedLocally && this.gpgpu.dispose(), this.disposed = !0; } }, t.prototype.floatPrecision = function () {
      const t = this;

      return bt(() => (t.abs(ne(1e-8)).get() > 0 ? 32 : 16));
    }, t.prototype.uploadToGPU = function (t) {
      const e = this.texData.get(t); const n = e.shape; const r = e.values; const o = e.texture; const i = e.dtype; const a = e.usage; const s = e.isPacked;

      if (o == null) {
        let u; const c = this.activeTimers != null;

        c && (u = performance.now()); const l = mr(n, s);

        e.texShape = l; const h = this.acquireTexture(t, l, a, s);

        if (e.texture = h, r != null) {
          if (s) {
            const p = B(n.slice(0, n.length - 2)); const f = n.length > 1 ? n[n.length - 2] : 1; const d = n[n.length - 1];

            this.gpgpu.uploadMatrixToPackedTexture(h, p, f, d, mi(r, i));
          }
          else this.gpgpu.uploadMatrixToTexture(h, l[0], l[1], mi(r, i)); e.values = null, c && (this.uploadWaitMs += performance.now() - u);
        }
      }
      else mt.get('WEBGL_PAGING_ENABLED') && this.lruDataGPU.indexOf(t) >= 0 && (this.lruDataGPU.splice(this.lruDataGPU.indexOf(t), 1), this.lruDataGPU.push(t));
    }, t.prototype.cacheOnCPU = function (t, e) {
      const n = this.delayedStorage; const r = this.texData.get(t); const o = r.texture; const i = r.texShape; const a = r.dtype; const s = r.usage; const u = r.isPacked;

      n && o != null && (this.releaseTexture(t, o, i, s, u), r.texture = null, r.texShape = null), r.usage = kn.UPLOAD, e != null && (r.values = (function (t, e) {
        if (e === 'float32' || e === 'complex64') return t; if (e !== 'int32' && e !== 'bool') throw new Error(`Unknown dtype ${e}`); for (var n = e === 'int32' ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r)n[r] = Math.round(t[r]);

        return n;
      }(e, a)));
    }, t.prototype.releaseTexture = function (t, e, n, r, o) {
      const i = this.texData.get(t); const a = i.shape; const s = i.dtype;

      if (mt.get('WEBGL_PAGING_ENABLED')) {
        const u = this.lruDataGPU.indexOf(t);

        u >= 0 && this.lruDataGPU.splice(u, 1);
      } this.numBytesInGPU -= this.computeBytes(a, s), this.textureManager.releaseTexture(e, n, r, o);
    }, t.prototype.acquireTexture = function (t, e, n, r) {
      const o = this.texData.get(t); const i = o.shape; const a = o.dtype;

      return mt.get('WEBGL_PAGING_ENABLED') && this.lruDataGPU.push(t), this.numBytesInGPU += this.computeBytes(i, a), this.textureManager.acquireTexture(e, n, r);
    }, t.prototype.computeBytes = function (t, e) { return B(t) * R(e); }, t;
  }());

  function mi(t, e) { return t instanceof Float32Array ? t : new Float32Array(t); }mt.get('IS_BROWSER') && mt.registerBackend('webgl', () => new di(), 2, X); const vi = Yt({
    abs_(t) {
      const e = Kt(t, 'x', 'abs');

      return mt.engine.runKernel((t) => t.abs(e), {$x: e}, (t) => ({$x() { return t.mulStrict(e.toFloat().step(-1)); }}));
    }
  }); const gi = Yt({
    acos_(t) {
      const e = Kt(t, 'x', 'acos');

      return mt.engine.runKernel((t) => t.acos(e), {$x: e}, (t) => ({$x() { return t.divStrict(ne(1).sub(e.toFloat().square()).sqrt()).neg(); }}));
    }
  }); const yi = Yt({
    acosh_(t) {
      const e = Kt(t, 'x', 'acosh');

      return mt.engine.runKernel((t) => t.acosh(e), {$x: e}, (t) => ({$x() { return t.divStrict(e.toFloat().square().sub(ne(1)).sqrt()); }}));
    }
  }); const xi = Yt({
    asin_(t) {
      const e = Kt(t, 'x', 'asin');

      return mt.engine.runKernel((t) => t.asin(e), {$x: e}, (t) => ({$x() { return t.divStrict(ne(1).sub(e.toFloat().square()).sqrt()); }}));
    }
  }); const bi = Yt({
    asinh_(t) {
      const e = Kt(t, 'x', 'asinh');

      return mt.engine.runKernel((t) => t.asinh(e), {$x: e}, (t) => ({$x() { return t.divStrict(ne(1).add(e.toFloat().square()).sqrt()); }}));
    }
  }); const wi = Yt({
    atan_(t) {
      const e = Kt(t, 'x', 'atan');

      return mt.engine.runKernel((t) => t.atan(e), {$x: e}, (t) => ({$x() { return t.divStrict(ne(1).add(e.toFloat().square())); }}));
    }
  }); const Ei = Yt({
    atanh_(t) {
      const e = Kt(t, 'x', 'atanh');

      return mt.engine.runKernel((t) => t.atanh(e), {$x: e}, (t) => ({$x() { return t.divStrict(ne(1).sub(e.toFloat().square())); }}));
    }
  }); const Si = Yt({
    ceil_(t) {
      const e = Kt(t, 'x', 'ceil');

      return mt.engine.runKernel((t) => t.ceil(e), {$x: e}, (t) => ({$x() { return Te(t); }}));
    }
  }); const _i = Yt({
    clipByValue_(t, e, n) {
      const r = Kt(t, 'x', 'clipByValue');

      return D(e <= n, `Error in clip: min (${e}) must be less than or equal to max (${n}).`), mt.engine.runKernel((t) => t.clip(r, e, n), {$x: r}, (t) => ({$x() { return t.where(r.greaterEqual(ne(e)).logicalAnd(r.lessEqual(ne(n))), Te(t)); }}));
    }
  }); const Ci = Yt({
    cos_(t) {
      const e = Kt(t, 'x', 'cos');

      return mt.engine.runKernel((t) => t.cos(e), {$x: e}, (t) => ({$x() { return e.toFloat().sin().neg().mulStrict(t); }}));
    }
  }); const Ri = Yt({
    cosh_(t) {
      const e = Kt(t, 'x', 'cosh');

      return mt.engine.runKernel((t) => t.cosh(e), {$x: e}, (t) => ({$x() { return e.toFloat().sinh().mulStrict(t); }}));
    }
  }); const Ti = Yt({
    erf_(t) {
      let e = Kt(t, 'x', 'erf');

      return D(e.dtype === 'int32' || e.dtype === 'float32', 'Input dtype must be `int32` or `float32`.'), e.dtype === 'int32' && (e = e.toFloat()), mt.engine.runKernel((t) => t.erf(e), {$x: e}, (t) => ({$x() { return t.mulStrict(ne(2 / Math.sqrt(Math.PI)).mul(e.square().neg().exp())); }}));
    }
  }); const ki = Yt({
    exp_(t) {
      const n = Kt(t, 'x', 'exp');

      return mt.engine.runKernel((t, e) => e(t.exp(n)), {$x: n}, (t, e) => {
        const n = e[0];

        return {$x() { return t.mulStrict(n); }};
      });
    }
  }); const Ii = Yt({
    expm1_(t) {
      const e = Kt(t, 'x', 'expm1');

      return mt.engine.runKernel((t) => t.expm1(e), {$x: e}, (t) => ({$x() { return t.mulStrict(e.exp()); }}));
    }
  }); const Di = Yt({
    floor_(t) {
      const e = Kt(t, 'x', 'floor');

      return mt.engine.runKernel((t) => t.floor(e), {$x: e}, (t) => ({$x() { return Te(t); }}));
    }
  }); const Ni = Yt({
    log_(t) {
      const e = Kt(t, 'x', 'log');

      return mt.engine.runKernel((t) => t.log(e), {$x: e}, (t) => ({$x() { return t.divStrict(e.toFloat()); }}));
    }
  }); const Ai = Yt({
    log1p_(t) {
      const e = Kt(t, 'x', 'log1p');

      return mt.engine.runKernel((t) => t.log1p(e), {$x: e}, (t) => ({$x() { return t.divStrict(e.add(ne(1))); }}));
    }
  }); const Mi = Yt({
    logSigmoid_(t) {
      const e = Kt(t, 'x', 'logSigmoid');

      return mt.engine.runKernel((t) => t.softplus(e.neg()).neg(), {$x: e}, (t) => ({$x() { return t.mulStrict(e.neg().sigmoid()); }}));
    }
  }); const Oi = Yt({
    neg_(t) {
      const e = Kt(t, 'x', 'neg');

      return mt.engine.runKernel((t) => t.neg(e), {$x: e}, (t) => ({$x() { return t.neg(); }}));
    }
  }); const Pi = Yt({
    reciprocal_(t) {
      const e = Kt(t, 'x', 'reciprocal');

      return mt.engine.runKernel((t) => t.reciprocal(e), {$x: e}, (t) => ({$x() { return t.divStrict(e.square().neg()); }}));
    }
  }); const Fi = Yt({
    round_(t) {
      const e = Kt(t, 'x', 'round');

      return mt.engine.runKernel((t) => t.round(e), {$x: e}, (t) => ({$x() { return Te(t); }}));
    }
  }); const Li = Yt({
    rsqrt_(t) {
      const e = Kt(t, 'x', 'rsqrt');

      return mt.engine.runKernel((t) => t.rsqrt(e), {$x: e}, (t) => ({$x() { return t.divStrict(e.pow(ne(1.5)).mul(ne(2))).neg(); }}));
    }
  }); const Bi = Yt({
    sigmoid_(t) {
      const n = Kt(t, 'x', 'sigmoid');

      return mt.engine.runKernel((t, e) => e(t.sigmoid(n)), {$x: n}, (t, e) => {
        const n = e[0];

        return {$x() { return t.mulStrict(n.mul(ne(1).sub(n))); }};
      });
    }
  }); const zi = Yt({
    sign_(t) {
      const e = Kt(t, 'x', 'sign');

      return mt.engine.runKernel((t) => t.sign(e), {$x: e}, (t) => ({$x() { return Te(t); }}));
    }
  }); const Wi = Yt({
    sin_(t) {
      const e = Kt(t, 'x', 'sin');

      return mt.engine.runKernel((t) => t.sin(e), {$x: e}, (t) => ({$x() { return e.toFloat().cos().mulStrict(t); }}));
    }
  }); const Ui = Yt({
    sinh_(t) {
      const e = Kt(t, 'x', 'sinh');

      return mt.engine.runKernel((t) => t.sinh(e), {$x: e}, (t) => ({$x() { return e.toFloat().cosh().mulStrict(t); }}));
    }
  }); const Vi = Yt({
    softplus_(t) {
      const e = Kt(t, 'x', 'softplus');

      return mt.engine.runKernel((t) => t.softplus(e), {$x: e}, (t) => ({$x() { return t.mulStrict(e.sigmoid()); }}));
    }
  }); const Gi = Yt({
    sqrt_(t) {
      const e = Kt(t, 'x', 'sqrt');

      return mt.engine.runKernel((t) => t.sqrt(e), {$x: e}, (t) => ({$x() { return t.divStrict(e.toFloat().sqrt().mul(ne(2))); }}));
    }
  }); const qi = Yt({
    square_(t) {
      const e = Kt(t, 'x', 'square');

      return mt.engine.runKernel((t) => t.square(e), {$x: e}, (t) => ({$x() { return t.mulStrict(e.toFloat().mul(ne(2))); }}));
    }
  }); const ji = Yt({
    step_(t, e) {
      void 0 === e && (e = 0); const n = Kt(t, 'x', 'step');

      return mt.engine.runKernel((t) => t.step(n, e), {$x: n}, (t) => ({$x() { return Te(t); }}));
    }
  }); const Hi = Yt({
    tan_(t) {
      const e = Kt(t, 'x', 'tan');

      return mt.engine.runKernel((t) => t.tan(e), {$x: e}, (t) => ({$x() { return t.divStrict(e.cos().square()); }}));
    }
  }); const $i = Yt({
    tanh_(t) {
      const n = Kt(t, 'x', 'tanh');

      return mt.engine.runKernel((t, e) => e(t.tanh(n)), {$x: n}, (t, e) => {
        const n = e[0];

        return {$x() { return ne(1).sub(n.square()).mulStrict(t); }};
      });
    }
  });

  function Ki(t) { return t == null ? null : t.rank === 0 ? t.as1D() : t.rank === 1 ? t : t.rank === 2 ? t.as4D(1, 1, t.shape[0], t.shape[1]) : t.rank === 3 ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t; } const Xi = Yt({
    batchNormalization2d_(t, e, n, r, o, i) {
      void 0 === r && (r = 0.001); let a; let s; const u = Kt(t, 'x', 'batchNormalization'); const c = Kt(e, 'mean', 'batchNormalization'); const l = Kt(n, 'variance', 'batchNormalization');

      return o != null && (a = Kt(o, 'scale', 'batchNormalization')), i != null && (s = Kt(i, 'offset', 'batchNormalization')), D(u.rank === 2, `Error in batchNormalization3D: x must be rank 3 but got rank ${u.rank}.`), D(c.rank === 2 || c.rank === 1, `Error in batchNormalization2D: mean must be rank 2 or rank 1 but got rank ${c.rank}.`), D(l.rank === 2 || l.rank === 1, `Error in batchNormalization2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`), a != null && D(a.rank === 2 || a.rank === 1, `Error in batchNormalization2D: scale must be rank 2 or rank 1 but got rank ${a.rank}.`), s != null && D(s.rank === 2 || s.rank === 1, `Error in batchNormalization2D: offset must be rank 2 or rank 1 but got rank ${s.rank}.`), Ji(u, c, l, r, a, s);
    }
  }); const Yi = Yt({
    batchNormalization3d_(t, e, n, r, o, i) {
      void 0 === r && (r = 0.001); let a; let s; const u = Kt(t, 'x', 'batchNormalization'); const c = Kt(e, 'mean', 'batchNormalization'); const l = Kt(n, 'variance', 'batchNormalization');

      return o != null && (a = Kt(o, 'scale', 'batchNormalization')), i != null && (s = Kt(i, 'offset', 'batchNormalization')), D(u.rank === 3, `Error in batchNormalization3D: x must be rank 3 but got rank ${u.rank}.`), D(c.rank === 3 || c.rank === 1, `Error in batchNormalization3D: mean must be rank 3 or rank 1 but got rank ${c.rank}.`), D(l.rank === 3 || l.rank === 1, `Error in batchNormalization3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`), a != null && D(a.rank === 3 || a.rank === 1, `Error in batchNormalization3D: scale must be rank 3 or rank 1 but got rank ${a.rank}.`), s != null && D(s.rank === 3 || s.rank === 1, `Error in batchNormalization3D: offset must be rank 3 or rank 1 but got rank ${s.rank}.`), Ji(u, c, l, r, a, s);
    }
  }); const Qi = Yt({
    batchNormalization4d_(t, e, n, r, o, i) {
      void 0 === r && (r = 0.001); let a; let s; const u = Kt(t, 'x', 'batchNormalization'); const c = Kt(e, 'mean', 'batchNormalization'); const l = Kt(n, 'variance', 'batchNormalization');

      return o != null && (a = Kt(o, 'scale', 'batchNormalization')), i != null && (s = Kt(i, 'offset', 'batchNormalization')), D(u.rank === 4, `Error in batchNormalization4D: x must be rank 4 but got rank ${u.rank}.`), D(c.rank === 4 || c.rank === 1, `Error in batchNormalization4D: mean must be rank 4 or rank 1 but got rank ${c.rank}.`), D(l.rank === 4 || l.rank === 1, `Error in batchNormalization4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`), a != null && D(a.rank === 4 || a.rank === 1, `Error in batchNormalization4D: scale must be rank 4 or rank 1 but got rank ${a.rank}.`), s != null && D(s.rank === 4 || s.rank === 1, `Error in batchNormalization4D: offset must be rank 4 or rank 1 but got rank ${s.rank}.`), Ji(u, c, l, r, a, s);
    }
  }); var Ji = Yt({
    batchNormalization_(t, e, n, c, r, o) {
      void 0 === c && (c = 0.001); let l; let i; let h; const p = Kt(t, 'x', 'batchNormalization'); const f = Kt(e, 'mean', 'batchNormalization'); const d = Kt(n, 'variance', 'batchNormalization');

      return r != null && (l = Kt(r, 'scale', 'batchNormalization')), o != null && (i = Kt(o, 'offset', 'batchNormalization')), D(f.rank === d.rank, 'Batch normalization gradient requires mean and variance to have equal ranks.'), D(i == null || f.rank === i.rank, 'Batch normalization gradient requires mean and offset to have equal ranks.'), D(l == null || f.rank === l.rank, 'Batch normalization gradient requires mean and scale to have equal ranks.'), h = p.rank === 0 || p.rank === 1 ? p.as4D(1, 1, 1, p.size) : p.rank === 2 ? p.as4D(1, 1, p.shape[0], p.shape[1]) : p.rank === 3 ? p.as4D(1, p.shape[0], p.shape[1], p.shape[2]) : p, mt.engine.runKernel((t) => t.batchNormalization(h, Ki(f), Ki(d), c, Ki(l), Ki(i)), {
        $x: p, $mean: f, $variance: d, $scale: l, $offset: i
      }, (n) => {
        const t = l == null ? ne(1) : l; const r = Ve(f.shape, h.shape); const e = [];

        if (f.rank === 1) { for (let o = 0; o < h.shape.length - 1; ++o)e.push(h.shape[o]); e.push(1); } const i = p.sub(f); const a = n.mul(t); const s = Li(d.add(ne(c))); const u = s.mul(s).mul(s).mul(ne(-0.5));

        return {
          $x() { return f.rank === 1 ? n.mul(li(s.as4D(1, 1, 1, f.shape[0]), e)).mul(t).reshape(p.shape) : n.mul(s).mul(t).reshape(p.shape); },
          $mean() {
            let t = s.mul(ne(-1)).mul(a);

            return f.rank === 1 && (t = t.sum(r)), t.reshape(f.shape);
          },
          $variance() {
            let t = u.mul(i).mul(a);

            return f.rank === 1 && (t = t.sum(r)), t.reshape(f.shape);
          },
          $scale() {
            const t = i.mul(s); let e = n.mul(t);

            return f.rank === 1 && (e = e.sum(r)), e.reshape(f.shape);
          },
          $offset() {
            let t = n;

            return f.rank === 1 && (t = t.sum(r)), t.reshape(f.shape);
          }
        };
      }).reshape(p.shape);
    }
  });

  function Zi(t, e, n, r, o, i, a) {
    void 0 === a && (a = 'channelsLast'); let s; const u = ea(e); const c = u[0]; const l = u[1];

    if (a === 'channelsLast')s = [c, l, t[3], t[3]]; else { if (a !== 'channelsFirst') throw new Error(`Unknown dataFormat ${a}`); s = [c, l, t[1], t[1]]; }

    return ta(t, s, n, r, o, i, !1, a);
  } function ta(t, e, n, r, o, i, a, s) {
    void 0 === a && (a = !1), void 0 === s && (s = 'channelsLast'); const u = [-1, -1, -1, -1]; let c = u[0]; let l = u[1]; let h = u[2]; let p = u[3];

    if (s === 'channelsLast')c = t[0], l = t[1], h = t[2], p = t[3]; else { if (s !== 'channelsFirst') throw new Error(`Unknown dataFormat ${s}`); c = t[0], p = t[1], l = t[2], h = t[3]; } let f; const d = e[0]; const m = e[1]; const v = e[3]; const g = ea(n); const y = g[0]; const x = g[1]; const b = ea(r); const w = b[0]; const E = b[1]; const S = na(d, w); const _ = na(m, E); const C = (function (t, e, n, r, o, i, a, s) {
      let u, c, l;

      if (typeof t === 'number') {
        u = {
          top: t, bottom: t, left: t, right: t, type: t === 0 ? 'VALID' : 'NUMBER'
        }; const h = (function (t, e, n, r, o, i) {
          o == null && (o = (function (t, e, n, r) {
            void 0 === r && (r = 1); const o = na(e, r);

            return Math.floor((t[0] * (n - 1) - n + o) / 2);
          }(t, e, r))); const a = t[0]; const s = t[1]; const u = ra((a - e + 2 * o) / r + 1, i);

          D(N(u), `The output # of rows (${u}) must be an integer. Change the stride and/or zero pad parameters`); const c = ra((s - e + 2 * o) / r + 1, i);

          return D(N(c), `The output # of columns (${c}) must be an integer. Change the stride and/or zero pad parameters`), [u, c, n];
        }([e, n, 1], i, 1, r, t, s));

        c = h[0], l = h[1];
      }
      else if (t === 'same') {
        const p = ((c = Math.ceil(e / r)) - 1) * r + i - e; const f = ((l = Math.ceil(n / o)) - 1) * o + a - n; const d = Math.floor(p / 2); const m = p - d; const v = Math.floor(f / 2);

        u = {
          top: d, bottom: m, left: v, right: f - v, type: 'SAME'
        };
      }
      else {
        if (t !== 'valid') throw Error(`Unknown padding parameter: ${t}`); u = {
          top: 0, bottom: 0, left: 0, right: 0, type: 'VALID'
        }, c = Math.ceil((e - i + 1) / r), l = Math.ceil((n - a + 1) / o);
      }

      return {padInfo: u, outHeight: c, outWidth: l};
    }(o, l, h, y, x, S, _, i)); const R = C.padInfo; const T = C.outHeight; const k = C.outWidth; const I = a ? v * p : v;

    return s === 'channelsFirst' ? f = [c, I, T, k] : s === 'channelsLast' && (f = [c, T, k, I]), {
      batchSize: c, dataFormat: s, inHeight: l, inWidth: h, inChannels: p, outHeight: T, outWidth: k, outChannels: I, padInfo: R, strideHeight: y, strideWidth: x, filterHeight: d, filterWidth: m, effectiveFilterHeight: S, effectiveFilterWidth: _, dilationHeight: w, dilationWidth: E, inShape: t, outShape: f, filterShape: e
    };
  } function ea(t) { return typeof t === 'number' ? [t, t] : t; } function na(t, e) { return e <= 1 ? t : t + (t - 1) * (e - 1); } function ra(t, e) { if (!e) return t; switch (e) { case 'round': return Math.round(t); case 'ceil': return Math.ceil(t); case 'floor': return Math.floor(t); default: throw new Error(`Unknown roundingMode ${e}`); } } function oa(t) {
    const e = ea(t); const n = e[0]; const r = e[1];

    return n === 1 && r === 1;
  } function ia(t, e) { return oa(t) || oa(e); } const aa = Yt({
    matMul_(t, e, n, r) {
      void 0 === n && (n = !1), void 0 === r && (r = !1); const o = Kt(t, 'a', 'matMul'); const i = Kt(e, 'b', 'matMul'); const a = n ? o.shape[o.rank - 2] : o.shape[o.rank - 1]; const s = r ? i.shape[i.rank - 1] : i.shape[i.rank - 2]; const u = n ? o.shape[o.rank - 1] : o.shape[o.rank - 2]; const c = r ? i.shape[i.rank - 2] : i.shape[i.rank - 1]; const l = o.shape.slice(0, -2); const h = i.shape.slice(0, -2); const p = B(l); const f = B(h);

      D(o.rank >= 2 && i.rank >= 2 && o.rank === i.rank, `Error in matMul: inputs must have the same rank of at least 2, got ranks ${o.rank} and ${i.rank}.`), D(T(l, h), `Error in matMul: outer dimensions (${l}) and (${h}) of Tensors with shapes ${o.shape} and ${i.shape} must match.`), D(a === s, `Error in matMul: inner shapes (${a}) and (${s}) of Tensors with shapes ${o.shape} and ${i.shape} and transposeA=${n} and transposeB=${r} must match.`); const d = o.shape.slice(0, -2).concat([u, c]); const m = n ? o.as3D(p, a, u) : o.as3D(p, u, a); const v = r ? i.as3D(f, c, s) : i.as3D(f, s, c);

      return mt.engine.runKernel((t) => t.batchMatMul(m, v, n, r), {$a: m, $b: v}, (t) => (n || r ? !n && r ? {$a() { return t.matMul(v.toFloat(), !1, !1); }, $b() { return t.matMul(m.toFloat(), !0, !1); }} : n && !r ? {$a() { return v.toFloat().matMul(t, !1, !0); }, $b() { return m.toFloat().matMul(t, !1, !1); }} : {$a() { return v.toFloat().matMul(t, !0, !0); }, $b() { return t.matMul(m.toFloat(), !0, !0); }} : {$a() { return t.matMul(v.toFloat(), !1, !0); }, $b() { return m.toFloat().matMul(t, !0, !1); }})).reshape(d);
    }
  }); const sa = Yt({
    dot_(t, e) {
      const n = Kt(t, 't1', 'dot'); const r = Kt(e, 't2', 'dot');

      D(!(n.rank !== 1 && n.rank !== 2 || r.rank !== 1 && r.rank !== 2), `Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`); const o = n.rank === 1 ? n.size : n.shape[1]; const i = r.rank === 1 ? r.size : r.shape[0];

      return D(o === i, `Error in dot: inner dimensions of inputs must match, but got ${o} and ${i}.`), n.rank === 1 && r.rank === 1 ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : n.rank === 1 && r.rank === 2 ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : n.rank === 2 && r.rank === 1 ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]));
    }
  }); const ua = Yt({
    outerProduct_(t, e) {
      const n = Kt(t, 'v1', 'outerProduct'); const r = Kt(e, 'v2', 'outerProduct');

      return D(n.rank === 1 && r.rank === 1, `Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`), n.as2D(-1, 1).matMul(r.as2D(1, -1));
    }
  });

  function ca(t, e, n, r, o, i) {
    D(t.length === e.rank, `Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`); let a = t; let s = e; let u = !1;

    e.rank === 3 && (u = !0, s = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), a = [1, t[0], t[1], t[2]]); const c = a[3]; const l = s.shape[3];

    D(a.length === 4, `Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`), D(s.rank === 4, `Error in conv2dDerInput: dy must be rank 4, but got rank ${s.rank}`), D(n.rank === 4, `Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`), D(c === n.shape[2], `Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`), D(l === n.shape[3], `Error in conv2dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[3]}.`), i != null && D(N(o), `Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`); const h = ta(a, n.shape, r, 1, o, i); const p = mt.engine.runKernel((t) => t.conv2dDerInput(s, n, h), {dy4D: s, filter: n}, (t) => ({dy4D() { return pa(t, n, r, o, 'NHWC', 1, i); }, filter() { return fa(t, s, n.shape, r, o, i); }}));

    return u ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;
  } function la(t, e, n, r, o, i) {
    let a = t;

    t.rank === 3 && (a = t.as4D(1, t.shape[0], t.shape[1], t.shape[2])); let s = e;

    s.rank === 3 && (s = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), D(a.rank === 4, `Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`), D(s.rank === 4, `Error in conv2dDerFilter: dy must be rank 4, but got shape ${s.shape}.`), D(n.length === 4, `Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`), D(a.shape[3] === n[2], `Error in conv2dDerFilter: depth of input ${a.shape[3]}) must match input depth in filter (${n[2]}.`), D(s.shape[3] === n[3], `Error in conv2dDerFilter: depth of dy (${s.shape[3]}) must match output depth for filter (${n[3]}).`), i != null && D(N(o), `Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`); const u = ta(a.shape, n, r, 1, o, i);

    return mt.engine.runKernel((t) => t.conv2dDerFilter(a, s, u), {x4D: a, dy4D: s});
  } const ha = Yt({
    conv1d_(t, e, n, r, o, i, a) {
      void 0 === o && (o = 'NWC'), void 0 === i && (i = 1); const s = Kt(t, 'x', 'conv1d'); const u = Kt(e, 'filter', 'conv1d'); let c = s; let l = !1;

      s.rank === 2 && (l = !0, c = s.as3D(1, s.shape[0], s.shape[1])), D(c.rank === 3, `Error in conv1d: input must be rank 3, but got rank ${c.rank}.`), D(u.rank === 3, `Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`), a != null && D(N(r), `Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`), D(c.shape[2] === u.shape[1], `Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`), D(ia(n, i), `Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`), D(o === 'NWC', `Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`); const h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]); const p = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]); const f = pa(p, h, [1, n], r, 'NHWC', [1, i], a);

      return l ? f.as2D(f.shape[2], f.shape[3]) : f.as3D(f.shape[0], f.shape[2], f.shape[3]);
    }
  }); var pa = Yt({
    conv2d_(t, e, n, r, o, i, a) {
      void 0 === o && (o = 'NHWC'), void 0 === i && (i = [1, 1]); const s = Kt(t, 'x', 'conv2d'); const u = Kt(e, 'filter', 'conv2d'); let c = s; let l = !1;

      s.rank === 3 && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), D(c.rank === 4, `Error in conv2d: input must be rank 4, but got rank ${c.rank}.`), D(u.rank === 4, `Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`), a != null && D(N(r), `Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`), D(c.shape[3] === u.shape[2], `Error in conv2d: depth of input (${c.shape[3]}) must match input depth for filter ${u.shape[2]}.`), D(ia(n, i), `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`), D(o === 'NHWC', `Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`); let h; const p = ta(c.shape, u.shape, n, i, r, a);

      if (p.filterHeight !== 1 || p.filterWidth !== 1 || p.dilationHeight !== 1 || p.dilationWidth !== 1 || p.strideHeight !== 1 || p.strideWidth !== 1 || p.padInfo.type !== 'SAME' && p.padInfo.type !== 'VALID')h = mt.engine.runKernel((t) => t.conv2d(c, u, p), {x: c, $filter: u}, (t) => D(oa(i), `Error in gradient of conv2D: dilation rates greater than 1 are notyet supported in gradients. Got dilations '${i}'`), {x() { return ca(c.shape, t, u, n, r); }, $filter() { return la(c, t, u.shape, n, r); }}); else {
        const f = c.reshape([-1, p.inChannels]); const d = u.reshape([p.inChannels, p.outChannels]);

        h = aa(f, d).reshape(p.outShape);
      }

      return l ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h;
    }
  }); var fa = Yt({conv2dDerFilter_: la}); const da = Yt({
    depthwiseConv2d_(t, e, n, r, o, i, a) {
      void 0 === o && (o = 'NHWC'), void 0 === i && (i = [1, 1]); const s = Kt(t, 'x', 'depthwiseConv2d'); const u = Kt(e, 'filter', 'depthwiseConv2d'); let c = s; let l = !1;

      s.rank === 3 && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), D(c.rank === 4, `Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`), D(u.rank === 4, `Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`), D(c.shape[3] === u.shape[2], `Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`), i == null && (i = [1, 1]), D(ia(n, i), `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`), a != null && D(N(r), `Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`); const h = ta(c.shape, u.shape, n, i, r, a, !0); const p = mt.engine.runKernel((t) => t.depthwiseConv2D(c, u, h), {x: c, $filter: u}, (t) => D(oa(i), `Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`), {
x() { return (function (t, e, n, r) { let o = e; let i = !1;

 e.rank === 3 && (i = !0, o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])); let a = mt.engine.runKernel((t) => t.depthwiseConv2DDerInput(o,n,r), {dy4D: o});

 return i ? a.as3D(a.shape[1], a.shape[2], a.shape[3]) : a; }(c.shape, t, u, h)); },
$filter() {
 return (function (t, e, n, r) {
 let o = t;

        3 === t.rank && (o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2])); let i = e;

 return i.rank === 3 && (i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), mt.engine.runKernel((t) => t.depthwiseConv2DDerFilter(o,i,r), {x4D: o, dy4D: i}); 
}(c, t, u.shape, h)); 
}
});

      return l ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;
    }
  }); const ma = Yt({
    separableConv2d_(t, e, n, r, o, i, a) {
      void 0 === i && (i = [1, 1]), void 0 === a && (a = 'NHWC'); const s = Kt(t, 'x', 'separableConv2d'); const u = Kt(e, 'depthwiseFilter', 'separableConv2d'); const c = Kt(n, 'pointwiseFilter', 'separableConv2d'); let l = s; let h = !1;

      if (s.rank === 3 && (h = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), a === 'NCHW') throw new Error('separableConv2d currently does not support dataFormat NCHW; only NHWC is supported'); D(l.rank === 4, `Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`), D(u.rank === 4, `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`), D(c.rank === 4, `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`), D(c.shape[0] === 1, `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`), D(c.shape[1] === 1, `Error in separableConv2d: the second dimension of pointwise filter  must be 1, but got ${c.shape[1]}.`); const p = u.shape[2]; const f = u.shape[3];

      D(c.shape[2] === p * f, `Error in separableConv2d: the third dimension of pointwise filter must be ${p * f}, but got ${c.shape[2]}.`); const d = da(l, u, r, o, a, i); const m = pa(d, c, 1, 'valid', a);

      return h ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m;
    }
  }); const va = Yt({conv2dTranspose_(t, e, n, r, o, i) { return ca(n, Kt(t, 'x', 'conv2dTranspose'), Kt(e, 'filter', 'conv2dTranspose'), r, o, i); }}); const ga = Yt({
    reverse_(t, e) {
      const n = Kt(t, 'x', 'reverse');

      if (n.rank === 0) return n.clone(); const r = Ot(e, n.shape);

      return mt.engine.runKernel((t) => t.reverse(n, r), {$x: n}, (t) => ({$x() { return t.reverse(r); }})).reshapeAs(n);
    }
  }); const ya = Yt({
    reverse1d_(t) {
      const e = Kt(t, 'x', 'reverse');

      return D(e.rank === 1, `Error in reverse1D: x must be rank 1 but got\n             rank ${e.rank}.`), ga(e, 0);
    }
  }); const xa = Yt({
    reverse2d_(t, e) {
      const n = Kt(t, 'x', 'reverse');

      return D(n.rank === 2, `Error in reverse2D: x must be rank 2 but got\n             rank ${n.rank}.`), ga(n, e);
    }
  }); const ba = Yt({
    reverse3d_(t, e) {
      const n = Kt(t, 'x', 'reverse');

      return D(n.rank === 3, `Error in reverse3D: x must be rank 3 but got\n             rank ${n.rank}.`), ga(n, e);
    }
  }); const wa = Yt({
    reverse4d_(t, e) {
      const n = Kt(t, 'x', 'reverse');

      return D(n.rank === 4, `Error in reverse4D: x must be rank 4 but got\n             rank ${n.rank}.`), ga(n, e);
    }
  });

  function Ea(t, r, o, i, a, e) {
    const n = Kt(t, 'x', 'maxPool'); let s = n; let u = !1;

    n.rank === 3 && (u = !0, s = n.as4D(1, n.shape[0], n.shape[1], n.shape[2])), i == null && (i = [1, 1]), D(s.rank === 4, `Error in maxPool: input must be rank 4 but got rank ${s.rank}.`), D(ia(o, i), `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${i}'`), e != null && D(N(a), `Error in maxPool: pad must be an integer when using, dimRoundingMode ${e} but got pad ${a}.`); const c = Zi(s.shape, r, o, i, a, e); const l = mt.engine.runKernel((t, e) => e(t.maxPool(s, c)), {x: s}, (t, e) => {
      const n = e[0];

      return {
        x() {
          return (function (t, e, n, r, o, i, a, s) {
            const u = Kt(t, 'dy', 'maxPoolBackprop'); const c = Kt(e, 'input', 'maxPoolBackprop'); const l = Kt(n, 'output', 'maxPoolBackprop');

            D(c.rank === u.rank, `Rank of input (${c.rank}) does not match rank of dy (${u.rank})`), i == null && (i = [1, 1]), D(ia(o, i), `Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides ${o} and dilations '${i}'`), D(u.rank === 4, `Error in maxPoolBackprop: dy must be rank 4 but got rank ${u.rank}.`), D(c.rank === 4, `Error in maxPoolBackprop: input must be rank 4 but got rank ${c.rank}.`), s != null && D(N(a), `Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${s} but got pad ${a}.`); const h = Zi(c.shape, r, o, i, a, s);

            return mt.engine.runKernel((t) => t.maxPoolBackprop(u, c, l, h), {$dy: u, $input: c});
          }(t, s, n, r, o, i, a));
        }
      };
    });

    return u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;
  } function Sa(t, e, n, r, o, i) {
    const a = Kt(t, 'x', 'avgPool');

    D(a.dtype === 'float32', 'The input dtype to avgPool must be float32'), r == null && (r = [1, 1]), D(ia(n, r), `Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${r}'`); let s = a; let u = !1;

    a.rank === 3 && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), D(s.rank === 4, `Error in avgPool: x must be rank 4 but got rank ${s.rank}.`), i != null && D(N(o), `Error in avgPool: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`); const c = Zi(s.shape, e, n, r, o); let l = mt.engine.runKernel((t) => t.avgPool(s, c), {x: s}, (t) => ({
      x() {
        return (function (t, e, n, r, o, i) {
          const a = Kt(t, 'dy', 'avgPoolBackprop'); const s = Kt(e, 'input', 'avgPoolBackprop');

          D(s.rank === a.rank, `Rank of input (${s.rank}) does not match rank of dy (${a.rank})`), o == null && (o = [1, 1]), D(ia(r, o), `Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides ${ r} and dilations '${o }'`); let u = s; let c = a; let l = !1;

          s.rank === 3 && (l = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), c = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), D(c.rank === 4, `Error in avgPoolBackprop: dy must be rank 4 but got rank ${c.rank }.`), D(u.rank === 4, `Error in avgPoolBackprop: input must be rank 4 but got rank ${ u.rank }.`); const h = Zi(u.shape, n, r, o, i); const p = mt.engine.runKernel((t) => t.avgPoolBackprop(c, u, h), {dy4D: c, input4D: u});

          return l ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;
        }(t, s, e, n, r, o));
      }
    }));

    return l = l.cast(a.dtype), u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;
  } const _a = Yt({maxPool_(t, e, n, r, o) { return Ea(t, e, n, 1, r, o); }}); const Ca = Yt({avgPool_(t, e, n, r, o) { return Sa(t, e, n, 1, r, o); }}); const Ra = Yt({pool_(t, e, n, r, o, i) { return o == null && (o = 1), i == null && (i = 1), n === 'avg' ? Sa(t, e, i, o, r) : Ea(t, e, i, o, r); }}); const Ta = Yt({
    slice_(t, e, n) {
      let r; let o; const i = Kt(t, 'x', 'slice');

      if (i.rank === 0) throw new Error('Slicing scalar is not possible'); r = typeof e === 'number' ? [e].concat(new Array(i.rank - 1).fill(0)) : e.length < i.rank ? e.concat(new Array(i.rank - e.length).fill(0)) : e.slice(), o = (o = n == null ? new Array(i.rank).fill(-1) : typeof n === 'number' ? [n].concat(new Array(i.rank - 1).fill(-1)) : n.length < i.rank ? n.concat(new Array(i.rank - n.length).fill(-1)) : n).map((t, e) => (t >= 0 ? t : (D(t === -1, 'Bad value in size'), i.shape[e] - r[e]))), (function (t, e, n) { D(t.rank === e.length, `Error in slice${t.rank}D: Length of begin ${e} must match the rank of the array (${t.rank}).`), D(t.rank === n.length, `Error in slice${t.rank}D: Length of size ${n} must match the rank of the array (${t.rank}).`); for (let r = 0; r < t.rank; ++r)D(e[r] + n[r] <= t.shape[r], `Error in slice${t.rank}D: begin[${r}] + size[${r}] (${e[r] + n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`); }(i, r, o)); const a = i.shape;

      return mt.engine.runKernel((t) => t.slice(i, r, o), {$x: i}, (t) => {
        for (var e = [], n = 0; n < t.rank; n++)e.push([r[n], a[n] - r[n] - o[n]]);

        return {$x() { return t.pad(e); }};
      });
    }
  }); const ka = Yt({
    slice1d_(t, e, n) {
      const r = Kt(t, 'x', 'slice1d');

      return D(r.rank === 1, `slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`), Ta(r, [e], [n]);
    }
  }); const Ia = Yt({
    slice2d_(t, e, n) {
      const r = Kt(t, 'x', 'slice2d');

      return D(r.rank === 2, `slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`), Ta(r, e, n);
    }
  }); const Da = Yt({
    slice3d_(t, e, n) {
      const r = Kt(t, 'x', 'slice3d');

      return D(r.rank === 3, `slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`), Ta(r, e, n);
    }
  }); const Na = Yt({
    slice4d_(t, e, n) {
      const r = Kt(t, 'x', 'slice4d');

      return D(r.rank === 4, `slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`), Ta(r, e, n);
    }
  });

  function Aa(e, t, n, r, o) {
    let i = t[0];

    return i.rank < n.rank && (i = i.reshape(Mt(i.shape, r))), e.rank < n.rank && (e = e.reshape(Mt(e.shape, r))), {
      $x() {
        const t = e.mul(n.equal(i).cast(e.dtype));

        return o == null ? t : t.transpose(o);
      }
    };
  } const Ma = Yt({
    all_(t, e, n) {
      void 0 === e && (e = null), void 0 === n && (n = !1); let r = Kt(t, 'x', 'all', 'bool');

      D(r.dtype === 'bool', `Error Tensor must be of type bool. Got: ${r.dtype}`); const o = Ot(e, r.shape); let i = o; const a = Ft(i, r.rank);

      a != null && (r = r.transpose(a), i = Bt(i.length, r.rank)); const s = mt.engine.runKernel((t) => t.all(r, i), {$x: r});

      if (n) {
        const u = Mt(s.shape, o);

        return s.reshape(u);
      }

      return s;
    }
  }); const Oa = Yt({
    any_(t, e, n) {
      void 0 === e && (e = null), void 0 === n && (n = !1); let r = Kt(t, 'x', 'any', 'bool');

      D(r.dtype === 'bool', `Error Tensor must be of type bool. Got: ${r.dtype}`); const o = Ot(e, r.shape); let i = o; const a = Ft(i, r.rank);

      a != null && (r = r.transpose(a), i = Bt(i.length, r.rank)); const s = mt.engine.runKernel((t) => t.any(r, i), {$x: r});

      if (n) {
        const u = Mt(s.shape, o);

        return s.reshape(u);
      }

      return s;
    }
  }); const Pa = Yt({
    argMax_(t, e) {
      void 0 === e && (e = 0); let n = Kt(t, 'x', 'argMax');

      e == null && (e = 0); let r = Ot(e, n.shape); const o = Ft(r, n.rank);

      return o != null && (n = n.transpose(o), r = Bt(r.length, n.rank)), mt.engine.runKernel((t) => t.argMax(n, r[0]), {$x: n}, (t) => ({$x() { return Te(n); }}));
    }
  }); const Fa = Yt({
    argMin_(t, e) {
      void 0 === e && (e = 0); let n = Kt(t, 'x', 'argMin');

      e == null && (e = 0); let r = Ot(e, n.shape); const o = Ft(r, n.rank);

      return o != null && (n = n.transpose(o), r = Bt(r.length, n.rank)), mt.engine.runKernel((t) => t.argMin(n, r[0]), {$x: n}, (t) => ({$x() { return Te(n); }}));
    }
  }); const La = Yt({
    logSumExp_(t, e, n) {
      void 0 === e && (e = null), void 0 === n && (n = !1); const r = Kt(t, 'x', 'logSumExp'); const o = Ot(e, r.shape); const i = r.max(o, !0); const a = r.sub(i).exp().sum(o).log(); const s = i.reshape(a.shape).add(a);

      if (n) {
        const u = Mt(s.shape, o);

        return s.reshape(u);
      }

      return s;
    }
  }); const Ba = Yt({
    max_(t, e, n) {
      void 0 === e && (e = null), void 0 === n && (n = !1); let r = Kt(t, 'x', 'max'); const o = r; const i = Ot(e, r.shape); let a = i; const s = Ft(a, r.rank);

      s != null && (r = r.transpose(s), a = Bt(a.length, r.rank)); let u = mt.engine.runKernel((t, e) => e(t.max(r, a)), {$x: r}, (t, e) => Aa(t, e, o, i, s));

      if (n) {
        const c = Mt(u.shape, i);

        u = u.reshape(c);
      }

      return u;
    }
  }); const za = Yt({
    mean_(t, e, o) {
      void 0 === e && (e = null), void 0 === o && (o = !1); const n = Kt(t, 'x', 'mean'); const i = Ot(e, n.shape); const a = B(At(n.shape, i)[1]);

      return yt((n) => {
        const r = ne(a);

        return {
          value: (r.dtype === n.dtype ? n : n.cast(r.dtype)).div(r).sum(e, o),
          gradFunc(t) {
            const e = n.shape.slice();

            return i.forEach((t) => { e[t] = 1; }), t.reshape(e).mul(ce(n.shape, 'float32')).div(r);
          }
        };
      })(n);
    }
  }); const Wa = Yt({
    min_(t, e, n) {
      void 0 === e && (e = null), void 0 === n && (n = !1); let r = Kt(t, 'x', 'min'); const o = r; const i = Ot(e, r.shape); let a = i; const s = Ft(a, r.rank);

      s != null && (r = r.transpose(s), a = Bt(a.length, r.rank)); let u = mt.engine.runKernel((t, e) => e(t.min(r, a)), {$x: r}, (t, e) => Aa(t, e, o, i, s));

      if (n) {
        const c = Mt(u.shape, i);

        u = u.reshape(c);
      }

      return u;
    }
  }); const Ua = Yt({
    moments_(t, e, n) {
      void 0 === e && (e = null), void 0 === n && (n = !1); const r = Ot(e, (t = Kt(t, 'x', 'moments')).shape); const o = t.mean(r, n); let i = o.shape;

      return n || (i = Mt(o.shape, r)), {mean: o, variance: t.toFloat().sub(o.reshape(i)).square().mean(r, n)};
    }
  }); const Va = Yt({
    sum_(t, e, a) {
      void 0 === e && (e = null), void 0 === a && (a = !1); let n = Kt(t, 'x', 'sum');

      n.dtype === 'bool' && (n = n.toInt()); const s = Ot(e, n.shape);

      return yt((n) => {
        const t = Ft(s, n.rank); let e = s; let r = n;

        t != null && (r = n.transpose(t), e = Bt(e.length, n.rank)); let o = mt.engine.runKernel((t) => t.sum(r, e), {permutedX: r});

        if (a) {
          const i = Mt(o.shape, s);

          o = o.reshape(i);
        }

        return {
          value: o,
          gradFunc(t) {
            const e = n.shape.slice();

            return s.forEach((t) => { e[t] = 1; }), t.reshape(e).mul(ce(n.shape, 'float32'));
          }
        };
      })(n);
    }
  }); const Ga = Yt({
    prod_(t, e, n) {
      void 0 === e && (e = null), void 0 === n && (n = !1); let r = Kt(t, 'x', 'prod');

      r.dtype === 'bool' && (r = r.toInt()); const o = Ot(e, r.shape); const i = Ft(o, r.rank); let a = o; let s = r;

      i != null && (s = r.transpose(i), a = Bt(a.length, r.rank)); let u = mt.engine.runKernel((t) => t.prod(s, a), {permutedX: s});

      if (n) {
        const c = Mt(u.shape, o);

        u = u.reshape(c);
      }

      return u;
    }
  }); const qa = Yt({
    equal_(t, e) {
      const n = Kt(t, 'a', 'equal'); const r = Kt(e, 'b', 'equal');

      return Z(n, r), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.equal(n, r), {$a: n, $b: r});
    }
  }); const ja = Yt({
    equalStrict_(t, e) {
      const n = Kt(t, 'a', 'equalStrict'); const r = Kt(e, 'b', 'equalStrict');

      return f(n.shape, r.shape, 'Error in equalStrict: '), n.equal(r);
    }
  }); const Ha = Yt({
    greater_(t, e) {
      const n = Kt(t, 'a', 'greater'); const r = Kt(e, 'b', 'greater');

      return Z(n, r), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.greater(n, r), {$a: n, $b: r});
    }
  }); const $a = Yt({
    greaterEqual_(t, e) {
      const n = Kt(t, 'a', 'greaterEqual'); const r = Kt(e, 'b', 'greaterEqual');

      return Z(n, r), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.greaterEqual(n, r), {$a: n, $b: r}, (t) => ({$a() { return Te(n); }, $b() { return Te(r); }}));
    }
  }); const Ka = Yt({
    greaterEqualStrict_(t, e) {
      const n = Kt(t, 'a', 'greaterEqualStrict'); const r = Kt(e, 'b', 'greaterEqualStrict');

      return f(n.shape, r.shape, 'Error in greaterEqualStrict: '), n.greaterEqual(r);
    }
  }); const Xa = Yt({
    greaterStrict_(t, e) {
      const n = Kt(t, 'a', 'greaterStrict'); const r = Kt(e, 'b', 'greaterStrict');

      return f(n.shape, r.shape, 'Error in greaterStrict: '), n.greater(r);
    }
  }); const Ya = Yt({
    less_(t, e) {
      const n = Kt(t, 'a', 'less'); const r = Kt(e, 'b', 'less');

      return Z(n, r), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.less(n, r), {$a: n, $b: r});
    }
  }); const Qa = Yt({
    lessEqual_(t, e) {
      const n = Kt(t, 'a', 'lessEqual'); const r = Kt(e, 'b', 'lessEqual');

      return Z(n, r), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.lessEqual(n, r), {$a: n, $b: r});
    }
  }); const Ja = Yt({
    lessEqualStrict_(t, e) {
      const n = Kt(t, 'a', 'lessEqualStrict'); const r = Kt(e, 'b', 'lessEqualStrict');

      return f(n.shape, r.shape, 'Error in lessEqualStrict: '), n.lessEqual(r);
    }
  }); const Za = Yt({
    lessStrict_(t, e) {
      const n = Kt(t, 'a', 'lessStrict'); const r = Kt(e, 'b', 'lessStrict');

      return f(n.shape, r.shape, 'Error in lessStrict: '), n.less(r);
    }
  }); const ts = Yt({
    notEqual_(t, e) {
      const n = Kt(t, 'a', 'notEqual'); const r = Kt(e, 'b', 'notEqual');

      return Z(n, r), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.notEqual(n, r), {$a: n, $b: r});
    }
  }); const es = Yt({
    notEqualStrict_(t, e) {
      const n = Kt(t, 'a', 'notEqualStrict'); const r = Kt(e, 'b', 'notEqualStrict');

      return f(n.shape, r.shape, 'Error in notEqualStrict: '), n.notEqual(r);
    }
  }); const ns = Yt({
    add_(t, e) {
      const r = Kt(t, 'a', 'add'); const o = Kt(e, 'b', 'add');

      Z(r, o); const i = Ge(r.shape, o.shape);

      return mt.engine.runKernel((t) => t.add(r, o), {$a: r, $b: o}, (n) => ({
        $a() {
          let t = n; const e = Ve(r.shape, i);

          return e.length > 0 && (t = t.sum(e)), t.reshape(r.shape);
        },
        $b() {
          let t = n; const e = Ve(o.shape, i);

          return e.length > 0 && (t = t.sum(e)), t.reshape(o.shape);
        }
      }));
    }
  }); const rs = Yt({
    addN_(t) {
      D(Array.isArray(t), () => 'The argument passed to tf.addN() must be a list of tensors'), D(t.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${t.length}`); const e = t.map((t, e) => Kt(t, `tensors${ e}`, 'addN')); const n = e[0];

      e.forEach((t) => { if (t.dtype !== n.dtype) throw new Error('All tensors passed to tf.addN() must have the same dtype'); }), e.forEach((t) => { if (!T(t.shape, n.shape)) throw new Error('All tensors passed to tf.addN() must have the same shape'); }); const r = e;

      return mt.engine.runKernel((t) => t.addN(e), r, (n) => {
        const r = {};

        return e.forEach((t, e) => { r[e] = function () { return n.clone(); }; }), r;
      });
    }
  }); const os = Yt({addStrict_(t, e) { return f(t.shape, e.shape, 'Error in addStrict: '), t.add(e); }}); const is = Yt({
    atan2_(t, e) {
      const o = Kt(t, 'a', 'atan2'); const i = Kt(e, 'b', 'atan2');

      Z(o, i); const a = Ge(o.shape, i.shape);

      return mt.engine.runKernel((t) => t.atan2(o, i), {$a: o, $b: i}, (r) => ({
$a() {
 const t = ns(o.square(), i.square()); let e = r.mul(i.div(t)); const n = Ve(o.shape, a);

        return n.length > 0 && (e = e.sum(n)), e.reshape(o.shape); 
},
$b() {
 const t = ns(o.square(), i.square()); let e = Oi(r.mul(o.div(t))); const n = Ve(i.shape, a);

        return n.length > 0 && (e = e.sum(n)), e.reshape(i.shape); 
}
}));
    }
  }); const as = Yt({
    div_(t, e) {
      let n; const o = Kt(t, 'a', 'div'); const i = Kt(e, 'b', 'div');

      if (Z(o, i), o.dtype === 'int32' && i.dtype === 'int32') return us(o, i); n = function (t) { return t.realDivide(o, i); }; const a = Ge(o.shape, i.shape);

      return mt.engine.runKernel(n, {$a: o, $b: i}, (r) => ({
        $a() {
 const t = r.div(i.toFloat()); const e = Ve(o.shape, a);

          return e.length > 0 ? t.sum(e).reshape(o.shape) : t; 
},
        $b () {
          let t = r.mul(o.toFloat()); const e = Ve(i.shape, a);

          0 < e.length && (t = t.sum(e).reshape(i.shape)); const n = i.square();

          return t.div(n.toFloat()).neg();
        }
      }));
    }
  }); const ss = Yt({divStrict_(t, e) { return f(t.shape, e.shape, 'Error in divideStrict: '), t.div(e); }}); var us = Yt({
    floorDiv_(t, e) {
      const o = Kt(t, 'a', 'floorDiv'); const i = Kt(e, 'b', 'floorDiv');

      Z(o, i); const a = Ge(o.shape, i.shape);

      return mt.engine.runKernel((t) => t.floorDiv(o, i), {$a: o, $b: i}, (r) => ({
        $a() {
          let t = r.div(i.toFloat()); const e = Ve(o.shape, a);

          return e.length > 0 ? t.sum(e).reshape(o.shape) : t;
        },
        $b () {
          let t = r.mul(o.toFloat()); const e = Ve(i.shape, a);

          0 < e.length && (t = t.sum(e).reshape(i.shape)); const n = i.square();

          return t.div(n.toFloat()).neg();
        }
      }));
    }
  }); const cs = Yt({
    maximum_(t, e) {
      let n = Kt(t, 'a', 'maximum'); let r = Kt(e, 'b', 'maximum');

      return Z(n, r), n.dtype === 'bool' && (n = n.toInt()), r.dtype === 'bool' && (r = r.toInt()), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.maximum(n, r), {$a: n, $b: r}, (t) => ({$a() { return t.mul(n.greaterEqual(r).toFloat()); }, $b() { return t.mul(n.less(r).toFloat()); }}));
    }
  }); const ls = Yt({maximumStrict_(t, e) { return f(t.shape, e.shape, 'Error in maximumStrict: '), t.maximum(e); }}); const hs = Yt({
    minimum_(t, e) {
      let n = Kt(t, 'a', 'minimum'); let r = Kt(e, 'b', 'minimum');

      return Z(n, r), n.dtype === 'bool' && (n = n.toInt()), r.dtype === 'bool' && (r = r.toInt()), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.minimum(n, r), {$a: n, $b: r}, (t) => ({$a() { return t.mul(n.lessEqual(r).toFloat()); }, $b() { return t.mul(n.greater(r).toFloat()); }}));
    }
  }); const ps = Yt({minimumStrict_(t, e) { return f(t.shape, e.shape, 'Error in minimumStrict: '), t.minimum(e); }}); const fs = Yt({
    mod_(t, e) {
      const r = Kt(t, 'a', 'mod'); const o = Kt(e, 'b', 'mod');

      Z(r, o); const i = Ge(r.shape, o.shape);

      return mt.engine.runKernel((t) => t.mod(r, o), {$a: r, $b: o}, (n) => ({
        $a() {
          let t = Ve(r.shape, i);

          return t.length > 0 ? n.sum(t).reshape(r.shape) : n; 
},
        $b() {
 const t = n.mul(r.div(o).floor().neg()); const e = Ve(o.shape, i);

          return e.length > 0 ? t.sum(e).reshape(o.shape) : t; 
}
      }));
    }
  }); const ds = Yt({modStrict_(t, e) { return f(t.shape, e.shape, 'Error in modStrict: '), t.mod(e); }}); const ms = Yt({
    mul_(t, e) {
      const r = Kt(t, 'a', 'mul'); const o = Kt(e, 'b', 'mul');

      Z(r, o); const i = Ge(r.shape, o.shape);

      return mt.engine.runKernel((t) => t.multiply(r, o), {$a: r, $b: o}, (n) => ({
        $a() {
          let t = n.mul(o.toFloat()); const e = Ve(r.shape, i);

          return e.length > 0 ? t.sum(e).reshape(r.shape) : t;
        },
        $b() {
 const t = n.mul(r.toFloat()); const e = Ve(o.shape, i);

          return e.length > 0 ? t.sum(e).reshape(o.shape) : t; 
}
      }));
    }
  }); const vs = Yt({mulStrict_(t, e) { return f(t.shape, e.shape, 'Error in multiplyStrict: '), t.mul(e); }}); const gs = Yt({
    pow_(t, e) {
      const o = Kt(t, 'base', 'pow'); const i = Kt(e, 'exp', 'pow'); const a = Ge(o.shape, i.shape);

      return t = o.cast(Ie(o.dtype, i.dtype)), e = i.cast(Ie(o.dtype, i.dtype)), mt.engine.runKernel((t, e) => e(t.pow(o, i)), {$base: o, $exp: i}, (n, t) => {
        const r = t[0];

        return {
          $base() {
            let t = n.mul(i.toFloat().mul(r.div(o))); const e = Ve(o.shape, a);

            return e.length > 0 && (t = t.sum(e)), t.reshape(o.shape);
          },
          $exp() {
            let t = n.mul(r.mul(o.log()).toFloat()); const e = Ve(i.shape, a);

            return e.length > 0 && (t = t.sum(e)), t.reshape(i.shape);
          }
        };
      });
    }
  }); const ys = Yt({powStrict_(t, e) { return f(t.shape, e.shape, 'Error in powStrict: '), t.pow(e); }}); const xs = Yt({
    squaredDifference_(t, e) {
      const n = Kt(t, 'a', 'squaredDifference'); const r = Kt(e, 'b', 'squaredDifference');

      return Z(n, r), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.squaredDifference(n, r), {$a: n, $b: r}, (t) => {
        const e = ne(2);

        return {$a() { return t.mul(n.sub(r).mul(e)); }, $b() { return t.mul(r.sub(n).mul(e)); }};
      });
    }
  }); const bs = Yt({squaredDifferenceStrict_(t, e) { return f(t.shape, e.shape, 'Error in squaredDifferenceStrict: '), t.squaredDifference(e); }}); const ws = Yt({
    sub_(t, e) {
      const r = Kt(t, 'a', 'sub'); const o = Kt(e, 'b', 'sub');

      Z(r, o); const i = Ge(r.shape, o.shape);

      return mt.engine.runKernel((t) => t.subtract(r, o), {$a: r, $b: o}, (n) => ({
$a() {
 let t = n; const e = Ve(r.shape, i);

        return e.length > 0 && (t = t.sum(e)), t.reshape(r.shape); 
},
$b() {
 let t = n; const e = Ve(o.shape, i);

        return e.length > 0 && (t = t.sum(e)), t.neg().reshape(o.shape); 
}
}));
    }
  }); const Es = Yt({subStrict_(t, e) { return f(t.shape, e.shape, 'Error in subStrict: '), t.sub(e); }}); const Ss = Yt({
    logicalAnd_(t, e) {
      const n = Kt(t, 'a', 'logicalAnd', 'bool'); const r = Kt(e, 'b', 'logicalAnd', 'bool');

      return D(n.dtype === 'bool' && r.dtype === 'bool', 'Error Array must be of type bool.'), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.logicalAnd(n, r), {$a: n, $b: r});
    }
  }); const _s = Yt({
    logicalNot_(t) {
      const e = Kt(t, 'x', 'logicalNot', 'bool');

      return D(e.dtype === 'bool', 'Error Array must be of type bool.'), mt.engine.runKernel((t) => t.logicalNot(e), {$x: e});
    }
  }); const Cs = Yt({
    logicalOr_(t, e) {
      const n = Kt(t, 'a', 'logicalOr', 'bool'); const r = Kt(e, 'b', 'logicalOr', 'bool');

      return D(n.dtype === 'bool' && r.dtype === 'bool', 'Error Array must be of type bool.'), Ge(n.shape, r.shape), mt.engine.runKernel((t) => t.logicalOr(n, r), {$a: n, $b: r});
    }
  }); const Rs = Yt({
    logicalXor_(t, e) {
      const n = Kt(t, 'a', 'logicalXor', 'bool'); const r = Kt(e, 'b', 'logicalXor', 'bool');

      return D(n.dtype === 'bool' && r.dtype === 'bool', 'Error Array must be of type bool.'), Ge(n.shape, r.shape), Cs(t, e).logicalAnd(Ss(t, e).logicalNot());
    }
  }); const Ts = Yt({
    where_(t, e, n) {
      const r = Kt(e, 'a', 'where'); const o = Kt(n, 'b', 'where'); const i = Kt(t, 'condition', 'where', 'bool');

      return D(i.dtype === 'bool', 'Error Condition must be of type bool.'), f(r.shape, o.shape, 'Error in where: '), i.rank === 1 ? D(i.shape[0] === r.shape[0], 'The first dimension of `a` must match the size of `condition`.') : f(i.shape, o.shape, 'Error in where: '), mt.engine.runKernel((t) => t.select(i, r, o), {$condition: i, $a: r, $b: o}, (t) => ({$condition() { return Te(i); }, $a() { return t.mul(i.cast(r.dtype)); }, $b() { return t.mul(i.logicalNot().cast(o.dtype)); }}));
    }
  }); const ks = function (o) {
    return m(this, void 0, void 0, function () {
      let e, n, r;

      return S(this, (t) => { switch (t.label) { case 0: return D((e = Kt(o, 'condition', 'where', 'bool')).dtype === 'bool', 'Condition must be of type bool.'), [4, e.data()]; case 1: return n = t.sent(), r = fi(e.shape, n), o !== e && e.dispose(), [2, r]; } });
    });
  }; const Is = Yt({
    elu_(t) {
      const n = Kt(t, 'x', 'elu');

      return mt.engine.runKernel((t, e) => e(t.elu(n)), {$x: n}, (e, t) => {
        const n = t[0];

        return {$x() { return mt.engine.runKernel((t) => t.eluDer(e, n), {dy: e, y: n}); }};
      });
    }
  }); const Ds = Yt({
    leakyRelu_(t, e) {
      void 0 === e && (e = 0.2); const n = Kt(t, 'x', 'leakyRelu');

      return cs(ne(e).mul(n), n);
    }
  }); const Ns = Yt({
    prelu_(t, e) {
      const n = Kt(t, 'x', 'prelu'); const r = Kt(e, 'alpha', 'prelu'); const o = ne(0);

      return cs(o, n).add(r.mul(hs(o, n)));
    }
  }); const As = Yt({
    relu_(t) {
      const n = Kt(t, 'x', 'relu');

      return n.dtype === 'bool' ? n.toInt() : mt.engine.runKernel((t) => t.relu(n), {$x: n}, (t) => {
        const e = n.step();

        return {$x() { return t.mulStrict(e.toFloat()); }};
      });
    }
  }); const Ms = Yt({
    selu_(t) {
      const a = Kt(t, 'x', 'selu');

      return mt.engine.runKernel((t) => t.selu(a), {$x: a}, (i) => ({
        $x() {
          const t = a.greater(ne(0)); const e = ne(yo); const n = ne(xo); const r = i.mul(n); const o = i.mul(e).mul(a.toFloat().exp());

          return Ts(t, r, o);
        }
      }));
    }
  }); const Os = Yt({
    transpose_(t, n) {
      const e = Kt(t, 'x', 'transpose');

      return n == null && (n = e.shape.map((t, e) => e).reverse()), D(e.rank === n.length, `Error in transpose: rank of input ${e.rank} must match length of perm ${n}.`), n.forEach((t) => { D(t >= 0 && t < e.rank, `All entries in 'perm' must be between 0 and ${e.rank - 1} but got ${n}`); }), e.rank <= 1 ? e.clone() : mt.engine.runKernel((t) => t.transpose(e, n), {$x: e}, (t) => {
        const e = Lt(n);

        return {$x() { return t.transpose(e); }};
      });
    }
  }); const Ps = Yt({
    localResponseNormalization_(t, r, o, i, a) {
      void 0 === r && (r = 5), void 0 === o && (o = 1), void 0 === i && (i = 1), void 0 === a && (a = 0.5); const e = Kt(t, 'x', 'localResponseNormalization');

      D(e.rank === 4 || e.rank === 3, `Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${e.rank}.`), D(N(r), `Error in localResponseNormalization: depthRadius must be an integer\n                     but got depthRadius ${r}.`); let s = e; let n = !1;

      e.rank === 3 && (n = !0, s = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])); const u = mt.engine.runKernel((t, e) => e(t.localResponseNormalization4D(s, r, o, i, a)), {x4D: s}, (e, t) => {
        const n = t[0];

        return {x4D() { return mt.engine.runKernel((t) => t.LRNGrad(e, s, n, r, o, i, a), {}); }};
      });

      return n ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
    }
  }); const Fs = Yt({
    norm_(t, e, n, r) {
      void 0 === e && (e = 'euclidean'), void 0 === n && (n = null), void 0 === r && (r = !1); const o = (function t(e, n, r) { if (void 0 === r && (r = null), e.rank === 0) return e.abs(); if (e.rank !== 1 && r === null) return t(e.reshape([-1]), n, r); if (e.rank === 1 || typeof r === 'number' || r instanceof Array && r.length === 1) { if (n === 1) return e.abs().sum(r); if (n === 1 / 0) return e.abs().max(r); if (n === -1 / 0) return e.abs().min(r); if (n === 'euclidean' || n === 2) return e.abs().pow(ne(2, 'int32')).sum(r).sqrt(); throw new Error(`Error in norm: invalid ord value: ${n}`); } if (r instanceof Array && r.length === 2) { if (n === 1) return e.abs().sum(r[0]).max(r[1] - 1); if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]); if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]); if (n === 'fro' || n === 'euclidean') return e.square().sum(r).sqrt(); throw new Error(`Error in norm: invalid ord value: ${n}`); } throw new Error(`Error in norm: invalid axis: ${r}`); }(t = Kt(t, 'x', 'norm'), e, n)); let i = o.shape;

      if (r) {
        const a = Ot(n, t.shape);

        i = Mt(o.shape, a);
      }

      return o.reshape(i);
    }
  });

  function Ls(t, e) {
    for (var n = [], r = t; r < e; ++r)n.push(r);

    return n;
  } function Bs(t) {
    for (var e = [], n = 0; n < t.length; ++n) for (let r = 0; r < t[n].length; ++r)e.push(t[n][r]);

    return e;
  } const zs = Yt({
    gather_(t, e, v) {
      void 0 === v && (v = 0); const g = Kt(t, 'x', 'gather'); const y = Kt(e, 'indices', 'gather', 'int32');

      return D(y.dtype === 'int32', 'Indices must be of dtype `int32`'), v = Ot(v, g.shape)[0], mt.engine.runKernel((t) => t.gather(g, y, v), {$x: g}, (m) => ({
        $x() {
          if (v === 0) return Ws(m, y, g.shape[v]); const t = g.shape; const e = y.size; const n = t.slice(0, v); const r = n.length; const o = t.slice(v, t.length).slice(1); const i = o.length; const a = Ls(0, r); const s = Ls(r + 1, r + 1 + i); const u = Bs([n, [e], o]); const c = m.reshape(u); const l = y.reshape([e]); const h = Bs([[r], a, s]); const p = c.transpose(h); const f = Ws(p, l, g.shape[v]); const d = Lt(h);

          return f.transpose(d);
        }
      }));
    }
  }); var Ws = Yt({
    unsortedSegmentSum_(t, e, n) {
      const r = Kt(t, 'x', 'unsortedSegmentSum'); const o = Kt(e, 'segmentIds', 'unsortedSegmentSum', 'int32');

      return D(o.dtype === 'int32', 'segmentIds must be of dtype `int32`'), D(N(n), 'numSegments must be of dtype int'), mt.engine.runKernel((t) => t.unsortedSegmentSum(r, o, n), {$x: r}, (t) => ({
$x() {
 return (function (t, e) {
 for (var n = cs(e, Te(e)), r = zs(t, n), o = $a(e, ne(0, 'int32')), i = r.rank - o.rank, a = 0; a < i; ++a)o = $o(o, a + 1); o = Ss(o, ce(r.shape, 'bool')); const s = Te(r);

        return Ts(o, r, s); 
}(t, o)); 
}
}));
    }
  }); const Us = Yt({
    basicLSTMCell_(t, e, n, r, o, i) {
      const a = Kt(t, 'forgetBias', 'basicLSTMCell'); const s = Kt(e, 'lstmKernel', 'basicLSTMCell'); const u = Kt(n, 'lstmBias', 'basicLSTMCell'); const c = Kt(r, 'data', 'basicLSTMCell'); const l = Kt(o, 'c', 'basicLSTMCell'); const h = Kt(i, 'h', 'basicLSTMCell'); const p = c.concat(h, 1).matMul(s).add(u); const f = p.shape[0]; const d = p.shape[1] / 4; const m = [f, d]; const v = p.slice([0, 0], m); const g = p.slice([0, d], m); const y = p.slice([0, 2 * d], m); const x = p.slice([0, 3 * d], m); const b = v.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(a.add(y).sigmoid()));

      return [b, b.tanh().mulStrict(x.sigmoid())];
    }
  }); const Vs = Yt({
    multiRNNCell_(t, e, n, r) {
      for (var o = Kt(e, 'data', 'multiRNNCell'), i = Xt(n, 'c', 'multiRNNCell'), a = Xt(r, 'h', 'multiRNNCell'), s = o, u = [], c = 0; c < t.length; c++) {
        const l = t[c](s, i[c], a[c]);

        u.push(l[0]), u.push(l[1]), s = l[1];
      } const h = []; const p = [];

      for (c = 0; c < u.length; c += 2)h.push(u[c]), p.push(u[c + 1]);

      return [h, p];
    }
  }); const Gs = Yt({
    movingAverage_(t, e, n, r, o) {
      void 0 === o && (o = !0); const i = Kt(t, 'v', 'movingAverage'); const a = Kt(e, 'x', 'movingAverage'); const s = Kt(n, 'decay', 'movingAverage');

      Z(i, a), D(T(i.shape, a.shape), 'Shape mismatch in v and x'); const u = ne(1); const c = u.sub(s); let l = a.sub(i).mul(c);

      if (o) {
        D(r != null, 'When using zeroDebias: true, step is required.'); const h = Kt(r, 'step', 'movingAverage');

        l = l.div(u.sub(gs(s, h)));
      }

      return i.add(l);
    }
  }); const qs = Yt({
    stridedSlice_(t, e, n, r, o, i, a, s, u) {
      if (void 0 === o && (o = 0), void 0 === i && (i = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), a !== 0) throw new Error('ellipsis mask is not yet supported'); if (s !== 0) throw new Error('new axis mask is not yet supported'); const c = Kt(t, 'x', 'stridedSlice');

      return mt.engine.runKernel((t) => t.stridedSlice(c, e, n, r, o, i, a, s, u), {$x: c});
    }
  }); const js = Yt({
    topk_(t, e, n) {
      void 0 === e && (e = 1), void 0 === n && (n = !0); const r = Kt(t, 'x', 'topk');

      if (r.rank === 0) throw new Error('topk() expects the input to be of rank 1 or higher'); const o = r.shape[r.shape.length - 1];

      if (o < e) throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`); const i = mt.engine.runKernel((t) => t.topk(r, e, n), {$x: r});

      return {values: i[0], indices: i[1]};
    }
  }); const Hs = Yt({
    scatterND_(t, e, n) {
      const r = Kt(t, 'indices', 'scatterND', 'int32'); const o = Kt(e, 'updates', 'scatterND');

      return Vt(o, r, n), mt.engine.runKernel((t) => t.scatterND(r, o, n), {$indices: r, $updates: o});
    }
  }); const $s = Yt({
    fft_(t) {
      D(t.dtype === 'complex64', `The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`); const e = t.shape[t.shape.length - 1]; const n = t.size / e; const r = t.as2D(n, e);

      return mt.engine.runKernel((t) => t.fft(r), {input: t}).reshape(t.shape);
    }
  }); const Ks = Object.freeze({fft: $s}); const Xs = Yt({
    sparseToDense_(t, e, n, r) {
      const o = Kt(t, 'sparseIndices', 'sparseToDense', 'int32'); const i = Kt(e, 'sparseValues', 'sparseToDense'); const a = Kt(r, 'defaultValue', 'sparseToDense');

      return (function (t, e, n) {
        if (t.dtype !== 'int32') throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`); if (t.rank > 2) throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`); const r = t.rank > 0 ? t.shape[0] : 1; const o = t.rank > 1 ? t.shape[1] : 1;

        if (n.length !== o) throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`); const i = e.size;

        if (e.rank !== 0 && (e.rank !== 1 || i !== r)) throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);
      }(o, i, n)), mt.engine.runKernel((t) => t.sparseToDense(o, i, n, a), {$sparseIndices: o, $sparseValues: i, $defaultValue: a});
    }
  }); let Ys; let Qs; const Js = Yt({
    gatherND_(t, e) {
      const n = Kt(e, 'indices', 'gatherND', 'int32'); const r = Kt(t, 'x', 'gatherND');

      return mt.engine.runKernel((t) => t.gatherND(r, n), {$x: r, $indices: n});
    }
  });

  (Qs = Ys || (Ys = {}))[Qs.NONE = 0] = 'NONE', Qs[Qs.MEAN = 1] = 'MEAN', Qs[Qs.SUM = 2] = 'SUM', Qs[Qs.SUM_BY_NONZERO_WEIGHTS = 3] = 'SUM_BY_NONZERO_WEIGHTS'; const Zs = Yt({
    absoluteDifference_(t, e, n, r) {
      void 0 === r && (r = Ys.SUM_BY_NONZERO_WEIGHTS); const o = Kt(t, 'labels', 'absoluteDifference'); const i = Kt(e, 'predictions', 'absoluteDifference'); let a = null;

      n != null && (a = Kt(n, 'weights', 'absoluteDifference')), f(o.shape, i.shape, 'Error in absoluteDifference: '); const s = o.sub(i).abs();

      return tu(s, a, r);
    }
  }); var tu = Yt({
    computeWeightedLoss_(t, e, n) {
      void 0 === n && (n = Ys.SUM_BY_NONZERO_WEIGHTS); const r = Kt(t, 'losses', 'computeWeightedLoss'); let o = null;

      e != null && (o = Kt(e, 'weights', 'computeWeightedLoss')); const i = o == null ? r : r.mul(o);

      if (n === Ys.NONE) return i; if (n === Ys.SUM) return i.sum(); if (n === Ys.MEAN) {
        if (o == null) return i.mean(); const a = B(r.shape) / B(o.shape); const s = i.sum().div(o.sum());

        return a > 1 ? s.div(ne(a)) : s;
      } if (n !== Ys.SUM_BY_NONZERO_WEIGHTS) throw Error(`Unknown reduction: ${n}`); if (o == null) return i.sum().div(ne(r.size)); const u = o.mul(ce(r.shape)).notEqual(ne(0)).sum().toFloat();

      return i.sum().div(u);
    }
  }); const eu = Yt({
    cosineDistance_(t, e, n, r, o) {
      void 0 === o && (o = Ys.SUM_BY_NONZERO_WEIGHTS); const i = Kt(t, 'labels', 'cosineDistance'); const a = Kt(e, 'predictions', 'cosineDistance'); let s = null;

      r != null && (s = Kt(r, 'weights', 'cosineDistance')), f(i.shape, a.shape, 'Error in cosineDistance: '); const u = ne(1).sub(i.mul(a).sum(n, !0));

      return tu(u, s, o);
    }
  }); const nu = Yt({
    hingeLoss_(t, e, n, r) {
      void 0 === r && (r = Ys.SUM_BY_NONZERO_WEIGHTS); let o = Kt(t, 'labels', 'hingeLoss'); const i = Kt(e, 'predictions', 'hingeLoss'); let a = null;

      n != null && (a = Kt(n, 'weights', 'hingeLoss')), f(o.shape, i.shape, 'Error in hingeLoss: '); const s = ne(1);

      o = ne(2).mul(o).sub(s); const u = s.sub(o.mul(i)).relu();

      return tu(u, a, r);
    }
  }); const ru = Yt({
    huberLoss_(t, e, n, r, o) {
      void 0 === r && (r = 1), void 0 === o && (o = Ys.SUM_BY_NONZERO_WEIGHTS); const i = Kt(t, 'labels', 'huberLoss'); const a = Kt(e, 'predictions', 'huberLoss'); let s = null;

      n != null && (s = Kt(n, 'weights', 'huberLoss')), f(i.shape, a.shape, 'Error in huberLoss: '); const u = ne(r); const c = a.sub(i).abs(); const l = hs(c, u); const h = c.sub(l); const p = ne(0.5).mul(l.square()).add(u.mul(h));

      return tu(p, s, o);
    }
  }); const ou = Yt({
    logLoss_(t, e, n, r, o) {
      void 0 === r && (r = 1e-7), void 0 === o && (o = Ys.SUM_BY_NONZERO_WEIGHTS); const i = Kt(t, 'labels', 'logLoss'); const a = Kt(e, 'predictions', 'logLoss'); let s = null;

      n != null && (s = Kt(n, 'weights', 'logLoss')), f(i.shape, a.shape, 'Error in logLoss: '); const u = ne(1); const c = ne(r); const l = i.mul(a.add(c).log()).neg().sub(u.sub(i).mul(u.sub(a).add(c).log()));

      return tu(l, s, o);
    }
  }); const iu = Yt({
    meanSquaredError_(t, e, n, r) {
      void 0 === r && (r = Ys.SUM_BY_NONZERO_WEIGHTS); const o = Kt(t, 'labels', 'meanSquaredError'); const i = Kt(e, 'predictions', 'meanSquaredError'); let a = null;

      n != null && (a = Kt(n, 'weights', 'meanSquaredError')), f(o.shape, i.shape, 'Error in meanSquaredError: '); const s = o.squaredDifference(i);

      return tu(s, a, r);
    }
  }); const au = Yt({
    sigmoidCrossEntropy_(t, e, n, r, o) {
      void 0 === r && (r = 0), void 0 === o && (o = Ys.SUM_BY_NONZERO_WEIGHTS); let i = Kt(t, 'multiClassLabels', 'sigmoidCrossEntropy'); const a = Kt(e, 'logits', 'sigmoidCrossEntropy'); let s = null;

      if (n != null && (s = Kt(n, 'weights', 'sigmoidCrossEntropy')), f(i.shape, a.shape, 'Error in sigmoidCrossEntropy: '), r > 0) {
        const u = ne(r); const c = ne(1); const l = ne(0.5);

        i = i.mul(c.sub(u)).add(l.mul(u));
      } const h = (function (t, e) {
        const n = Kt(t, 'labels', 'sigmoidCrossEntropyWithLogits'); const r = Kt(e, 'logits', 'sigmoidCrossEntropyWithLogits');

        f(n.shape, r.shape, 'Error in sigmoidCrossEntropyWithLogits: '); const o = r.relu(); const i = r.mul(n); const a = r.abs().neg().exp().log1p();

        return o.sub(i).add(a);
      }(i, a));

      return tu(h, s, o);
    }
  }); const su = Yt({
    softmaxCrossEntropy_(t, e, n, r, o) {
      void 0 === r && (r = 0), void 0 === o && (o = Ys.SUM_BY_NONZERO_WEIGHTS); let i = Kt(t, 'onehotLabels', 'softmaxCrossEntropy'); const a = Kt(e, 'logits', 'softmaxCrossEntropy'); let s = null;

      if (n != null && (s = Kt(n, 'weights', 'softmaxCrossEntropy')), f(i.shape, a.shape, 'Error in softmaxCrossEntropy: '), r > 0) {
        const u = ne(r); const c = ne(1); const l = ne(i.shape[1]);

        i = i.mul(c.sub(u)).add(u.div(l));
      } const h = (function (t, e, o) {
        if (void 0 === o && (o = -1), o === -1 && (o = e.rank - 1), o !== e.rank - 1) throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${o}`);

        return yt((n, t) => {
          const e = t.logSumExp([o], !0); const r = t.toFloat().sub(e);

          return {
            value: r.mul(n).neg().sum([o]),
            gradFunc (t) {
              let e = Mt(t.shape, [o]);

              return [t.reshape(e).mul(n.toFloat().sub(r.exp())), t.reshape(e).mul(r.exp().sub(n.toFloat()))];
            }
          };
        })(t, e);
      }(i, a));

      return tu(h, s, o);
    }
  }); const uu = Object.freeze({
    get Reduction() { return Ys; }, absoluteDifference: Zs, computeWeightedLoss: tu, cosineDistance: eu, hingeLoss: nu, huberLoss: ru, logLoss: ou, meanSquaredError: iu, sigmoidCrossEntropy: au, softmaxCrossEntropy: su
  });

  function cu(r, o) {
    return void 0 === o && (o = !1), mt.engine.tidy(() => {
      if (r.shape.length !== 2) throw new Error(`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`); for (var h = r.shape[0], p = r.shape[1], f = Ko(h), d = r.clone(), m = oe([[1]], [1, 1]), v = m.clone(), t = p <= h ? p : h, e = function (l) {
          let t; const e = d; const n = v; const r = f;

          v = (t = mt.engine.tidy(() => {
            const t = d.slice([l, l], [h - l, 1]); const e = t.norm(); const n = d.slice([l, l], [1, 1]); const r = n.sign().neg(); const o = n.sub(r.mul(e)); const i = t.div(o);

            v = i.shape[0] === 1 ? m.clone() : m.concat(i.slice([1, 0], [i.shape[0] - 1, i.shape[1]]), 0); const a = r.matMul(o).div(e).neg(); const s = d.slice([l, 0], [h - l, p]); const u = a.mul(v);

            d = l === 0 ? s.sub(u.matMul(v.transpose().matMul(s))) : d.slice([0, 0], [l, p]).concat(s.sub(u.matMul(v.transpose().matMul(s))), 0); const c = f.slice([0, l], [h, f.shape[1] - l]);

            return f = l === 0 ? c.sub(c.matMul(v).matMul(u.transpose())) : f.slice([0, 0], [h, l]).concat(c.sub(c.matMul(v).matMul(u.transpose())), 1), [v, d, f];
          }))[0], d = t[1], f = t[2], Et([e, n, r]);
        }, n = 0; n < t; ++n)e(n);

      return !o && p < h && (f = f.slice([0, 0], [h, p]), d = d.slice([0, 0], [p, p])), [f, d];
    });
  } const lu = Yt({
    gramSchmidt_(t) {
      let e;

      if (Array.isArray(t)) { e = !1, D(t != null && t.length > 0, 'Gram-Schmidt process: input must not be null, undefined, or empty'); for (var n = t[0].shape[0], r = 1; r < t.length; ++r)D(t[r].shape[0] === n, `Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[r].shape[0]} vs. ${n})`); }
      else e = !0, t = ko(t, t.shape[0], 0).map((t) => ui(t, [0])); D(t.length <= t[0].shape[0], `Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`); const o = []; const i = t; const a = function (r) {
        o.push(mt.engine.tidy(() => {
          let t = i[r];

          if (r > 0) {
            for (let e = 0; e < r; ++e) {
              const n = Va(o[e].mulStrict(t)).mul(o[e]);

              t = t.sub(n);
            }
          }

          return t.div(Fs(t, 'euclidean'));
        }));
      };

      for (r = 0; r < t.length; ++r)a(r);

      return e ? ci(o, 0) : o;
    }
  }); const hu = Yt({
    qr_(t, o) {
      if (void 0 === o && (o = !1), t.rank < 2) throw new Error(`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`); if (t.rank === 2) return cu(t, o); const e = t.shape.slice(0, t.shape.length - 2).reduce((t, e) => t * e); const i = []; const a = [];

      return pi(t.reshape([e, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0).forEach((t) => {
        const e = cu(t, o); const n = e[0]; const r = e[1];

        i.push(n), a.push(r);
      }), [ci(i, 0).reshape(t.shape), ci(a, 0).reshape(t.shape)];
    }
  }); const pu = Object.freeze({gramSchmidt: lu, qr: hu});

  function fu(t, e, n, r, o) {
    r == null && (r = 0.5), o == null && (o = Number.NEGATIVE_INFINITY); const i = t.shape[0];

    return n = Math.min(n, i), D(r >= 0 && r <= 1, `iouThreshold must be in [0, 1], but was '${r}'`), D(t.rank === 2, `boxes must be a 2D tensor, but was of rank '${t.rank}'`), D(t.shape[1] === 4, `boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`), D(e.rank === 1, 'scores must be a 1D tensor'), D(e.shape[0] === i, `scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`), {maxOutputSize: n, iouThreshold: r, scoreThreshold: o};
  } const du = Yt({
    resizeBilinear_(t, e, n) {
      void 0 === n && (n = !1); const r = Kt(t, 'images', 'resizeBilinear');

      D(r.rank === 3 || r.rank === 4, `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`), D(e.length === 2, `Error in resizeBilinear: new shape must 2D, but got shape ${e}.`); let o = r; let i = !1;

      r.rank === 3 && (i = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2])); const a = e[0]; const s = e[1]; const u = mt.engine.runKernel((t, e) => t.resizeBilinear(o, a, s, n), {batchImages: o}, (e, t) => ({batchImages() { return mt.engine.runKernel((t) => t.resizeBilinearBackprop(e, o, n), {}); }}));

      return i ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
    }
  }); const mu = Yt({
    resizeNearestNeighbor_(t, e, n) {
      void 0 === n && (n = !1); const r = Kt(t, 'images', 'resizeNearestNeighbor');

      D(r.rank === 3 || r.rank === 4, `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`), D(e.length === 2, `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`), D(r.dtype === 'float32' || r.dtype === 'int32', '`images` must have `int32` or `float32` as dtype'); let o = r; let i = !1;

      r.rank === 3 && (i = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2])); const a = e[0]; const s = e[1]; const u = mt.engine.runKernel((t, e) => t.resizeNearestNeighbor(o, a, s, n), {batchImages: o}, (e, t) => ({batchImages() { return mt.engine.runKernel((t) => t.resizeNearestNeighborBackprop(e, o, n), {}); }}));

      return i ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
    }
  }); const vu = Yt({
    nonMaxSuppression_(t, e, n, r, o) {
      void 0 === r && (r = 0.5), void 0 === o && (o = Number.NEGATIVE_INFINITY); const i = Kt(t, 'boxes', 'nonMaxSuppression'); const a = Kt(e, 'scores', 'nonMaxSuppression'); const s = fu(i, a, n, r, o);

      return n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold, mt.engine.runKernel((t) => t.nonMaxSuppression(i, a, n, r, o), {$boxes: i});
    }
  }); const gu = function (s, u, c, l, h) {
    return void 0 === l && (l = 0.5), void 0 === h && (h = Number.NEGATIVE_INFINITY), m(this, void 0, void 0, function () {
      let e, n, r, o, i, a;

      return S(this, (t) => { switch (t.label) { case 0: return e = Kt(s, 'boxes', 'nonMaxSuppressionAsync'), n = Kt(u, 'scores', 'nonMaxSuppressionAsync'), r = fu(e, n, c, l, h), c = r.maxOutputSize, l = r.iouThreshold, h = r.scoreThreshold, [4, e.data()]; case 1: return o = t.sent(), [4, n.data()]; case 2: return i = t.sent(), a = Pe(o, i, c, l, h), e !== s && e.dispose(), n !== u && n.dispose(), [2, a]; } });
    });
  }; const yu = function (t, e, n, r, o, i) {
    const a = Kt(t, 'image', 'cropAndResize', 'float32'); const s = Kt(e, 'boxes', 'cropAndResize', 'float32'); const u = Kt(n, 'boxInd', 'cropAndResize', 'int32');

    o = o || 'bilinear', i = i || 0; const c = s.shape[0];

    return D(a.rank === 4, `Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`), D(s.rank === 2 && s.shape[1] === 4, `Error in cropAndResize: boxes must be have size [${c},4] but had shape ${s.shape}.`), D(u.rank === 1 && u.shape[0] === c, `Error in cropAndResize: boxInd must be have size [${c}] but had shape ${s.shape}.`), D(u.dtype === 'int32', `Error in cropAndResize: boxInd must be of dtype int32, but got dtype ${u.dtype}.`), D(r.length === 2, `Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`), D(r[0] >= 1 && r[1] >= 1, `cropSize must be atleast [1,1], but was ${r}`), D(o === 'bilinear' || o === 'nearest', `method must be bilinear or nearest, but was ${o}`), mt.engine.runKernel((t, e) => t.cropAndResize(a, s, u, r, o, i), {$image: a, $boxes: s});
  }; const xu = Object.freeze({
    resizeBilinear: du, resizeNearestNeighbor: mu, nonMaxSuppression: vu, nonMaxSuppressionAsync: gu, cropAndResize: yu
  }); const bu = Object.freeze({
    image: xu, linalg: pu, losses: uu, spectral: Ks, op: Yt, batchNormalization2d: Xi, batchNormalization3d: Yi, batchNormalization4d: Qi, batchNormalization: Ji, complex: Jt, real: Zt, imag: te, concat: So, concat1d: _o, concat2d: Co, concat3d: Ro, concat4d: To, split: ko, conv1d: ha, conv2d: pa, conv2dDerFilter: fa, depthwiseConv2d: da, separableConv2d: ma, conv2dTranspose: va, matMul: aa, dot: sa, outerProduct: ua, reverse: ga, reverse1d: ya, reverse2d: xa, reverse3d: ba, reverse4d: wa, maxPool: _a, avgPool: Ca, pool: Ra, slice: Ta, slice1d: ka, slice2d: Ia, slice3d: Da, slice4d: Na, abs: vi, acos: gi, acosh: yi, asin: xi, asinh: bi, atan: wi, atanh: Ei, ceil: Si, clipByValue: _i, cos: Ci, cosh: Ri, erf: Ti, exp: ki, expm1: Ii, floor: Di, log: Ni, log1p: Ai, logSigmoid: Mi, neg: Oi, reciprocal: Pi, round: Fi, rsqrt: Li, sigmoid: Bi, sign: zi, sin: Wi, sinh: Ui, softplus: Vi, sqrt: Gi, square: qi, step: ji, tan: Hi, tanh: $i, all: Ma, any: Oa, argMax: Pa, argMin: Fa, logSumExp: La, max: Ba, mean: za, min: Wa, moments: Ua, sum: Va, prod: Ga, equal: qa, equalStrict: ja, greater: Ha, greaterEqual: $a, greaterEqualStrict: Ka, greaterStrict: Xa, less: Ya, lessEqual: Qa, lessEqualStrict: Ja, lessStrict: Za, notEqual: ts, notEqualStrict: es, add: ns, addN: rs, addStrict: os, atan2: is, div: as, divStrict: ss, floorDiv: us, maximum: cs, maximumStrict: ls, minimum: hs, minimumStrict: ps, mod: fs, modStrict: ds, mul: ms, mulStrict: vs, pow: gs, powStrict: ys, squaredDifference: xs, squaredDifferenceStrict: bs, sub: ws, subStrict: Es, elu: Is, leakyRelu: Ds, prelu: Ns, relu: As, selu: Ms, logicalAnd: Ss, logicalNot: _s, logicalOr: Cs, logicalXor: Rs, where: Ts, whereAsync: ks, buffer: Wo, toPixels: zo, print: Uo, batchToSpaceND: Vo, cast: Go, clone: qo, cumsum: jo, depthToSpace: Ho, expandDims: $o, eye: Ko, fromPixels: Xo, multinomial: Yo, oneHot: Qo, pad: Jo, pad1d: Zo, pad2d: ti, pad3d: ei, pad4d: ni, rand: ri, randomNormal: oi, randomUniform: ii, reshape: ai, spaceToBatchND: si, squeeze: ui, stack: ci, tile: li, truncatedNormal: hi, unstack: pi, fill: he, linspace: pe, ones: ce, range: fe, scalar: ne, tensor: ee, tensor1d: re, tensor2d: oe, tensor3d: ie, tensor4d: ae, tensor5d: se, tensor6d: ue, zeros: le, onesLike: Re, zerosLike: Te, transpose: Os, softmax: Qt, localResponseNormalization: Ps, norm: Fs, gather: zs, unsortedSegmentSum: Ws, basicLSTMCell: Us, multiRNNCell: Vs, movingAverage: Gs, stridedSlice: qs, topk: js, scatterND: Hs, fft: $s, sparseToDense: Xs, gatherND: Js
  }); const wu = (function () {
    function t() { this.blockSize = 48, this.firstUse = !0, mt.get('IS_BROWSER') && (this.canvas = document.createElement('canvas')); }

    return t.prototype.setDataMover = function (t) { this.data = new Ne(t); }, t.prototype.register = function (t, e, n) { if (this.firstUse && (this.firstUse = !1, mt.get('IS_NODE') && Ct("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n")), this.data.has(t)) throw new Error('Data buffer is already registered'); this.data.set(t, {dtype: n}); }, t.prototype.write = function (t, e) { if (e == null) throw new Error('MathBackendCPU.write(): values can not be null'); this.data.get(t).values = e; }, t.prototype.fromPixels = function (t, e) {
      if (t == null) throw new Error('pixels passed to tf.fromPixels() can not be null'); let n, r;

      if (mt.get('IS_NODE') && t.getContext == null) throw new Error('When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package'); if (t.getContext != null)n = t.getContext('2d').getImageData(0, 0, t.width, t.height).data; else if (t instanceof ImageData)n = t.data; else { if (!(t instanceof HTMLImageElement || t instanceof HTMLVideoElement)) throw new Error(`pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was ${t.constructor.name}`); if (this.canvas == null) throw new Error("Can't read pixels from HTMLImageElement outside the browser."); this.canvas.width = t.width, this.canvas.height = t.height, this.canvas.getContext('2d').drawImage(t, 0, 0, t.width, t.height), n = this.canvas.getContext('2d').getImageData(0, 0, t.width, t.height).data; } if (e === 4)r = new Int32Array(n); else {
        const o = t.width * t.height;

        r = new Int32Array(o * e); for (let i = 0; i < o; i++) for (let a = 0; a < e; ++a)r[i * e + a] = n[4 * i + a];
      }

      return ie(r, [t.height, t.width, e], 'int32');
    }, t.prototype.read = function (e) { return m(this, void 0, void 0, function () { return S(this, function (t) { return [2, this.readSync(e)]; }); }); }, t.prototype.readSync = function (t) {
      const e = this.data.get(t); const n = e.dtype; const r = e.complexTensors;

      return n === 'complex64' ? Oe(r.real.dataSync(), r.imag.dataSync()) : this.data.get(t).values;
    }, t.prototype.disposeData = function (t) {
      if (this.data.has(t)) {
        const e = this.data.get(t).complexTensors;

        e != null && (e.real.dispose(), e.imag.dispose()), this.data.delete(t);
      }
    }, t.prototype.time = function (n) {
      return m(this, void 0, void 0, function () {
        let e;

        return S(this, (t) => e = F(), n(), [2, {kernelMs: F() - e}]);
      });
    }, t.prototype.memory = function () { return {unreliable: !0}; }, t.prototype.complex = function (t, e) {
      const n = Y.make(t.shape, {}, 'complex64');

      return this.data.get(n.dataId).complexTensors = {real: mt.engine.keep(t.clone()), imag: mt.engine.keep(e.clone())}, n;
    }, t.prototype.real = function (t) { return this.data.get(t.dataId).complexTensors.real.clone(); }, t.prototype.imag = function (t) { return this.data.get(t.dataId).complexTensors.imag.clone(); }, t.prototype.assertNotComplex = function (t, e) { Array.isArray(t) || (t = [t]), t.forEach((t) => { t != null && D(t.dtype !== 'complex64', `${e} does not support complex64 tensors.`); }); }, t.prototype.slice = function (t, n, e) {
      this.assertNotComplex(t, 'slice'); for (var r = Wo(e, t.dtype), o = 0; o < r.size; ++o) {
        const i = r.indexToLoc(o); const a = i.map((t, e) => t + n[e]);

        r.set.apply(r, [t.get.apply(t, a)].concat(i));
      }

      return r.toTensor();
    }, t.prototype.stridedSlice = function (t, e, n, r, o, i, a, s, u) {
      this.assertNotComplex(t, 'stridedSlice'); const c = qt(t.shape, e, n, r, o, i, a, s, u); const l = c[0]; const h = c[1]; const p = c[2]; const f = h.filter((t, e) => p.indexOf(e) === -1);

      if (f.some((t) => t === 0)) return ee([], f); for (var d = Wo(h, t.dtype), m = 0; m < d.size; m++) { for (var v = d.indexToLoc(m), g = new Array(v.length), y = 0; y < g.length; y++)g[y] = v[y] * r[y] + l[y]; d.set.apply(d, [t.get.apply(t, g)].concat(v)); }

      return d.toTensor().reshape(f);
    }, t.prototype.reverse = function (r, o) {
      this.assertNotComplex(r, 'reverse'); for (var i = Wo(r.shape, r.dtype), a = r.buffer(), t = function (t) {
          const e = i.indexToLoc(t); const n = e.slice();

          o.forEach((t) => n[t] = r.shape[t] - 1 - n[t]), i.set.apply(i, [a.get.apply(a, n)].concat(e));
        }, e = 0; e < i.size; e++)t(e);

      return i.toTensor();
    }, t.prototype.concat = function (t, n) {
      this.assertNotComplex(t, 'concat'); const e = t.map((t) => {
        const e = B(t.shape.slice(n));

        return t.as2D(-1, e);
      }); const a = zt(e.map((t) => t.shape), 1); const s = Wo(a, t[0].dtype).values;

      if (e[0].shape[0] === 1) {
        let r = 0;

        e.forEach((t) => { s.set(t.dataSync(), r), r += t.size; });
      }
      else {
        let u = 0;

        e.forEach((t) => { for (let e = t.dataSync(), n = 0, r = 0; r < t.shape[0]; ++r) for (let o = r * a[1] + u, i = 0; i < t.shape[1]; ++i)s[o + i] = e[n++]; u += t.shape[1]; });
      } const o = zt(t.map((t) => t.shape), n);

      return ee(s, o, t[0].dtype);
    }, t.prototype.neg = function (t) { return this.assertNotComplex(t, 'neg'), this.multiply(ne(-1), t); }, t.prototype.add = function (t, e) { return t.dtype === 'complex64' || e.dtype === 'complex64' ? this.broadcastedBinaryComplexOp(t.cast('complex64'), e.cast('complex64'), (t, e, n, r) => ({real: t + n, imag: e + r})) : this.broadcastedBinaryOp(t, e, Ie(t.dtype, e.dtype), (t, e) => t + e); }, t.prototype.addN = function (t) {
      this.assertNotComplex(t, 'addN'); for (var e = t.map((t) => t.dataSync()), n = Wo(t[0].shape, t[0].dtype), r = n.values, o = 0; o < t.length; o++) for (let i = e[o], a = 0; a < r.length; a++)r[a] += i[a];

      return n.toTensor();
    }, t.prototype.subtract = function (t, e) { return t.dtype === 'complex64' || e.dtype === 'complex64' ? this.broadcastedBinaryComplexOp(t.cast('complex64'), e.cast('complex64'), (t, e, n, r) => ({real: t - n, imag: e - r})) : this.broadcastedBinaryOp(t, e, Ie(t.dtype, e.dtype), (t, e) => t - e); }, t.prototype.pow = function (t, e) { return this.assertNotComplex([t, e], 'pow'), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => Math.pow(t, e)); }, t.prototype.batchMatMul = function (t, e, n, r) {
      this.assertNotComplex([t, e], 'matMul'); for (var o = n ? t.shape[1] : t.shape[2], i = n ? t.shape[2] : t.shape[1], a = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = t.dataSync(), c = e.dataSync(), l = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], h = l[0], p = l[1], f = l[2], d = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]], m = d[0], v = d[1], g = d[2], y = i * a, x = new Float32Array(s * y), b = this.blockSize, w = 0; w < s; w++) for (let E = 0; E < i; E += b) for (let S = 0; S < a; S += b) for (let _ = 0; _ < o; _ += b) for (let C = Math.min(E + b, i), R = Math.min(S + b, a), T = Math.min(_ + b, o), k = E; k < C; k++) for (let I = S; I < R; I++) { for (var D = 0, N = _; N < T; N++)D += u[w * h + k * p + N * f] * c[N * m + I * v + w * g]; x[w * y + (k * a + I)] += D; }

      return ie(x, [s, i, a]);
    }, t.prototype.multiply = function (t, e) { return t.dtype === 'complex64' || e.dtype === 'complex64' ? this.broadcastedBinaryComplexOp(t.cast('complex64'), e.cast('complex64'), (t, e, n, r) => ({real: t * n - e * r, imag: t * r + e * n})) : this.broadcastedBinaryOp(t, e, Ie(t.dtype, e.dtype), (t, e) => t * e); }, t.prototype.realDivide = function (t, e) { return this.assertNotComplex([t, e], 'realDivide'), this.broadcastedBinaryOp(t, e, 'float32', (t, e) => t / e); }, t.prototype.floorDiv = function (t, e) { return this.assertNotComplex([t, e], 'floorDiv'), this.broadcastedBinaryOp(t, e, 'int32', (t, e) => Math.floor(t / e)); }, t.prototype.sum = function (t, e) {
      this.assertNotComplex(t, 'sum'), Pt('sum', e, t.rank); for (var n = At(t.shape, e), r = n[0], o = n[1], i = le(r, Ie(t.dtype, 'int32')), a = B(o), s = i.dataSync(), u = t.dataSync(), c = 0; c < s.length; ++c) { for (var l = c * a, h = 0, p = 0; p < a; ++p)h += u[l + p]; s[c] = h; }

      return i;
    }, t.prototype.prod = function (t, e) {
      this.assertNotComplex(t, 'sum'); for (var n = At(t.shape, e), r = n[0], o = n[1], i = le(r, Ie(t.dtype, 'int32')), a = B(o), s = i.dataSync(), u = t.dataSync(), c = 0; c < s.length; ++c) { for (var l = c * a, h = 1, p = 0; p < a; ++p)h *= u[l + p]; s[c] = h; }

      return i;
    }, t.prototype.unsortedSegmentSum = function (t, e, n) {
      this.assertNotComplex(t, 'unsortedSegmentSum'); for (var r = [], o = t.rank - e.rank, i = 0; i < o; ++i)e = e.expandDims(i + 1); for (i = 0; i < n; ++i) {
        const a = ne(i, 'int32'); const s = qa(a, e).asType('float32').mul(t).sum(0);

        r.push(s);
      }

      return ci(r);
    }, t.prototype.argMin = function (t, e) {
      this.assertNotComplex(t, 'argMin'); const n = [e];

      Pt('argMin', n, t.rank); for (var r = At(t.shape, n), o = r[0], i = r[1], a = le(o, 'int32'), s = B(i), u = a.dataSync(), c = t.dataSync(), l = 0; l < u.length; ++l) {
        for (var h = l * s, p = c[h], f = 0, d = 0; d < s; ++d) {
          const m = c[h + d];

          m < p && (p = m, f = d);
        }u[l] = f;
      }

      return a;
    }, t.prototype.argMax = function (t, e) {
      this.assertNotComplex(t, 'argMax'); const n = [e];

      Pt('argMax', n, t.rank); for (var r = At(t.shape, n), o = r[0], i = r[1], a = le(o, 'int32'), s = B(i), u = a.dataSync(), c = t.dataSync(), l = 0; l < u.length; ++l) {
        for (var h = l * s, p = c[h], f = 0, d = 0; d < s; ++d) {
          const m = c[h + d];

          p < m && (p = m, f = d);
        }u[l] = f;
      }

      return a;
    }, t.prototype.cumsum = function (t, e, n, r) {
      if (this.assertNotComplex(t, 'cumsum'), e !== t.rank - 1) throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank - 1} but got axis=${e}`); for (var o = Ie(t.dtype, 'int32'), i = le(t.shape, o), a = i.dataSync(), s = t.dataSync(), u = t.shape[t.rank - 1], c = r ? function (t, e) { return t + u - e - 1; } : function (t, e) { return t + e; }, l = 0; l < s.length; l += u) {
        for (let h = 0; h < u; h++) {
          const p = c(l, h);

          if (h === 0)a[p] = n ? 0 : s[p]; else {
            const f = c(l, h - 1);

            a[p] = n ? s[f] + a[f] : s[p] + a[f];
          }
        }
      }

      return i;
    }, t.prototype.equal = function (t, e) { return this.assertNotComplex([t, e], 'equal'), this.broadcastedBinaryOp(t, e, 'bool', (t, e) => (t === e ? 1 : 0)); }, t.prototype.notEqual = function (t, e) { return this.assertNotComplex([t, e], 'notEqual'), this.broadcastedBinaryOp(t, e, 'bool', (t, e) => (t !== e ? 1 : 0)); }, t.prototype.less = function (t, e) { return this.assertNotComplex([t, e], 'less'), this.broadcastedBinaryOp(t, e, 'bool', (t, e) => (t < e ? 1 : 0)); }, t.prototype.lessEqual = function (t, e) { return this.assertNotComplex([t, e], 'lessEqual'), this.broadcastedBinaryOp(t, e, 'bool', (t, e) => (t <= e ? 1 : 0)); }, t.prototype.greater = function (t, e) { return this.assertNotComplex([t, e], 'greater'), this.broadcastedBinaryOp(t, e, 'bool', (t, e) => (e < t ? 1 : 0)); }, t.prototype.greaterEqual = function (t, e) { return this.assertNotComplex([t, e], 'greaterEqual'), this.broadcastedBinaryOp(t, e, 'bool', (t, e) => (e <= t ? 1 : 0)); }, t.prototype.logicalNot = function (t) {
      this.assertNotComplex(t, 'logicalNot'); for (var e = t.dataSync(), n = new Int32Array(e.length), r = 0; r < e.length; ++r)n[r] = e[r] ? 0 : 1;

      return Y.make(t.shape, {values: n}, 'bool');
    }, t.prototype.logicalAnd = function (t, e) { return this.assertNotComplex([t, e], 'logicalAnd'), this.broadcastedBinaryOp(t, e, 'bool', (t, e) => t && e); }, t.prototype.logicalOr = function (t, e) { return this.assertNotComplex([t, e], 'logicalOr'), this.broadcastedBinaryOp(t, e, 'bool', (t, e) => t || e); }, t.prototype.select = function (t, e, n) {
      this.assertNotComplex([t, e, n], 'select'); for (var r = t.dataSync(), o = e.dataSync(), i = n.dataSync(), a = le(e.shape, Ie(e.dtype, n.dtype)), s = a.dataSync(), u = 0, c = t.rank === 0 || t.rank > 1 || e.rank === 1 ? 1 : e.shape[1], l = 0; l < r.length; l++) for (let h = 0; h < c; h++)r[l] === 1 ? s[u++] = o[l] : s[u++] = i[l];

      return a;
    }, t.prototype.where = function (t) {
      this.assertNotComplex([t], 'where'); const e = t.dataSync();

      return fi(t.shape, e);
    }, t.prototype.topk = function (t, e, n) { return this.assertNotComplex(t, 'topk'), Be(t.dataSync(), t.shape, t.dtype, e); }, t.prototype.min = function (t, e) {
      this.assertNotComplex(t, 'min'), Pt('min', e, t.rank); for (var n = At(t.shape, e), r = n[0], o = n[1], i = le(r, t.dtype), a = B(o), s = i.dataSync(), u = t.dataSync(), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
          const f = u[l + p];

          f < h && (h = f);
        }s[c] = h;
      }

      return i;
    }, t.prototype.minimum = function (t, e) { return this.assertNotComplex([t, e], 'minimum'), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => Math.min(t, e)); }, t.prototype.mod = function (t, e) {
      return this.assertNotComplex([t, e], 'mod'), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => {
        const n = t % e;

        return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;
      });
    }, t.prototype.max = function (t, e) {
      this.assertNotComplex(t, 'max'), Pt('max', e, t.rank); for (var n = At(t.shape, e), r = n[0], o = n[1], i = le(r, t.dtype), a = B(o), s = i.dataSync(), u = t.dataSync(), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
          const f = u[l + p];

          h < f && (h = f);
        }s[c] = h;
      }

      return i;
    }, t.prototype.maximum = function (t, e) { return this.assertNotComplex([t, e], 'maximum'), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => Math.max(t, e)); }, t.prototype.all = function (t, e) {
      this.assertNotComplex(t, 'all'), Pt('all', e, t.rank); for (var n = At(t.shape, e), r = n[0], o = n[1], i = le(r, t.dtype), a = B(o), s = i.dataSync(), u = t.dataSync(), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
          const f = u[l + p];

          h = h && f;
        }s[c] = h;
      }

      return i;
    }, t.prototype.any = function (t, e) {
      this.assertNotComplex(t, 'any'), Pt('any', e, t.rank); for (var n = At(t.shape, e), r = n[0], o = n[1], i = le(r, t.dtype), a = B(o), s = i.dataSync(), u = t.dataSync(), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
          const f = u[l + p];

          h = h || f;
        }s[c] = h;
      }

      return i;
    }, t.prototype.squaredDifference = function (t, e) {
      return this.assertNotComplex([t, e], 'squaredDifference'), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => {
        const n = t - e;

        return n * n;
      });
    }, t.prototype.ceil = function (t) {
      this.assertNotComplex(t, 'ceil'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.ceil(e[r]);

      return Y.make(t.shape, {values: n});
    }, t.prototype.floor = function (t) {
      this.assertNotComplex(t, 'floor'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.floor(e[r]);

      return Y.make(t.shape, {values: n});
    }, t.prototype.sign = function (t) {
      this.assertNotComplex(t, 'x'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r)e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;

      return Y.make(t.shape, {values: n});
    }, t.prototype.round = function (t) {
      this.assertNotComplex(t, 'round'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        const o = Math.floor(e[r]);

        e[r] - o < 0.5 ? n[r] = Math.floor(e[r]) : e[r] - o > 0.5 ? n[r] = Math.ceil(e[r]) : n[r] = o % 2 == 0 ? o : o + 1;
      }

      return Y.make(t.shape, {values: n});
    }, t.prototype.exp = function (t) {
      this.assertNotComplex(t, 'exp'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.exp(e[r]);

      return Y.make(t.shape, {values: n});
    }, t.prototype.expm1 = function (t) {
      this.assertNotComplex(t, 'expm1'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.expm1(e[r]);

      return Y.make(t.shape, {values: n});
    }, t.prototype.log = function (t) {
      this.assertNotComplex(t, 'log'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        const o = e[r];

        n[r] = Math.log(o);
      }

      return Y.make(t.shape, {values: n});
    }, t.prototype.log1p = function (t) {
      this.assertNotComplex(t, 'log1p'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        const o = e[r];

        n[r] = Math.log1p(o);
      }

      return Y.make(t.shape, {values: n});
    }, t.prototype.sqrt = function (t) {
      this.assertNotComplex(t, 'sqrt'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        const o = e[r];

        n[r] = Math.sqrt(o);
      }

      return Y.make(t.shape, {values: n});
    }, t.prototype.rsqrt = function (t) {
      this.assertNotComplex(t, 'rsqrt'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        const o = e[r];

        n[r] = 1 / Math.sqrt(o);
      }

      return Y.make(t.shape, {values: n});
    }, t.prototype.square = function (t) {
      this.assertNotComplex(t, 'square'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        const o = e[r];

        n[r] = o * o;
      }

      return Y.make(t.shape, {values: n});
    }, t.prototype.reciprocal = function (t) {
      this.assertNotComplex(t, 'reciprocal'); for (var e = t.dataSync(), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = 1 / e[r];

      return Y.make(t.shape, {values: n});
    }, t.prototype.relu = function (t) {
      this.assertNotComplex(t, 'relu'); for (var e = le(t.shape, t.dtype), n = e.dataSync(), r = t.dataSync(), o = 0; o < r.length; ++o)n[o] = Math.max(0, r[o]);

      return e;
    }, t.prototype.elu = function (t) {
      this.assertNotComplex(t, 'elu'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r) {
        const o = n[r];

        e[r] = o >= 0 ? o : Math.exp(o) - 1;
      }

      return Y.make(t.shape, {values: e});
    }, t.prototype.eluDer = function (t, e) {
      this.assertNotComplex([t, e], 'eluDer'); for (var n = new Float32Array(e.size), r = e.dataSync(), o = t.dataSync(), i = 0; i < r.length; ++i) {
        const a = r[i];

        n[i] = a >= 1 ? o[i] : o[i] * (a + 1);
      }

      return Y.make(e.shape, {values: n});
    }, t.prototype.selu = function (t) {
      this.assertNotComplex(t, 'selu'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r) {
        const o = n[r];

        e[r] = o >= 0 ? 1.0507009873554805 * o : 1.7580993408473768 * (Math.exp(o) - 1);
      }

      return Y.make(t.shape, {values: e});
    }, t.prototype.clip = function (t, e, n) {
      this.assertNotComplex(t, 'clip'); for (var r = new Float32Array(t.size), o = t.dataSync(), i = 0; i < o.length; ++i) {
        const a = o[i];

        r[i] = n < a ? n : a < e ? e : a;
      }

      return Y.make(t.shape, {values: r});
    }, t.prototype.abs = function (t) {
      const e = new Float32Array(t.size); const n = t.dataSync();

      if (t.dtype === 'complex64') {
        for (var r = 0; r < t.size; ++r) {
          const o = n[2 * r]; const i = n[2 * r + 1];

          e[r] = Math.sqrt(o * o + i * i);
        }
      }
      else for (r = 0; r < n.length; ++r)e[r] = Math.abs(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.int = function (t) {
      this.assertNotComplex(t, 'int'); for (var e = new Int32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = n[r];

      return Y.make(t.shape, {values: e}, 'int32');
    }, t.prototype.sigmoid = function (t) {
      this.assertNotComplex(t, 'sigmoid'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = 1 / (1 + Math.exp(-n[r]));

      return Y.make(t.shape, {values: e});
    }, t.prototype.softplus = function (t) {
      this.assertNotComplex(t, 'softplus'); for (var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = t.dataSync(), o = 0; o < r.length; ++o) {
        var i; const a = r[o] > -e; const s = r[o] < e; const u = Math.exp(r[o]);

        i = s ? u : a ? r[o] : Math.log(1 + u), n[o] = i;
      }

      return Y.make(t.shape, {values: n});
    }, t.prototype.sin = function (t) {
      this.assertNotComplex(t, 'sin'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.sin(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.cos = function (t) {
      this.assertNotComplex(t, 'cos'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.cos(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.tan = function (t) {
      this.assertNotComplex(t, 'tan'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.tan(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.asin = function (t) {
      this.assertNotComplex(t, 'asin'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.asin(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.acos = function (t) {
      this.assertNotComplex(t, 'acos'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.acos(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.atan = function (t) {
      this.assertNotComplex(t, 'atan'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.atan(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.atan2 = function (t, e) { return this.assertNotComplex([t, e], 'atan2'), this.broadcastedBinaryOp(t, e, t.dtype, (t, e) => Math.atan2(t, e)); }, t.prototype.sinh = function (t) {
      this.assertNotComplex(t, 'sinh'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.sinh(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.cosh = function (t) {
      this.assertNotComplex(t, 'cosh'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.cosh(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.tanh = function (t) {
      this.assertNotComplex(t, 'tanh'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = h(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.asinh = function (t) {
      this.assertNotComplex(t, 'asinh'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.asinh(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.acosh = function (t) {
      this.assertNotComplex(t, 'acosh'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.acosh(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.atanh = function (t) {
      this.assertNotComplex(t, 'atanh'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r)e[r] = Math.atanh(n[r]);

      return Y.make(t.shape, {values: e});
    }, t.prototype.erf = function (t) {
      this.assertNotComplex(t, 'erf'); for (var e = new Float32Array(t.size), n = t.dataSync(), r = 0; r < n.length; ++r) {
        const o = n[r]; const i = 1 / (1 + 0.3275911 * o);

        e[r] = 1 - ((((1.061405429 * i - 1.453152027) * i + 1.421413741) * i - 0.284496736) * i + 0.254829592) * i * Math.exp(-o * o);
      }

      return Y.make(t.shape, {values: e});
    }, t.prototype.step = function (t, e) {
      void 0 === e && (e = 0), this.assertNotComplex(t, 'step'); for (var n = new Float32Array(t.size), r = t.dataSync(), o = 0; o < r.length; ++o) {
        const i = r[o];

        isNaN(i) ? n[o] = NaN : n[o] = i > 0 ? 1 : e;
      }

      return Y.make(t.shape, {values: n});
    }, t.prototype.conv2d = function (t, e, n) {
      this.assertNotComplex([t, e], 'conv2d'); for (var r = n.filterHeight, o = n.filterWidth, i = n.dilationHeight, a = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = Wo(n.outShape, t.dtype), l = t.dataSync(), h = e.dataSync(), p = c.values, f = 0; f < n.batchSize; ++f) {
        for (let d = f * t.strides[0], m = f * c.strides[0], v = 0; v < n.outHeight; ++v) {
          for (let g = m + v * c.strides[1], y = v * n.strideHeight - s, x = 0; x < r; x++) {
            const b = y + x * i;

            if (!(b < 0 || b >= n.inHeight)) {
              for (let w = x * e.strides[0], E = d + b * t.strides[1], S = 0; S < n.outWidth; ++S) {
for (let _ = g + S * n.outChannels, C = S * n.strideWidth - u, R = 0; R < o; R++) {
 const T = C + R * a;

                if (!(T < 0 || T >= n.inWidth)) for (let k = w + R * e.strides[1], I = E + T * n.inChannels, D = k, N = 0; N < n.inChannels; ++N) { for (let A = l[I + N], M = 0; M < n.outChannels; ++M)p[_ + M] += A * h[D + M]; D += n.outChannels; } 
} } }
          }
        }
      }

      return c.toTensor();
    }, t.prototype.conv2dDerInput = function (t, e, n) {
      this.assertNotComplex([t, e], 'conv2dDerInput'); for (var r = Wo(n.inShape, 'float32'), o = r.values, i = r.strides, a = i[0], s = i[1], u = i[2], c = t.dataSync(), l = t.strides, h = l[0], p = l[1], f = l[2], d = e.dataSync(), m = e.strides, v = m[0], g = m[1], y = m[2], x = n.batchSize, b = n.filterHeight, w = n.filterWidth, E = n.inChannels, S = n.inHeight, _ = n.inWidth, C = n.outChannels, R = n.outHeight, T = n.outWidth, k = n.strideHeight, I = n.strideWidth, D = b - 1 - n.padInfo.top, N = w - 1 - n.padInfo.left, A = 0; A < x; ++A) for (let M = 0; M < E; ++M) for (let O = 0; O < S; ++O) for (let P = O - D, F = Math.max(0, Math.ceil(P / k)), L = Math.min(R, (b + P) / k), B = 0; B < _; ++B) { for (var z = B - N, W = Math.max(0, Math.ceil(z / I)), U = Math.min(T, (w + z) / I), V = 0, G = F; G < L; ++G) for (let q = G * k - P, j = W; j < U; ++j) for (let H = h * A + p * G + f * j, $ = v * (b - 1 - q) + g * (w - 1 - (j * I - z)) + y * M, K = 0; K < C; ++K)V += c[H + K] * d[$ + K]; o[a * A + s * O + u * B + M] = V; }

      return r.toTensor();
    }, t.prototype.conv2dDerFilter = function (t, e, n) {
      this.assertNotComplex([t, e], 'conv2dDerFilter'); for (var r = n.strideHeight, o = n.strideWidth, i = n.filterHeight, a = n.filterWidth, s = Wo(n.filterShape, 'float32'), u = n.padInfo.left, c = n.padInfo.top, l = 0; l < i; ++l) {
        for (let h = Math.max(0, Math.ceil((c - l) / r)), p = Math.min(n.outHeight, (n.inHeight + c - l) / r), f = 0; f < a; ++f) {
          for (let d = Math.max(0, Math.ceil((u - f) / o)), m = Math.min(n.outWidth, (n.inWidth + u - f) / o), v = 0; v < n.inChannels; ++v) {
            for (let g = 0; g < n.outChannels; ++g) {
              for (var y = 0, x = 0; x < n.batchSize; ++x) {
 for (let b = h; b < p; ++b) { for (let w = l + b * r - c, E = d; E < m; ++E) {
 let S = f + E * o - u;

                y += t.get(x, w, S, v) * e.get(x, b, E, g); 
}
}
}s.set(y, l, f, v, g);
            }
          }
        }
      }

      return s.toTensor();
    }, t.prototype.depthwiseConv2D = function (t, e, n) {
      this.assertNotComplex([t, e], 'depthwiseConv2D'); for (var r = n.filterHeight, o = n.filterWidth, i = n.dilationHeight, a = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = n.outChannels / n.inChannels, l = Wo(n.outShape, t.dtype), h = t.dataSync(), p = e.dataSync(), f = l.values, d = 0; d < n.batchSize; ++d) {
        for (let m = d * t.strides[0], v = d * l.strides[0], g = 0; g < n.outHeight; ++g) {
          for (let y = v + g * l.strides[1], x = g * n.strideHeight - s, b = 0; b < r; ++b) {
            const w = x + b * i;

            if (!(w < 0 || w >= n.inHeight)) {
              for (let E = b * e.strides[0], S = m + w * t.strides[1], _ = 0; _ < n.outWidth; ++_) { for (let C = y + _ * l.strides[2], R = _ * n.strideWidth - u, T = 0; T < o; ++T) {
 const k = R + T * a;

                if (!(k < 0 || k >= n.inWidth)) for (let I = E + T * e.strides[1], D = S + k * n.inChannels, N = C, A = I, M = 0; M < n.inChannels; ++M) { for (let O = h[D + M], P = 0; P < c; ++P)f[N + P] += O * p[A + P]; N += c, A += c; } 
} } }
          }
        }
      }

      return l.toTensor();
    }, t.prototype.depthwiseConv2DDerInput = function (t, e, n) {
      this.assertNotComplex([t, e], 'depthwiseConv2DDerInput'); for (var r = Wo(n.inShape, 'float32'), o = r.values, i = r.strides, a = i[0], s = i[1], u = i[2], c = t.dataSync(), l = t.strides, h = l[0], p = l[1], f = l[2], d = e.dataSync(), m = e.strides, v = m[0], g = m[1], y = m[2], x = n.batchSize, b = n.filterHeight, w = n.filterWidth, E = n.inChannels, S = n.inHeight, _ = n.inWidth, C = n.outChannels, R = n.outHeight, T = n.outWidth, k = n.strideHeight, I = n.strideWidth, D = b - 1 - n.padInfo.top, N = w - 1 - n.padInfo.left, A = C / E, M = 0; M < x; ++M) for (let O = 0; O < E; ++O) for (let P = 0; P < S; ++P) for (let F = P - D, L = Math.max(0, Math.ceil(F / k)), B = Math.min(R, (b + F) / k), z = 0; z < _; ++z) { for (var W = z - N, U = Math.max(0, Math.ceil(W / I)), V = Math.min(T, (w + W) / I), G = 0, q = L; q < B; ++q) for (let j = q * k - F, H = U; H < V; ++H) for (let $ = h * M + p * q + f * H, K = v * (b - 1 - j) + g * (w - 1 - (H * I - W)) + y * O, X = 0; X < A; ++X)G += c[$ + (O * A + X)] * d[K + X]; o[a * M + s * P + u * z + O] = G; }

      return r.toTensor();
    }, t.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
      this.assertNotComplex([t, e], 'depthwiseConv2DDerFilter'); for (var r = n.strideHeight, o = n.strideWidth, i = n.filterHeight, a = n.filterWidth, s = Wo(n.filterShape, 'float32'), u = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = 0; h < i; ++h) {
        for (let p = Math.max(0, Math.ceil((c - h) / r)), f = Math.min(n.outHeight, (n.inHeight + c - h) / r), d = 0; d < a; ++d) {
          for (let m = Math.max(0, Math.ceil((u - d) / o)), v = Math.min(n.outWidth, (n.inWidth + u - d) / o), g = 0; g < n.outChannels; ++g) {
            for (var y = Math.trunc(g / l), x = g % l, b = 0, w = 0; w < n.batchSize; ++w) {
 for (let E = p; E < f; ++E) { for (let S = h + E * r - c, _ = m; _ < v; ++_) {
 const C = d + _ * o - u;

              b += t.get(w, S, C, y) * e.get(w, E, _, g); 
} }
}s.set(b, h, d, y, x);
          }
        }
      }

      return s.toTensor();
    }, t.prototype.tile = function (t, e) {
      this.assertNotComplex(t, 'tile'); for (var n = new Array(t.rank), r = 0; r < n.length; r++)n[r] = t.shape[r] * e[r]; const o = Wo(n, t.dtype); const i = t.buffer();

      for (r = 0; r < o.values.length; ++r) {
        for (var a = o.indexToLoc(r), s = new Array(t.rank), u = 0; u < s.length; u++)s[u] = a[u] % t.shape[u]; const c = i.locToIndex(s);

        o.values[r] = i.values[c];
      }

      return o.toTensor();
    }, t.prototype.pad = function (n, t, e) {
      this.assertNotComplex(n, 'pad'); const r = t.map((t, e) => t[0] + n.shape[e] + t[1]); const o = t.map((t) => t[0]); const i = n.buffer(); const a = Wo(r, n.dtype);

      e !== 0 && a.values.fill(e); for (let s = 0; s < n.size; s++) {
        const u = i.indexToLoc(s); const c = u.map((t, e) => t + o[e]);

        a.set.apply(a, [n.get.apply(n, u)].concat(c));
      }

      return a.toTensor();
    }, t.prototype.transpose = function (t, e) {
      this.assertNotComplex(t, 'transpose'); for (var n = new Array(t.rank), r = 0; r < n.length; r++)n[r] = t.shape[e[r]]; const o = t.dataSync(); const i = Wo(n, t.dtype); const a = t.buffer();

      for (r = 0; r < t.size; ++r) {
        for (var s = a.indexToLoc(r), u = new Array(s.length), c = 0; c < u.length; c++)u[c] = s[e[c]]; const l = i.locToIndex(u);

        i.values[l] = o[r];
      }

      return i.toTensor();
    }, t.prototype.gather = function (t, e, n) {
      this.assertNotComplex([t, e], 'gather'); const r = t.shape.slice(); const o = e.dataSync();

      r[n] = o.length; for (var i = Wo(r, t.dtype), a = t.buffer(), s = 0; s < i.size; ++s) {
        const u = i.indexToLoc(s); const c = u.slice();

        c[n] = o[u[n]]; const l = a.locToIndex(c);

        i.values[s] = a.values[l];
      }

      return i.toTensor();
    }, t.prototype.batchToSpaceND = function (t, e, n) {
      this.assertNotComplex([t], 'batchToSpaceND'); const r = e.reduce((t, e) => t * e); const o = Rt(t.shape, e, r); const i = Tt(o.length, e.length); const a = kt(t.shape, e, r); const s = It(n, e.length); const u = Dt(a, n, e.length);

      return t.reshape(o).transpose(i).reshape(a).slice(s, u);
    }, t.prototype.spaceToBatchND = function (t, e, n) {
      this.assertNotComplex([t], 'spaceToBatchND'); const r = e.reduce((t, e) => t * e); const o = [[0, 0]];

      o.push.apply(o, n); for (let i = 1 + e.length; i < t.shape.length; ++i)o.push([0, 0]); const a = t.pad(o); const s = Rt(a.shape, e, r, !1); const u = Tt(s.length, e.length, !1); const c = kt(a.shape, e, r, !1);

      return a.reshape(s).transpose(u).reshape(c);
    }, t.prototype.pool = function (t, e, n) {
      this.assertNotComplex(t, 'pool'); for (var r = e.strideHeight, o = e.strideWidth, i = e.dilationHeight, a = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = Wo(e.outShape, 'float32'), l = e.padInfo.top, h = e.padInfo.left, p = n === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f = 0; f < e.batchSize; ++f) {
        for (let d = 0; d < e.inChannels; ++d) {
          for (let m = 0; m < e.outHeight; ++m) {
            for (let v = m * r - l, g = Math.max(0, v), y = Math.min(e.inHeight, s + v), x = 0; x < e.outWidth; ++x) {
              for (var b = x * o - h, w = Math.max(0, b), E = Math.min(e.inWidth, u + b), S = p, _ = 0, C = 0, R = g; R < y; R += i) {
                for (let T = w; T < E; T += a) {
                  let k = t.get(f, R, T, d);

                  "max" === n && S < k ? S = k : n === 'avg' && (_ += k, C++);
                } if (isNaN(S)) break;
              }c.set(n === 'avg' ? _ / C : S, f, m, x, d);
            }
          }
        }
      }

      return c.toTensor();
    }, t.prototype.maxPool = function (t, e) { return this.pool(t, e, 'max'); }, t.prototype.maxPoolPositions = function (t, e) {
      for (var n = Wo(e.outShape, 'int32'), r = e.strideHeight, o = e.strideWidth, i = e.dilationHeight, a = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = 0; h < e.batchSize; ++h) {
        for (let p = 0; p < e.inChannels; ++p) {
          for (let f = 0; f < e.outHeight; ++f) {
            for (var d = f * r - c, m = d; m < 0;)m += i; for (let v = Math.min(e.inHeight, s + d), g = 0; g < e.outWidth; ++g) {
              for (var y = g * o - l, x = y; x < 0;)x += a; for (var b = Math.min(e.inWidth, u + y), w = Number.NEGATIVE_INFINITY, E = -1, S = m; S < v; S += i) {
                for (let _ = S - d, C = x; C < b; C += a) {
                  const R = C - y; const T = t.get(h, S, C, p);

                  w < T && (w = T, E = _ * u + R);
                }
              }n.set(E, h, f, g, p);
            }
          }
        }
      }

      return n.toTensor();
    }, t.prototype.maxPoolBackprop = function (t, e, n, r) {
      this.assertNotComplex([e, n], 'maxPoolBackprop'); for (var o = this.maxPoolPositions(e, r), i = r.strideHeight, a = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, c = r.effectiveFilterHeight, l = r.effectiveFilterWidth, h = l - 1 - r.padInfo.left, p = c - 1 - r.padInfo.top, f = Wo(e.shape, 'float32'), d = 0; d < r.batchSize; ++d) {
        for (let m = 0; m < r.inChannels; ++m) {
          for (let v = 0; v < r.inHeight; ++v) {
            for (let g = 0; g < r.inWidth; ++g) {
              for (var y = v - p, x = g - h, b = 0, w = 0; w < c; w += s) {
                const E = (y + w) / i;

                if (!(E < 0 || E >= r.outHeight || Math.floor(E) !== E)) {
 for (let S = 0; S < l; S += u) {
                  let _ = (x + S) / a;

                  if (!(_ < 0 || _ >= r.outWidth || Math.floor(_) !== _)) {
                    let C = c * l - 1 - o.get(d, E, _, m) === w * l + S ? 1 : 0;

                    C !== 0 && (b += t.get(d, E, _, m) * C);
                  }
                } 
}
              }f.set(b, d, v, g, m);
            }
          }
        }
      }

      return f.toTensor();
    }, t.prototype.avgPoolBackprop = function (t, e, n) {
      this.assertNotComplex([t, e], 'avgPoolBackprop'); for (var r = n.strideHeight, o = n.strideWidth, i = n.filterHeight, a = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, p = c - 1 - n.padInfo.top, f = Wo(e.shape, 'float32'), d = 1 / (i * a), m = 0; m < n.batchSize; ++m) {
        for (let v = 0; v < n.inChannels; ++v) {
          for (let g = 0; g < n.inHeight; ++g) {
            for (let y = 0; y < n.inWidth; ++y) {
              for (var x = g - p, b = y - h, w = 0, E = 0; E < c; E += s) {
                let S = (x + E) / r;

                if (!(S < 0 || S >= n.outHeight || Math.floor(S) !== S)) { for (let _ = 0; _ < l; _ += u) {
 const C = (b + _) / o;

                  C < 0 || C >= n.outWidth || Math.floor(C) !== C || (w += t.get(m, S, C, v)); 
}
}
              }f.set(w * d, m, g, y, v);
            }
          }
        }
      }

      return f.toTensor();
    }, t.prototype.cast = function (t, e) { return Ae(t, e, this); }, t.prototype.reshape = function (t, e) { return Me(t, e); }, t.prototype.avgPool = function (t, e) { return this.assertNotComplex(t, 'avgPool'), this.pool(t, e, 'avg').toFloat(); }, t.prototype.resizeBilinear = function (t, e, n, r) {
      this.assertNotComplex(t, 'resizeBilinear'); for (var o = t.shape, i = o[0], a = o[1], s = o[2], u = o[3], c = t.dataSync(), l = new Float32Array(B([i, e, n, u])), h = [r && e > 1 ? a - 1 : a, r && n > 1 ? s - 1 : s], p = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = 0, d = h[0] / p[0], m = h[1] / p[1], v = 0; v < i; v++) {
        for (let g = 0; g < e; g++) {
          for (let y = d * g, x = Math.floor(y), b = y - x, w = Math.min(a - 1, Math.ceil(y)), E = v * t.strides[0] + x * t.strides[1], S = v * t.strides[0] + w * t.strides[1], _ = 0; _ < n; _++) {
 for (let C = m * _, R = Math.floor(C), T = C - R, k = Math.min(s - 1, Math.ceil(C)), I = E + R * t.strides[2], D = S + R * t.strides[2], N = E + +k * t.strides[2], A = S + k * t.strides[2], M = 0; M < u; M++) {
            const O = c[I + M]; const P = c[D + M]; const F = O + (c[N + M] - O) * T; const L = F + (P + (c[A + M] - P) * T - F) * b;

            l[f++] = L;
          }
          } 
}
      }

      return ee(l, [i, e, n, u]);
    }, t.prototype.resizeBilinearBackprop = function (t, e, n) {
      this.assertNotComplex([t, e], 'resizeBilinearBackprop'); for (var r = e.shape, o = r[0], i = r[1], a = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * i * a * s), p = [n && c > 1 ? i - 1 : i, n && l > 1 ? a - 1 : a], f = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], d = p[0] / f[0], m = p[1] / f[1], v = t.dataSync(), g = 0, y = 0; y < o; y++) {
        for (let x = y * e.strides[0], b = 0; b < c; b++) {
          for (let w = b * d, E = Math.floor(w), S = Math.min(Math.ceil(w), i - 1), _ = x + E * e.strides[1], C = x + S * e.strides[1], R = w - E, T = 1 - R, k = 0; k < l; k++) {
 for (let I = k * m, D = Math.floor(I), N = Math.min(Math.ceil(I), a - 1), A = I - D, M = 1 - A, O = _ + D * e.strides[2], P = _ + N * e.strides[2], F = C + D * e.strides[2], L = C + N * e.strides[2], B = T * M, z = T * A, W = R * M, U = R * A, V = 0; V < s; V++) {
            const G = v[g++];

            h[O + V] += G * B, h[P + V] += G * z, h[F + V] += G * W, h[L + V] += G * U;
          } 
} 
}
      }

      return ae(h, [o, a, i, s], e.dtype);
    }, t.prototype.resizeNearestNeighbor = function (t, e, n, r) {
      this.assertNotComplex(t, 'resizeNearestNeighbor'); for (var o = t.shape, i = o[0], a = o[1], s = o[2], u = o[3], c = t.dataSync(), l = new Float32Array(i * e * n * u), h = [r && e > 1 ? a - 1 : a, r && n > 1 ? s - 1 : s], p = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = h[0] / p[0], d = h[1] / p[1], m = 0, v = 0; v < i; v++) {
        for (let g = v * t.strides[0], y = 0; y < e; y++) {
          for (let x = f * y, b = g + Math.min(a - 1, r ? Math.round(x) : Math.floor(x)) * t.strides[1], w = 0; w < n; w++) {
            for (let E = d * w, S = b + Math.min(s - 1, r ? Math.round(E) : Math.floor(E)) * t.strides[2], _ = 0; _ < u; _++) {
              const C = c[S + _];

              l[m++] = C;
            }
          }
        }
      }

      return ee(l, [i, e, n, u], t.dtype);
    }, t.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
      this.assertNotComplex([t, e], 'resizeNearestNeighborBackprop'); for (var r = e.shape, o = r[0], i = r[1], a = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * i * a * s), p = t.dataSync(), f = [n && c > 1 ? i - 1 : i, n && l > 1 ? a - 1 : a], d = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], m = f[0] / d[0], v = f[1] / d[1], g = 1 / m, y = 1 / v, x = 2 * Math.ceil(g) + 2, b = 2 * Math.ceil(y) + 2, w = 0; w < o; w++) {
        for (let E = w * e.strides[0], S = 0; S < i; S++) {
          for (let _ = E + S * e.strides[1], C = Math.floor(S * g), R = Math.floor(C - x / 2), T = 0; T < a; T++) {
            for (let k = _ + T * e.strides[2], I = Math.floor(T * y), D = Math.floor(I - b / 2), N = 0; N < s; N++) {
              for (var A = 0, M = 0; M < x; M++) {
                const O = M + R;

                if (!(O < 0 || c <= O)) {
                  const P = E + O * t.strides[1]; const F = O * m;

                  if (S === Math.min(i - 1, n ? Math.round(F) : Math.floor(F))) {
                    for (let L = 0; L < b; L++) {
                      let B = L + D;

                      if (!(B < 0 || l <= B)) {
 const z = P + B * t.strides[2]; const W = B * v;

                        T === Math.min(a - 1, n ? Math.round(W) : Math.floor(W)) && (A += p[z + N]); 
}
                    }
                  }
                }
              }h[k + N] = A;
            }
          }
        }
      }

      return ae(h, e.shape, e.dtype);
    }, t.prototype.batchNormalization = function (t, e, n, r, o, i) {
      this.assertNotComplex([t, e, n, o, i], 'batchNormalization'); for (var a = t.dataSync(), s = e.dataSync(), u = n.dataSync(), c = o ? o.dataSync() : new Float32Array([1]), l = i ? i.dataSync() : new Float32Array([0]), h = new Float32Array(a.length), p = l.length, f = c.length, d = u.length, m = s.length, v = 0, g = 0, y = 0, x = 0, b = 0; b < a.length; ++b)h[b] = l[v++] + (a[b] - s[g++]) * c[y++] / Math.sqrt(u[x++] + r), p <= v && (v = 0), m <= g && (g = 0), f <= y && (y = 0), d <= x && (x = 0);

      return ae(h, t.shape);
    }, t.prototype.localResponseNormalization4D = function (t, a, e, n, r) {
      this.assertNotComplex(t, 'localResponseNormalization4D'); const s = t.shape[3]; const u = s - 1; const c = t.dataSync(); const o = B(t.shape); const i = new Float32Array(o);

      function l(t) {
        for (var e = t % s, n = t - e + Math.max(0, e - a), r = t - e + Math.min(e + a, u), o = 0; n <= r; n++) {
          const i = c[n];

          o += i * i;
        }

        return o;
      } for (let h = 0; h < o; h++) {
        const p = l(h); const f = c[h] * Math.pow(e + n * p, -r);

        i[h] = f;
      }

      return ae(i, t.shape);
    }, t.prototype.LRNGrad = function (t, e, n, r, o, i, a) {
      this.assertNotComplex(t, 'LRNGrad'); for (var s = t.shape[3], u = t.dataSync(), c = e.dataSync(), l = n.dataSync(), h = new Float32Array(B(t.shape)), p = B(t.shape), f = 0; f < p; f++) {
        for (var d = f % s, m = f - d + Math.max(0, d - r), v = f - d + Math.min(s, d + r + 1), g = 0, y = m; y < v; y++)g += Math.pow(c[y], 2); for (g = i * g + o, y = m; y < v; y++) {
          let x = -2 * i * a * c[y] * l[f] / g;

          f === y && (x += Math.pow(g, -a)), x *= u[f], h[y] += x;
        }
      }

      return ae(h, t.shape);
    }, t.prototype.multinomial = function (t, e, n, r) {
      this.assertNotComplex(t, 'multinomial'); for (var o = e ? t : Qt(t), i = o.shape[0], a = o.shape[1], s = le([i, n], 'int32'), u = s.dataSync(), c = o.dataSync(), l = 0; l < i; ++l) {
        const h = l * a; const p = new Float32Array(a - 1);

        p[0] = c[h]; for (let f = 1; f < p.length; ++f)p[f] = p[f - 1] + c[h + f]; for (let d = Lo(r.toString()), m = l * n, v = 0; v < n; ++v) {
          const g = d();

          u[m + v] = p.length; for (let y = 0; y < p.length; y++) if (g < p[y]) { u[m + v] = y; break; }
        }
      }

      return s;
    }, t.prototype.oneHot = function (t, e, n, r) {
      this.assertNotComplex(t, 'oneHot'); const o = new Float32Array(t.size * e);

      o.fill(r); for (let i = 0; i < t.size; ++i)t.get(i) >= 0 && t.get(i) < e && (o[i * e + t.get(i)] = n);

      return oe(o, [t.size, e], 'int32');
    }, t.prototype.nonMaxSuppression = function (t, e, n, r, o) { return this.assertNotComplex(t, 'nonMaxSuppression'), Pe(t.dataSync(), e.dataSync(), n, r, o); }, t.prototype.fft = function (t) {
      if (t.shape[0] !== 1) throw new Error('tf.fft() on CPU only supports vectors.'); const e = t.as1D(); const n = e.size;

      if (this.isExponentOf2(n)) return this.fftRadix2(e, n).as2D(t.shape[0], t.shape[1]); const r = t.dataSync(); const o = (function (t) {
        for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2)e[r / 2] = t[r], n[r / 2] = t[r + 1];

        return {real: e, imag: n};
      }(this.fourierTransformByMatmul(r, n)));

      return Jt(o.real, o.imag).as2D(t.shape[0], t.shape[1]);
    }, t.prototype.isExponentOf2 = function (t) { return (t & t - 1) == 0; }, t.prototype.fftRadix2 = function (t, e) {
      if (e === 1) return t; const n = t.dataSync(); const r = e / 2; const o = (function (t) {
        for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 0; o < t.length; o += 4)n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];

        return {real: n, imag: r};
      }(n)); let i = Jt(o.real, o.imag).as1D(); const a = (function (t) {
        for (var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 2; o < t.length; o += 4)n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];

        return {real: n, imag: r};
      }(n)); let s = Jt(a.real, a.imag).as1D();

      i = this.fftRadix2(i, r), s = this.fftRadix2(s, r); const u = (function (t) {
        for (var e = new Float32Array(t / 2), n = new Float32Array(t / 2), r = 0; r < Math.ceil(t / 2); r++) {
          const o = -2 * Math.PI * (r / t);

          e[r] = Math.cos(o), n[r] = Math.sin(o);
        }

        return {real: e, imag: n};
      }(e)); const c = Jt(u.real, u.imag).mul(s); const l = i.add(c); const h = i.sub(c); const p = Zt(l).concat(Zt(h)); const f = te(l).concat(te(h));

      return Jt(p, f).as1D();
    }, t.prototype.fourierTransformByMatmul = function (t, e) {
      for (var n = new Float32Array(2 * e), r = 0; r < e; r++) {
        for (var o = 0, i = 0, a = 0; a < e; a++) {
          const s = (m = r * a, v = e, void 0, g = -2 * Math.PI * (m / v), {real: Math.cos(g), imag: Math.sin(g)}); const u = {real: (f = t)[2 * (d = a)], imag: f[2 * d + 1]};

          o += u.real * s.real - u.imag * s.imag, i += u.real * s.imag + u.imag * s.real;
        }l = o, h = i, (c = n)[2 * (p = r)] = l, c[2 * p + 1] = h;
      } let c, l, h, p, f, d, m, v, g;

      return n;
    }, t.prototype.depthToSpace = function (t, e, n) {
      D(n === 'NHWC', `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${n}`), D(e > 1, `blockSize should be > 1 for depthToSpace, but was: ${e}`); for (var r = t.shape[0], o = t.shape[1], i = t.shape[2], a = t.shape[3], s = o * e, u = i * e, c = a / (e * e), l = t.dataSync(), h = new Float32Array(r * s * u * c), p = 0, f = 0; f < r; ++f) {
        for (let d = 0; d < s; ++d) {
          for (let m = Math.floor(d / e), v = d % e, g = 0; g < u; ++g) {
            for (let y = Math.floor(g / e), x = (v * e + g % e) * c, b = 0; b < c; ++b) {
              const w = b + x + a * (y + i * (m + o * f));

              h[p++] = l[w];
            }
          }
        }
      }

      return ae(h, [r, s, u, c]);
    }, t.prototype.broadcastedBinaryOp = function (a, s, t, u) {
      const e = Ge(a.shape, s.shape); const c = Wo(e, t); const l = a.dataSync(); const h = s.dataSync(); const p = Ue(a.shape, e); const f = Ue(s.shape, e); const d = c.values;

      if (p.length + f.length === 0) for (var n = 0; n < d.length; ++n)d[n] = u(l[n % l.length], h[n % h.length]); else {
        const m = a.buffer(); const v = s.buffer(); const r = function (t) {
          const e = c.indexToLoc(t); const n = e.slice(-a.rank);

          p.forEach((t) => n[t] = 0); const r = m.locToIndex(n); const o = e.slice(-s.rank);

          f.forEach((t) => o[t] = 0); const i = v.locToIndex(o);

          d[t] = u(l[r], h[i]);
        };

        for (n = 0; n < d.length; ++n)r(n);
      }

      return c.toTensor();
    }, t.prototype.broadcastedBinaryComplexOp = function (s, u, c) {
      const t = Ge(s.shape, u.shape); const l = Wo(t, 'float32'); const e = Wo(t, 'float32'); const h = s.dataSync(); const p = u.dataSync(); const f = Ue(s.shape, t); const d = Ue(u.shape, t); const m = l.values; const v = e.values;

      if (f.length + d.length === 0) {
        for (var n = 0; n < m.length; n++) {
          const r = n % h.length; const o = n % p.length; const i = c(h[2 * r], h[2 * r + 1], p[2 * o], p[2 * o + 1]);

          m[n] = i.real, v[n] = i.imag;
        }
      }
      else {
        const g = this.data.get(s.dataId).complexTensors.real.buffer(); const y = this.data.get(u.dataId).complexTensors.real.buffer(); const a = function (t) {
          const e = l.indexToLoc(t); const n = e.slice(-s.rank);

          f.forEach((t) => n[t] = 0); const r = g.locToIndex(n); const o = e.slice(-u.rank);

          d.forEach((t) => o[t] = 0); const i = y.locToIndex(o); const a = c(h[2 * r], h[2 * r + 1], p[2 * i], p[2 * i + 1]);

          m[t] = a.real, v[t] = a.imag;
        };

        for (n = 0; n < m.length; n++)a(n);
      }

      return this.complex(l.toTensor(), e.toTensor());
    }, t.prototype.split = function (t, e, n) { return Le(t, e, n); }, t.prototype.dispose = function () {}, t.prototype.floatPrecision = function () { return 32; }, t.prototype.cropAndResize = function (t, e, n, r, o, i) {
      for (var a = t.shape, s = a[0], u = a[1], c = a[2], l = a[3], h = e.shape[0], p = r[0], f = r[1], d = Wo([h, p, f, l]), m = e.dataSync(), v = n.dataSync(), g = t.dataSync(), y = t.strides, x = d.strides, b = 0; b < h; b++) {
        const w = 4 * b; const E = m[w]; const S = m[w + 1]; const _ = m[w + 2]; const C = m[w + 3]; const R = v[b];

        if (!(s <= R)) {
          for (let T = p > 1 ? (_ - E) * (u - 1) / (p - 1) : 0, k = f > 1 ? (C - S) * (c - 1) / (f - 1) : 0, I = 0; I < p; I++) {
            const D = p > 1 ? E * (u - 1) + I * T : 0.5 * (E + _) * (u - 1);

            if (D < 0 || u - 1 < D) {
              for (var N = 0; N < f; N++) {
                for (var A = 0; A < l; A++) {
                  var M = A + N * x[2] + I * x[1] + b * x[0];

                  d.values[M] = i;
                }
              } 
}
            else if (o === 'bilinear') {
              const O = Math.floor(D); const P = Math.ceil(D); const F = D - O;

              for (N = 0; N < f; N++) {
                if ((j = f > 1 ? S * (c - 1) + N * k : 0.5 * (S + C) * (c - 1)) < 0 || c - 1 < j) for (A = 0; A < l; A++)M = A + N * x[2] + I * x[1] + b * x[0], d.values[M] = i; else {
                  const L = Math.floor(j); const B = Math.ceil(j); const z = j - L;

                  for (A = 0; A < l; A++) {
                    const W = g[M = A + L * y[2] + O * y[1] + R * y[0]]; const U = g[M = A + B * y[2] + O * y[1] + R * y[0]]; const V = g[M = A + L * y[2] + P * y[1] + R * y[0]]; const G = W + (U - W) * z; const q = V + (g[M = A + B * y[2] + P * y[1] + R * y[0]] - V) * z;

                    M = A + N * x[2] + I * x[1] + b * x[0], d.values[M] = G + (q - G) * F;
                  }
                }
              }
            }
            else {
              for (N = 0; N < f; ++N) {
                var j;

                if ((j = f > 1 ? S * (c - 1) + N * k : 0.5 * (S + C) * (c - 1)) < 0 || c - 1 < j) for (A = 0; A < l; A++)M = A + N * x[2] + I * x[1] + b * x[0], d.values[M] = i; else {
                  const H = Math.round(j); const $ = Math.round(D);

                  for (A = 0; A < l; A++) {
                    const K = A + H * y[2] + $ * y[1] + R * y[0]; const X = A + N * x[2] + I * x[1] + b * x[0];

                    d.values[X] = g[K];
                  }
                }
              }
            }
          }
        }
      }

      return d.toTensor();
    }, t.prototype.sparseToDense = function (t, e, n, r) {
      const o = Gt(0, t, n); const i = o.sliceRank; const a = o.numUpdates; const s = o.sliceSize; const u = o.strides; const c = o.outputSize;

      return this.scatter(t, e, n, c, s, a, i, u, r, !1);
    }, t.prototype.gatherND = function (t, e) {
      const n = e.shape; const r = n[n.length - 1]; const o = Wt(t, e); const i = o[0]; const a = o[1]; const s = o[2]; const u = o[3];

      if (a === 0) return ee([], i, t.dtype); for (var c = new H([a, s], t.dtype), l = e.dataSync(), h = t.dataSync(), p = 0; p < a; p++) {
        for (var f = [], d = 0, m = 0; m < r; m++) {
          const v = l[p * r + m];

          d += v * u[m], f.push(v);
        } if (d < 0 || d >= t.size / s) throw new Error(`Invalid indices: ${f} does not index into ${t.shape}`); for (let g = 0; g < s; g++)c.values[p * s + g] = h[d * s + g];
      }

      return c.toTensor().reshape(i);
    }, t.prototype.scatterND = function (t, e, n) {
      const r = Gt(0, t, n); const o = r.sliceRank; const i = r.numUpdates; const a = r.sliceSize; const s = r.strides; const u = r.outputSize; const c = ne(0);

      return this.scatter(t, e, n, u, a, i, o, s, c, !0);
    }, t.prototype.scatter = function (t, e, n, r, o, i, a, s, u, c) {
      const l = [r / o, o]; const h = t.dataSync(); const p = e.dataSync();

      if (r === 0) return ee([], n, e.dtype); const f = new H(l, e.dtype);

      f.values.fill(u.dataSync()[0]); for (let d = 0; d < i; d++) {
        for (var m = [], v = 0, g = 0; g < a; g++) {
          const y = h[d * a + g];

          m.push(y), v += y * s[g];
        } if (v < 0 || r / o <= v) throw new Error(`Invalid indices: ${m} does not index into ${n}`); for (let x = 0; x < o; x++)c ? f.values[v * o + x] += p[d * o + x] : f.values[v * o + x] = e.rank === 0 ? p[0] : p[d * o + x];
      }

      return f.toTensor().reshape(n);
    }, t;
  }());

  mt.registerBackend('cpu', () => new wu(), 1, X); const Eu = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setImmediate; const Su = {
    float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1
  };

  function _u(p, t) {
    for (var f = {}, d = 0, e = function (t) {
        const e = t.name; const n = t.dtype; const r = t.shape; const o = B(r); let i = void 0;

        if ('quantization' in t) {
          const a = t.quantization;

          if (a.dtype !== 'uint8' && a.dtype !== 'uint16') throw new Error(`Weight ${t.name} has unknown quantization dtype ${a.dtype}. Supported quantization dtypes are: 'uint8' and 'uint16'.`); const s = Su[a.dtype]; var u = p.slice(d, d + o * s); const c = a.dtype === 'uint8' ? new Uint8Array(u) : new Uint16Array(u);

          if (n === 'float32')i = Float32Array.from(c, (t) => t * a.scale + a.min); else { if (n !== 'int32') throw new Error(`Unsupported dtype in weight '${e}': ${n}`); i = Int32Array.from(c, (t) => Math.round(t * a.scale + a.min)); }d += o * s;
        }
        else {
          const l = Su[n];

          if (u = p.slice(d, d + o * l), n === 'float32')i = new Float32Array(u); else if (n === 'int32')i = new Int32Array(u); else { if (n !== 'bool') throw new Error(`Unsupported dtype in weight '${e}': ${n}`); i = new Uint8Array(u); }d += o * l;
        } let h = void 0;

        if (n === 'float32')h = ee(i, r, 'float32'); else if (n === 'int32')h = ee(i, r, 'int32'); else { if (n !== 'bool') throw new Error(`Unsupported dtype in weight '${e}': ${n}`); h = ee(i, r, 'bool'); }f[e] = h;
      }, n = 0, r = t; n < r.length; n++)e(r[n]);

    return f;
  } const Cu = typeof Buffer !== 'undefined' && (typeof Blob === 'undefined' || typeof atob === 'undefined' || typeof btoa === 'undefined');

  function Ru(t) { return Cu ? Buffer.byteLength(t) : new Blob([t]).size; } function Tu(t) {
    let e = 0;

    t.forEach((t) => { e += t.byteLength; }); const n = new Uint8Array(e); let r = 0;

    return t.forEach((t) => { n.set(new Uint8Array(t), r), r += t.byteLength; }), n.buffer;
  } function ku(t) {
    for (t = t.trim(); t.endsWith('/');)t = t.slice(0, t.length - 1); const e = t.split('/');

    return e[e.length - 1];
  } function Iu(t) {
    if (t.modelTopology instanceof ArrayBuffer) throw new Error('Expected JSON model topology, received ArrayBuffer.');

    return {
      dateSaved: new Date(), modelTopologyType: 'JSON', modelTopologyBytes: t.modelTopology == null ? 0 : Ru(JSON.stringify(t.modelTopology)), weightSpecsBytes: t.weightSpecs == null ? 0 : Ru(JSON.stringify(t.weightSpecs)), weightDataBytes: t.weightData == null ? 0 : t.weightData.byteLength
    };
  } const Du = (function () {
    function e() { this.saveRouters = [], this.loadRouters = []; }

    return e.getInstance = function () { return e.instance == null && (e.instance = new e()), e.instance; }, e.registerSaveRouter = function (t) { e.getInstance().saveRouters.push(t); }, e.registerLoadRouter = function (t) { e.getInstance().loadRouters.push(t); }, e.getSaveHandlers = function (t) { return e.getHandlers(t, 'save'); }, e.getLoadHandlers = function (t) { return e.getHandlers(t, 'load'); }, e.getHandlers = function (n, t) {
      const r = [];

      return (t === 'load' ? this.getInstance().loadRouters : this.getInstance().saveRouters).forEach((t) => {
        const e = t(n);

        e !== null && r.push(e);
      }), r;
    }, e;
  }()); const Nu = '://'; const Au = (function () {
    function r() { this.managers = {}; }

    return r.getInstance = function () { return r.instance == null && (r.instance = new r()), r.instance; }, r.registerManager = function (t, e) {
      D(t != null, 'scheme must not be undefined or null.'), t.endsWith(Nu) && (t = t.slice(0, t.indexOf(Nu))), D(t.length > 0, 'scheme must not be an empty string.'); const n = r.getInstance();

      D(n.managers[t] == null, `A model store manager is already registered for scheme '${t}'.`), n.managers[t] = e;
    }, r.getManager = function (t) {
      const e = this.getInstance().managers[t];

      if (e == null) throw new Error(`Cannot find model manager for scheme '${t}'`);

      return e;
    }, r.getSchemes = function () { return Object.keys(this.getInstance().managers); }, r;
  }());

  function Mu(t) {
    if (t.indexOf(Nu) === -1) throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Au.getSchemes().join(',')}`);

    return {scheme: t.split(Nu)[0], path: t.split(Nu)[1]};
  } function Ou(l, h, p) {
    return void 0 === p && (p = !1), m(this, void 0, void 0, function () {
      let e, n, r, o, i, a, s, u, c;

      return S(this, (t) => { switch (t.label) { case 0: return D(l !== h, `Old path and new path are the same: '${l}'`), D((e = Du.getLoadHandlers(l)).length > 0, `Copying failed because no load handler is found for source URL ${l}.`), D(e.length < 2, `Copying failed because more than one (${e.length}) load handlers for source URL ${l}.`), n = e[0], D((r = Du.getSaveHandlers(h)).length > 0, `Copying failed because no save handler is found for destination URL ${h}.`), D(r.length < 2, `Copying failed because more than one (${e.length}) save handlers for destination URL ${h}.`), o = r[0], i = Mu(l).scheme, a = Mu(l).path, s = i === Mu(l).scheme, [4, n.load()]; case 1: return u = t.sent(), p && s ? [4, Au.getManager(i).removeModel(a)] : [3, 3]; case 2: t.sent(), t.label = 3; case 3: return [4, o.save(u)]; case 4: return c = t.sent(), !p || s ? [3, 6] : [4, Au.getManager(i).removeModel(a)]; case 5: t.sent(), t.label = 6; case 6: return [2, c.modelArtifactsInfo]; } });
    });
  } const Pu = 'tensorflowjs'; const Fu = 'models_store'; const Lu = 'model_info_store';

  function Bu() {
    if (!mt.get('IS_BROWSER')) throw new Error('Failed to obtain IndexedDB factory because the current environmentis not a web browser.'); const t = window; const e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;

    if (e == null) throw new Error('The current browser does not appear to support IndexedDB.');

    return e;
  } function zu(t) {
    const e = t.result;

    e.createObjectStore(Fu, {keyPath: 'modelPath'}), e.createObjectStore(Lu, {keyPath: 'modelPath'});
  } const Wu = (function () {
    function t(t) { if (this.indexedDB = Bu(), t == null || !t) throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.'); this.modelPath = t; }

    return t.prototype.save = function (e) {
      return m(this, void 0, void 0, function () {
        return S(this, function (t) {
          if (e.modelTopology instanceof ArrayBuffer) throw new Error('BrowserLocalStorage.save() does not support saving model topology in binary formats yet.');

          return [2, this.databaseAction(this.modelPath, e)];
        });
      });
    }, t.prototype.load = function () { return m(this, void 0, void 0, function () { return S(this, function (t) { return [2, this.databaseAction(this.modelPath)]; }); }); }, t.prototype.databaseAction = function (t, h) {
      const p = this;

      return new Promise(((u, c) => {
        const l = p.indexedDB.open(Pu, 1);

        l.onupgradeneeded = function () { return zu(l); }, l.onsuccess = function () {
          const r = l.result;

          if (h == null) {
            const t = r.transaction(Fu, 'readonly'); const e = t.objectStore(Fu).get(p.modelPath);

            e.onsuccess = function () { if (e.result == null) return r.close(), c(new Error(`Cannot find model with path '${p.modelPath}' in IndexedDB.`)); u(e.result.modelArtifacts); }, e.onerror = function (t) { return r.close(), c(e.error); }, t.oncomplete = function () { return r.close(); };
          }
          else {
            let o; const i = Iu(h); const a = r.transaction(Lu, 'readwrite'); let s = a.objectStore(Lu); const n = s.put({modelPath: p.modelPath, modelArtifactsInfo: i});

            n.onsuccess = function () {
              const n = (o = r.transaction(Fu, 'readwrite')).objectStore(Fu).put({modelPath: p.modelPath, modelArtifacts: h, modelArtifactsInfo: i});

              n.onsuccess = function () { return u({modelArtifactsInfo: i}); }, n.onerror = function (t) {
                const e = (s = a.objectStore(Lu)).delete(p.modelPath);

                e.onsuccess = function () { return r.close(), c(n.error); }, e.onerror = function (t) { return r.close(), c(n.error); };
              };
            }, n.onerror = function (t) { return r.close(), c(n.error); }, a.oncomplete = function () { o == null ? r.close() : o.oncomplete = function () { return r.close(); }; };
          }
        }, l.onerror = function (t) { return c(l.error); };
      }));
    }, t.URL_SCHEME = 'indexeddb://', t;
  }()); const Uu = function (t) { return mt.get('IS_BROWSER') && !Array.isArray(t) && t.startsWith(Wu.URL_SCHEME) ? (e = t.slice(Wu.URL_SCHEME.length), new Wu(e)) : null; let e; };

  Du.registerSaveRouter(Uu), Du.registerLoadRouter(Uu); const Vu = (function () {
    function t() { this.indexedDB = Bu(); }

    return t.prototype.listModels = function () {
      return m(this, void 0, void 0, function () {
        const e = this;

        return S(this, (t) => [2, new Promise(((i, n) => {
          const r = e.indexedDB.open(Pu, 1);

          r.onupgradeneeded = function () { return zu(r); }, r.onsuccess = function () {
            const e = r.result; const t = e.transaction(Lu, 'readonly'); const o = t.objectStore(Lu).getAll();

            o.onsuccess = function () {
              for (var t = {}, e = 0, n = o.result; e < n.length; e++) {
                const r = n[e];

                t[r.modelPath] = r.modelArtifactsInfo;
              }i(t);
            }, o.onerror = function (t) { return e.close(), n(o.error); }, t.oncomplete = function () { return e.close(); };
          }, r.onerror = function (t) { return n(r.error); };
        }))]);
      });
    }, t.prototype.removeModel = function (u) {
      return m(this, void 0, void 0, function () {
        const n = this;

        return S(this, (t) => {
          return u = (e = u).startsWith(Wu.URL_SCHEME) ? e.slice(Wu.URL_SCHEME.length) : e, [2, new Promise(((a, s) => {
            const e = n.indexedDB.open(Pu, 1);

            e.onupgradeneeded = function () { return zu(e); }, e.onsuccess = function () {
              let n; const r = e.result; const t = r.transaction(Lu, 'readwrite'); const o = t.objectStore(Lu); const i = o.get(u);

              i.onsuccess = function () {
                if (i.result == null) return r.close(), s(new Error(`Cannot find model with path '${u}' in IndexedDB.`)); const t = o.delete(u); const e = function () {
                  const t = (n = r.transaction(Fu, 'readwrite')).objectStore(Fu).delete(u);

                  t.onsuccess = function () { return a(i.result.modelArtifactsInfo); }, t.onerror = function (t) { return s(i.error); };
                };

                t.onsuccess = e, t.onerror = function (t) { return e(), r.close(), s(i.error); };
              }, i.onerror = function (t) { return r.close(), s(i.error); }, t.oncomplete = function () { n == null ? r.close() : n.oncomplete = function () { return r.close(); }; };
            }, e.onerror = function (t) { return s(e.error); };
          }))]; let e;
        });
      });
    }, t;
  }());

  if (mt.get('IS_BROWSER')) {
    try { Au.registerManager(Wu.URL_SCHEME, new Vu()); }
    catch (t) {}
  } const Gu = '/'; const qu = 'tensorflowjs_models'; const ju = 'info'; const Hu = 'model_topology'; const $u = 'weight_specs'; const Ku = 'weight_data';

  function Xu(t) {
    return {
      info: [qu, t, ju].join(Gu), topology: [qu, t, Hu].join(Gu), weightSpecs: [qu, t, $u].join(Gu), weightData: [qu, t, Ku].join(Gu)
    };
  } function Yu(t) {
    const e = t.split(Gu);

    if (e.length < 3) throw new Error(`Invalid key format: ${t}`);

    return e.slice(1, e.length - 1).join(Gu);
  } const Qu = (function () {
    function t(t) { if (!mt.get('IS_BROWSER') || void 0 === window.localStorage) throw new Error('The current environment does not support local storage.'); if (this.LS = window.localStorage, t == null || !t) throw new Error('For local storage, modelPath must not be null, undefined or empty.'); this.modelPath = t, this.keys = Xu(this.modelPath); }

    return t.prototype.save = function (a) {
      return m(this, void 0, void 0, function () {
        let n, r, o, i;

        return S(this, function (t) {
          if (a.modelTopology instanceof ArrayBuffer) throw new Error('BrowserLocalStorage.save() does not support saving model topology in binary formats yet.'); n = JSON.stringify(a.modelTopology), r = JSON.stringify(a.weightSpecs), o = Iu(a); try { return this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, n), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, (e = a.weightData, Cu ? Buffer.from(e).toString('base64') : btoa(String.fromCharCode.apply(null, new Uint8Array(e))))), [2, {modelArtifactsInfo: o}]; }
          catch (t) { for (i in this.keys) this.LS.removeItem(this.keys[i]); throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`); } let e;

          return [2];
        });
      });
    }, t.prototype.load = function () {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i;

        return S(this, function (t) {
          if ((e = JSON.parse(this.LS.getItem(this.keys.info))) == null) throw new Error(`In local storage, there is no model with name '${this.modelPath}'`); if (e.modelTopologyType !== 'JSON') throw new Error('BrowserLocalStorage does not support loading non-JSON model topology yet.'); if (n = {}, (r = JSON.parse(this.LS.getItem(this.keys.topology))) == null) throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`); if (n.modelTopology = r, (o = JSON.parse(this.LS.getItem(this.keys.weightSpecs))) == null) throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`); if (n.weightSpecs = o, (i = this.LS.getItem(this.keys.weightData)) == null) throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);

          return n.weightData = (function (t) {
            if (Cu) {
              const e = Buffer.from(t, 'base64');

              return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
            } for (var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o)r.set([n.charCodeAt(o)], o);

            return r.buffer;
          }(i)), [2, n];
        });
      });
    }, t.URL_SCHEME = 'localstorage://', t;
  }()); const Ju = function (t) { return mt.get('IS_BROWSER') && !Array.isArray(t) && t.startsWith(Qu.URL_SCHEME) ? (e = t.slice(Qu.URL_SCHEME.length), new Qu(e)) : null; let e; };

  Du.registerSaveRouter(Ju), Du.registerLoadRouter(Ju); const Zu = (function () {
    function t() { D(mt.get('IS_BROWSER'), 'Current environment is not a web browser'), D(void 0 !== window.localStorage, 'Current browser does not appear to support localStorage'), this.LS = window.localStorage; }

    return t.prototype.listModels = function () {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i, a;

        return S(this, function (t) {
          for (e = {}, n = qu + Gu, r = Gu + ju, o = 0; o < this.LS.length; ++o)(i = this.LS.key(o)).startsWith(n) && i.endsWith(r) && (a = Yu(i), e[a] = JSON.parse(this.LS.getItem(i)));

          return [2, e];
        });
      });
    }, t.prototype.removeModel = function (o) {
      return m(this, void 0, void 0, function () {
        let n, r;

        return S(this, function (t) {
          if (o = (e = o).startsWith(Qu.URL_SCHEME) ? e.slice(Qu.URL_SCHEME.length) : e, n = Xu(o), this.LS.getItem(n.info) == null) throw new Error(`Cannot find model at path '${o}'`); let e;

          return r = JSON.parse(this.LS.getItem(n.info)), this.LS.removeItem(n.info), this.LS.removeItem(n.topology), this.LS.removeItem(n.weightSpecs), this.LS.removeItem(n.weightData), [2, r];
        });
      });
    }, t;
  }());

  if (mt.get('IS_BROWSER')) {
    try { Au.registerManager(Qu.URL_SCHEME, new Zu()); }
    catch (t) {}
  } const tc = (function () {
    function e(t) { if (!mt.get('IS_BROWSER')) throw new Error('triggerDownloads() cannot proceed because the current environment is not a browser.'); t.startsWith(e.URL_SCHEME) && (t = t.slice(e.URL_SCHEME.length)), t != null && t.length !== 0 || (t = 'model'), this.modelTopologyFileName = `${t}.json`, this.weightDataFileName = `${t}.weights.bin`; }

    return e.prototype.save = function (s) {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i, a;

        return S(this, function (t) {
          if (e = window.URL.createObjectURL(new Blob([s.weightData], {type: 'application/octet-stream'})), s.modelTopology instanceof ArrayBuffer) throw new Error('DownloadTrigger.save() does not support saving model topology in binary formats yet.');

          return n = [{paths: [`./${this.weightDataFileName}`], weights: s.weightSpecs}], r = {modelTopology: s.modelTopology, weightsManifest: n}, o = window.URL.createObjectURL(new Blob([JSON.stringify(r)], {type: 'application/json'})), (i = this.jsonAnchor == null ? document.createElement('a') : this.jsonAnchor).download = this.modelTopologyFileName, i.href = o, i.click(), s.weightData != null && ((a = this.weightDataAnchor == null ? document.createElement('a') : this.weightDataAnchor).download = this.weightDataFileName, a.href = e, a.click()), [2, {modelArtifactsInfo: Iu(s)}];
        });
      });
    }, e.URL_SCHEME = 'downloads://', e;
  }()); const ec = (function () {
    function t(t) { if (t == null || t.length < 1) throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`); this.files = t; }

    return t.prototype.load = function () {
      return m(this, void 0, void 0, function () {
        let r; let h; const p = this;

        return S(this, function (t) {
          return r = this.files[0], h = this.files.slice(1), [2, new Promise(((c, l) => {
            const t = new FileReader();

            t.onload = function (t) {
              const e = JSON.parse(t.target.result); const o = e.modelTopology;

              if (o != null) {
                h.length === 0 && c({modelTopology: o}); const n = e.weightsManifest;

                if (n != null) {
                  let i;

                  try { i = p.checkManifestAndWeightFiles(n, h); }
                  catch (t) { return void l(t); } const a = []; const s = []; const u = [];

                  n.forEach((t) => { t.paths.forEach((t) => { s.push(t), u.push(null); }), a.push.apply(a, t.weights); }), n.forEach((t) => {
                    t.paths.forEach((r) => {
                      const t = new FileReader();

                      t.onload = function (t) {
                        const e = t.target.result; const n = s.indexOf(r);

                        u[n] = e, u.indexOf(null) === -1 && c({modelTopology: o, weightSpecs: a, weightData: Tu(u)});
                      }, t.onerror = function (t) { l(`Failed to weights data from file of path '${r}'.`); }, t.readAsArrayBuffer(i[r]);
                    });
                  });
                }
                else l(new Error(`weightManifest field is missing from file ${r.name}`));
              }
              else l(new Error(`modelTopology field is missing from file ${r.name}`));
            }, t.onerror = function (t) { l(`Failed to read model topology and weights manifest JSON from file '${r.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`); }, t.readAsText(r);
          }))];
        });
      });
    }, t.prototype.checkManifestAndWeightFiles = function (t, n) {
      for (var r = [], o = n.map((t) => ku(t.name)), i = {}, e = 0, a = t; e < a.length; e++) {
        a[e].paths.forEach((t) => {
          const e = ku(t);

          if (r.indexOf(e) !== -1) throw new Error(`Duplicate file basename found in weights manifest: '${e}'`); if (r.push(e), o.indexOf(e) === -1) throw new Error(`Weight file with basename '${e}' is not provided.`); i[t] = n[o.indexOf(e)];
        });
      } if (r.length !== n.length) throw new Error(`Mismatch in the number of files in weights manifest (${r.length}) and the number of weight files provided (${n.length}).`);

      return i;
    }, t;
  }());

  function nc(r, o) {
    return m(this, void 0, void 0, function () {
      let e, n;

      return S(this, (t) => { switch (t.label) { case 0: return e = r.map((t) => fetch(t, o)), [4, Promise.all(e)]; case 1: return n = t.sent(), [4, Promise.all(n.map((t) => t.arrayBuffer()))]; case 2: return [2, t.sent()]; } });
    });
  }Du.registerSaveRouter((t) => { return mt.get('IS_BROWSER') && !Array.isArray(t) && t.startsWith(tc.URL_SCHEME) ? (void 0 === (e = t.slice(tc.URL_SCHEME.length)) && (e = 'model'), new tc(e)) : null; let e; }); const rc = (function () {
    function t(t, e) { if (this.DEFAULT_METHOD = 'POST', typeof fetch === 'undefined') throw new Error('browserHTTPRequest is not supported outside the web browser without a fetch polyfill.'); if (D(t != null && t.length > 0, 'URL path for browserHTTPRequest must not be null, undefined or empty.'), Array.isArray(t) && D(t.length === 2, `URL paths for browserHTTPRequest must have a length of 2, (actual length is ${t.length}).`), this.path = t, e != null && e.body != null) throw new Error('requestInit is expected to have no pre-existing body, but has one.'); this.requestInit = e || {}; }

    return t.prototype.save = function (i) {
      return m(this, void 0, void 0, function () {
        let e, n, r, o;

        return S(this, function (t) {
          switch (t.label) {
            case 0: if (i.modelTopology instanceof ArrayBuffer) throw new Error('BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.');

              return (e = Object.assign({method: this.DEFAULT_METHOD}, this.requestInit)).body = new FormData(), n = [{paths: ['./model.weights.bin'], weights: i.weightSpecs}], r = {modelTopology: i.modelTopology, weightsManifest: n}, e.body.append('model.json', new Blob([JSON.stringify(r)], {type: 'application/json'}), 'model.json'), i.weightData != null && e.body.append('model.weights.bin', new Blob([i.weightData], {type: 'application/octet-stream'}), 'model.weights.bin'), [4, fetch(this.path, e)]; case 1: if ((o = t.sent()).status === 200) return [2, {modelArtifactsInfo: Iu(i), responses: [o]}]; throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`);
          }
        });
      });
    }, t.prototype.load = function () { return m(this, void 0, void 0, function () { return S(this, function (t) { return [2, Array.isArray(this.path) ? this.loadBinaryModel() : this.loadJSONModel()]; }); }); }, t.prototype.loadBinaryTopology = function () {
      return m(this, void 0, void 0, function () {
        let e;

        return S(this, function (t) { switch (t.label) { case 0: return t.trys.push([0, 3,, 4]), [4, fetch(this.path[0], this.requestInit)]; case 1: return [4, t.sent().arrayBuffer()]; case 2: return [2, t.sent()]; case 3: throw e = t.sent(), new Error(`${this.path[0]} not found. ${e}`); case 4: return [2]; } });
      });
    }, t.prototype.loadBinaryModel = function () {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s, u;

        return S(this, function (t) { switch (t.label) { case 0: return e = this.loadBinaryTopology(), [4, fetch(this.path[1], this.requestInit)]; case 1: return n = t.sent(), [4, Promise.all([e, n])]; case 2: return r = t.sent(), o = r[0], [4, r[1].json()]; case 3: return (i = t.sent()) == null ? [3, 5] : [4, this.loadWeights(i)]; case 4: u = t.sent(), a = u[0], s = u[1], t.label = 5; case 5: return [2, {modelTopology: o, weightSpecs: a, weightData: s}]; } });
      });
    }, t.prototype.loadJSONModel = function () {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s;

        return S(this, function (t) {
          switch (t.label) {
            case 0: return [4, fetch(this.path, this.requestInit)]; case 1: return [4, t.sent().json()]; case 2: if (e = t.sent(), n = e.modelTopology, r = e.weightsManifest, n == null && r == null) throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);

              return r == null ? [3, 4] : (a = e.weightsManifest, [4, this.loadWeights(a)]); case 3: s = t.sent(), o = s[0], i = s[1], t.label = 4; case 4: return [2, {modelTopology: n, weightSpecs: o, weightData: i}];
          }
        });
      });
    }, t.prototype.loadWeights = function (l) {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s, u, c;

        return S(this, function (t) {
          switch (t.label) {
            case 0: for (e = Array.isArray(this.path) ? this.path[1] : this.path, n = [], r = 0, o = l; r < o.length; r++)i = o[r], n.push.apply(n, i.weights);

              return (a = e.substring(0, e.lastIndexOf('/'))).endsWith('/') || (a += '/'), s = [], l.forEach((t) => { t.paths.forEach((t) => { s.push(a + t); }); }), u = [n], c = Tu, [4, nc(s, this.requestInit)]; case 1: return [2, u.concat([c.apply(void 0, [t.sent()])])];
          }
        });
      });
    }, t.URL_SCHEME_REGEX = /^https?:\/\//, t;
  }());

  function oc(t) { return t.match(rc.URL_SCHEME_REGEX) != null; } const ic = function (t) { return typeof fetch === 'undefined' ? null : (Array.isArray(t) ? t.every((t) => oc(t)) : oc(t)) ? ac(t) : null; };

  function ac(t, e) { return new rc(t, e); }Du.registerSaveRouter(ic), Du.registerLoadRouter(ic); const sc = (function () {
    function t(t, e, n) { this.modelTopology = t, this.weightSpecs = e, this.weightData = n; }

    return t.prototype.load = function () {
      return m(this, void 0, void 0, function () {
        let e;

        return S(this, function (t) { return e = {}, this.modelTopology != null && (e = n({modelTopology: this.modelTopology}, e)), this.weightSpecs != null && this.weightSpecs.length > 0 && (e = n({weightSpecs: this.weightSpecs}, e)), this.weightData != null && this.weightData.byteLength > 0 && (e = n({weightData: this.weightData}, e)), [2, e]; });
      });
    }, t;
  }()); const uc = (function () {
    function t(t) { this.saveHandler = t; }

    return t.prototype.save = function (e) { return m(this, void 0, void 0, function () { return S(this, function (t) { return [2, this.saveHandler(e)]; }); }); }, t;
  }()); const cc = Du.registerSaveRouter; const lc = Du.registerLoadRouter; const hc = Du.getSaveHandlers; const pc = Du.getLoadHandlers; const fc = Object.freeze({
    browserFiles(t) { return new ec(t); },
    browserHTTPRequest: ac,
    concatenateArrayBuffers: Tu,
    decodeWeights: _u,
    encodeWeights(i) {
      return m(this, void 0, void 0, function () {
        let e, n, r, o;

        return S(this, (t) => {
          switch (t.label) {
            case 0: for (r in e = [], n = [], i) { if ((o = i[r]).dtype !== 'float32' && o.dtype !== 'int32' && o.dtype !== 'bool') throw new Error(`Unsupported dtype in weight '${r}': ${o.dtype}`); e.push({name: r, shape: o.shape, dtype: o.dtype}), n.push(o.data()); }

              return [4, Promise.all(n)]; case 1: return [2, {
              data: (function (t) {
                if (t === null) throw new Error(`Invalid input value: ${JSON.stringify(t)}`); let e = 0; const n = [];

                t.forEach((t) => { if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`); }); const r = new Uint8Array(e); let o = 0;

                return n.forEach((t) => { r.set(new Uint8Array(t.buffer), o), o += t.byteLength; }), r.buffer;
              }(t.sent())),
              specs: e
            }];
          }
        });
      });
    },
    fromMemory(t, e, n) { return new sc(t, e, n); },
    getLoadHandlers: pc,
    getModelArtifactsInfoForJSON: Iu,
    getSaveHandlers: hc,
    loadWeights(f, o, d, i) {
      return void 0 === o && (o = ''), m(this, void 0, void 0, function () {
        let a, c, s, u, e, n, r, l, h, p;

        return S(this, (t) => {
          switch (t.label) {
            case 0: if (a = f.map(() => !1), c = {}, s = d != null ? d.map(() => !1) : [], u = [], f.forEach((t, o) => {
              let i = 0;

              t.weights.forEach((n) => {
                const t = 'quantization' in n ? n.quantization.dtype : n.dtype; const e = Su[t] * B(n.shape); const r = function () { a[o] = !0, c[o] == null && (c[o] = []), c[o].push({manifestEntry: n, groupOffset: i, sizeBytes: e}); };

                d != null ? d.forEach((t, e) => { t === n.name && (r(), s[e] = !0); }) : r(), u.push(n.name), i += e;
              });
            }), !s.every((t) => t)) throw e = d.filter((t, e) => !s[e]), new Error(`Could not find weights in manifest with names: ${e.join(', ')}. \nManifest JSON has weights with names: ${u.join(', ')}.`);

              return n = a.reduce((t, e, n) => e && t.push(n), t, []), r = [], n.forEach((t) => {
                f[t].paths.forEach((t) => {
                  const e = o + (o.endsWith('/') ? '' : '/') + t;

                  r.push(e);
                });
              }), [4, nc(r, i)]; case 1: return l = t.sent(), h = {}, p = 0, n.forEach((t) => {
              for (var e = f[t].paths.length, n = 0, r = 0; r < e; r++)n += l[p + r].byteLength; for (var o = new ArrayBuffer(n), i = new Uint8Array(o), a = 0, s = 0; s < e; s++) {
                const u = new Uint8Array(l[p + s]);

                i.set(u, a), a += u.byteLength;
              }c[t].forEach((t) => {
                const e = _u(o.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry]);

                for (const n in e)h[n] = e[n];
              }), p += e;
            }), [2, h];
          }
        });
      });
    },
    registerLoadRouter: lc,
    registerSaveRouter: cc,
    withSaveHandler(t) { return new uc(t); },
    copyModel(e, n) { return m(this, void 0, void 0, function () { return S(this, (t) => { switch (t.label) { case 0: return [4, Ou(e, n, !1)]; case 1: return [2, t.sent()]; } }); }); },
    listModels() {
      return m(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s;

        return S(this, (t) => { switch (t.label) { case 0: e = Au.getSchemes(), n = {}, r = 0, o = e, t.label = 1; case 1: return r < o.length ? (i = o[r], [4, Au.getManager(i).listModels()]) : [3, 4]; case 2: for (s in a = t.sent())n[i + Nu + s] = a[s]; t.label = 3; case 3: return r++, [3, 1]; case 4: return [2, n]; } });
      });
    },
    moveModel(e, n) { return m(this, void 0, void 0, function () { return S(this, (t) => { switch (t.label) { case 0: return [4, Ou(e, n, !0)]; case 1: return [2, t.sent()]; } }); }); },
    removeModel(n) {
      return m(this, void 0, void 0, function () {
        let e;

        return S(this, (t) => { switch (t.label) { case 0: return e = Mu(n), [4, Au.getManager(e.scheme).removeModel(e.path)]; case 1: return [2, t.sent()]; } });
      });
    }
  }); const dc = Yt({
    confusionMatrix_(t, e, n) {
      const r = Kt(t, 'label', 'confusionMatrix', 'int32'); const o = Kt(e, 'label', 'confusionMatrix', 'int32');

      D(n == null || n > 0 && Number.isInteger(n), `If provided, numClasses must be a positive integer, but got ${n}`), D(r.rank === 1, `Expected the rank of labels to be 1, but got ${r.rank}`), D(o.rank === 1, `Expected the rank of predictions to be 1, but got ${o.rank}`), D(r.shape[0] === o.shape[0], `Mismatch in the number of examples: ${r.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`), D(n > 0 && Number.isInteger(n), `numClasses is required to be a positive integer, but got ${n}`); const i = Qo(r, n); const a = Qo(o, n);

      return i.transpose().matMul(a);
    }
  }); const mc = Object.freeze({confusionMatrix: dc}); const vc = (function () {
    function t() {}

    return t.prototype.getClassName = function () { return this.constructor.className; }, t.fromConfig = function (t, e) { return new t(e); }, t;
  }()); const gc = (function () {
    function e() { this.classNameMap = {}; }

    return e.getMap = function () { return e.instance == null && (e.instance = new e()), e.instance; }, e.register = function (t) { e.getMap().classNameMap[t.className] = [t, t.fromConfig]; }, e;
  }());

  function yc(t) { D(t.className != null, 'Class being registered does not have the static className property defined.'), D(typeof t.className === 'string', `className is required to be a string, but got type ${typeof t.className}`), D(t.className.length > 0, 'Class being registered has an empty-string as its className, which is disallowed.'), gc.register(t); } const xc = Object.freeze({Serializable: vc, SerializationMap: gc, registerClass: yc});

  function bc(t, e, n) {
    if (n == null && (n = mt.get('TEST_EPSILON')), t instanceof Y || e instanceof Y) { if (t instanceof Y && e instanceof Y) { if (t.dtype !== e.dtype) throw new Error(`Arrays are of different type actual: ${t.dtype} vs expected: ${e.dtype}.`); if (!T(t.shape, e.shape)) throw new Error(`Arrays are of different shape actual: ${t.shape} vs expected: ${e.shape}.`); } }
    else {
      const r = t.constructor.name; const o = e.constructor.name;

      if (r !== o) throw new Error(`Arrays are of different type actual: ${r} vs expected: ${o}`);
    } let i, a;

    if (i = t instanceof Y ? t.dataSync() : t, a = e instanceof Y ? e.dataSync() : e, i.length !== a.length) throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${a.length}.\nActual:   ${i}.\nExpected: ${a}.`); for (let s = 0; s < a.length; ++s) {
      const u = i[s]; const c = a[s];

      if (!wc(u, Number(c), n)) throw new Error(`Arrays differ: actual[${s}] = ${u}, expected[${s}] = ${c}.\nActual:   ${i}.\nExpected: ${a}.`);
    }
  } function wc(t, e, n) { return !(!isNaN(t) || !isNaN(e)) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n); } const Ec = Object.freeze({
    WEBGL_ENVS: {HAS_WEBGL: !0},
    NODE_ENVS: {IS_NODE: !0},
    CHROME_ENVS: {IS_CHROME: !0},
    BROWSER_ENVS: {IS_BROWSER: !0},
    CPU_ENVS: {HAS_WEBGL: !1},
    BROWSER_CPU_ENVS: {BACKEND: 'test-cpu'},
    ALL_ENVS: {},
    expectArraysClose: bc,
    expectPromiseToFail(t, e) { t().then(() => e.fail(), () => e()); },
    expectArraysEqual(t, e) { return bc(t, e, 0); },
    expectNumbersClose(t, e, n) { if (n == null && (n = mt.get('TEST_EPSILON')), !wc(t, e, n)) throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`); },
    expectValuesInRange(t, e, n) {
      let r;

      r = t instanceof Y ? t.dataSync() : t; for (let o = 0; o < r.length; o++) if (r[o] < e || r[o] > n) throw new Error(`Value out of range:${r[o]} low: ${e}, high: ${n}`);
    },
    expectArrayBuffersEqual(t, e) { expect(new Float32Array(t)).toEqual(new Float32Array(e)); }
  }); const Sc = Object.freeze({
    gpgpu_util: zr, webgl_util: vr, MathBackendWebGL: di, GPGPUContext: Wr
  }); const _c = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return s(e, t), e.prototype.minimize = function (t, e, n) {
      void 0 === e && (e = !1); const r = this.computeGradients(t, n); const o = r.value; const i = r.grads;

      return this.applyGradients(i), Object.keys(i).forEach((t) => i[t].dispose()), e ? o : (o.dispose(), null);
    }, e.prototype.computeGradients = function (t, e) { return gt(t, e); }, e;
  }(vc)); const Cc = (function (o) {
    function t(t, e, n) {
      void 0 === n && (n = null); const r = o.call(this) || this;

      return r.learningRate = t, r.rho = e, r.epsilon = n, r.accumulatedGrads = {}, r.accumulatedUpdates = {}, r.c = wt(ne(-t)), r.rhoScalar = wt(ne(e)), r.oneMinusRho = wt(ne(1 - e)), n === null && (n = mt.get('EPSILON')), r.epsilonScalar = wt(ne(n)), r;
    }

    return s(t, o), t.prototype.applyGradients = function (t) {
      const c = this; const e = function (o) {
        const i = mt.engine.registeredVariables[o];

        n.accumulatedGrads[o] == null && bt(() => { c.accumulatedGrads[o] = Te(i).variable(!1); }), n.accumulatedUpdates[o] == null && bt(() => { c.accumulatedUpdates[o] = Te(i).variable(!1); }); const a = t[o]; const s = n.accumulatedGrads[o]; const u = n.accumulatedUpdates[o];

        bt(() => {
          const t = c.rhoScalar.mul(s).add(c.oneMinusRho.mul(a.square())); const e = u.add(c.epsilonScalar).sqrt().div(s.add(c.epsilonScalar).sqrt()).mul(a); const n = c.rhoScalar.mul(u).add(c.oneMinusRho.mul(e.square()));

          c.accumulatedGrads[o].assign(t), c.accumulatedUpdates[o].assign(n); const r = c.c.mul(e).add(i);

          i.assign(r);
        });
      }; var n = this;

      for (const r in t)e(r);
    }, t.prototype.dispose = function () {
      const e = this;

      this.c.dispose(), this.epsilonScalar.dispose(), this.rhoScalar.dispose(), this.oneMinusRho.dispose(), this.accumulatedUpdates != null && (Object.keys(this.accumulatedUpdates).forEach((t) => e.accumulatedUpdates[t].dispose()), Object.keys(this.accumulatedGrads).forEach((t) => e.accumulatedGrads[t].dispose()));
    }, t.prototype.getConfig = function () { return {learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon}; }, t.fromConfig = function (t, e) { return new t(e.learningRate, e.rho, e.epsilon); }, t.className = 'AdadeltaOptimizer', t;
  }(_c));

  yc(Cc); const Rc = (function (r) {
    function t(t, e) {
      void 0 === e && (e = 0.1); const n = r.call(this) || this;

      return n.learningRate = t, n.initialAccumulatorValue = e, n.accumulatedGrads = {}, n.c = wt(ne(-t)), n.epsilon = wt(ne(mt.get('EPSILON'))), n;
    }

    return s(t, r), t.prototype.applyGradients = function (t) {
      const a = this; const e = function (n) {
        const r = mt.engine.registeredVariables[n];

        s.accumulatedGrads[n] == null && bt(() => { a.accumulatedGrads[n] = he(r.shape, a.initialAccumulatorValue).variable(!1); }); const o = t[n]; const i = s.accumulatedGrads[n];

        bt(() => {
          const t = i.add(o.square());

          a.accumulatedGrads[n].assign(t); const e = a.c.mul(o.div(t.add(a.epsilon).sqrt())).add(r);

          r.assign(e);
        });
      }; var s = this;

      for (const n in t)e(n);
    }, t.prototype.dispose = function () {
      const e = this;

      this.epsilon.dispose(), this.c.dispose(), this.accumulatedGrads != null && Object.keys(this.accumulatedGrads).forEach((t) => e.accumulatedGrads[t].dispose());
    }, t.prototype.getConfig = function () { return {learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue}; }, t.fromConfig = function (t, e) { return new t(e.learningRate, e.initialAccumulatorValue); }, t.className = 'AdagradOptimizer', t;
  }(_c));

  yc(Rc); const Tc = (function (i) {
    function t(t, e, n, r) {
      void 0 === r && (r = null); const o = i.call(this) || this;

      return o.learningRate = t, o.beta1 = e, o.beta2 = n, o.epsilon = r, o.accumulatedFirstMoment = {}, o.accumulatedSecondMoment = {}, o.c = wt(ne(-t)), o.beta1Scalar = wt(ne(e)), o.beta2Scalar = wt(ne(n)), bt(() => { o.accBeta1 = ne(e).variable(), o.accBeta2 = ne(n).variable(); }), o.oneMinusBeta1 = wt(ne(1 - e)), o.oneMinusBeta2 = wt(ne(1 - n)), o.one = wt(ne(1)), r === null && (r = mt.get('EPSILON')), o.epsScalar = wt(ne(r)), o;
    }

    return s(t, i), t.prototype.applyGradients = function (f) {
      const d = this;

      bt(() => {
        const t = d.one.sub(d.accBeta1); const e = d.one.sub(d.accBeta2);

        for (const n in f) {
          const r = mt.engine.registeredVariables[n];

          if (d.accumulatedFirstMoment[n] == null) {
            var o = !1;

            d.accumulatedFirstMoment[n] = Te(r).variable(o);
          }d.accumulatedSecondMoment[n] == null && (o = !1, d.accumulatedSecondMoment[n] = Te(r).variable(o)); const i = f[n]; const a = d.accumulatedFirstMoment[n]; const s = d.accumulatedSecondMoment[n]; const u = d.beta1Scalar.mul(a).add(d.oneMinusBeta1.mul(i)); const c = d.beta2Scalar.mul(s).add(d.oneMinusBeta2.mul(i.square())); const l = u.div(t); const h = c.div(e);

          d.accumulatedFirstMoment[n].assign(u), d.accumulatedSecondMoment[n].assign(c); const p = d.c.mul(l.div(d.epsScalar.add(h.sqrt()))).add(r);

          r.assign(p);
        }d.accBeta1.assign(d.accBeta1.mul(d.beta1Scalar)), d.accBeta2.assign(d.accBeta2.mul(d.beta2Scalar));
      });
    }, t.prototype.dispose = function () {
      const e = this;

      this.c.dispose(), this.epsScalar.dispose(), this.beta1Scalar.dispose(), this.beta2Scalar.dispose(), this.accBeta1.dispose(), this.accBeta2.dispose(), this.oneMinusBeta1.dispose(), this.oneMinusBeta2.dispose(), this.one.dispose(), this.accumulatedFirstMoment != null && Object.keys(this.accumulatedFirstMoment).forEach((t) => e.accumulatedFirstMoment[t].dispose()), this.accumulatedSecondMoment != null && Object.keys(this.accumulatedSecondMoment).forEach((t) => e.accumulatedSecondMoment[t].dispose());
    }, t.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon
      };
    }, t.fromConfig = function (t, e) { return new t(e.learningRate, e.beta1, e.beta2, e.epsilon); }, t.className = 'AdamOptimizer', t;
  }(_c));

  yc(Tc); const kc = (function (a) {
    function t(t, e, n, r, o) {
      void 0 === r && (r = null), void 0 === o && (o = 0); const i = a.call(this) || this;

      return i.learningRate = t, i.beta1 = e, i.beta2 = n, i.epsilon = r, i.decay = o, i.accumulatedFirstMoment = {}, i.accumulatedWeightedInfNorm = {}, i.c = wt(ne(-t)), i.beta1Scalar = wt(ne(e)), i.beta2Scalar = wt(ne(n)), i.decayScalar = wt(ne(o)), bt(() => { i.iteration = ne(0).variable(), i.accBeta1 = ne(e).variable(); }), i.oneMinusBeta1 = wt(ne(1 - e)), i.one = wt(ne(1)), r === null && (r = mt.get('EPSILON')), i.epsScalar = wt(ne(r)), i;
    }

    return s(t, a), t.prototype.applyGradients = function (f) {
      const d = this;

      bt(() => {
        const t = d.one.sub(d.accBeta1); const e = d.c.div(d.one.add(d.decayScalar.mul(d.iteration)));

        for (const n in f) {
          const r = mt.engine.registeredVariables[n];

          if (d.accumulatedFirstMoment[n] == null) {
            var o = !1;

            d.accumulatedFirstMoment[n] = Te(r).variable(o);
          }d.accumulatedWeightedInfNorm[n] == null && (o = !1, d.accumulatedWeightedInfNorm[n] = Te(r).variable(o)); const i = f[n]; const a = d.accumulatedFirstMoment[n]; const s = d.accumulatedWeightedInfNorm[n]; const u = d.beta1Scalar.mul(a).add(d.oneMinusBeta1.mul(i)); const c = d.beta2Scalar.mul(s); const l = i.abs(); const h = c.maximum(l);

          d.accumulatedFirstMoment[n].assign(u), d.accumulatedWeightedInfNorm[n].assign(h); const p = e.div(t).mul(u.div(d.epsScalar.add(h))).add(r);

          r.assign(p);
        }d.iteration.assign(d.iteration.add(d.one)), d.accBeta1.assign(d.accBeta1.mul(d.beta1Scalar));
      });
    }, t.prototype.dispose = function () {
      const e = this;

      this.c.dispose(), this.epsScalar.dispose(), this.accBeta1.dispose(), this.beta1Scalar.dispose(), this.beta2Scalar.dispose(), this.oneMinusBeta1.dispose(), this.decayScalar.dispose(), this.iteration.dispose(), this.one.dispose(), this.accumulatedFirstMoment != null && Object.keys(this.accumulatedFirstMoment).forEach((t) => e.accumulatedFirstMoment[t].dispose()), this.accumulatedWeightedInfNorm != null && Object.keys(this.accumulatedWeightedInfNorm).forEach((t) => e.accumulatedWeightedInfNorm[t].dispose());
    }, t.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay
      };
    }, t.fromConfig = function (t, e) { return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay); }, t.className = 'AdamaxOptimizer', t;
  }(_c));

  yc(kc); const Ic = (function (n) {
    function t(t) {
      const e = n.call(this) || this;

      return e.learningRate = t, e.setLearningRate(t), e;
    }

    return s(t, n), t.prototype.applyGradients = function (r) {
      const o = this;

      Object.keys(r).forEach((t) => {
        const e = r[t]; const n = mt.engine.registeredVariables[t];

        bt(() => {
          const t = o.c.mul(e).add(n);

          n.assign(t);
        });
      });
    }, t.prototype.setLearningRate = function (t) { this.learningRate = t, this.c != null && this.c.dispose(), this.c = wt(ne(-t)); }, t.prototype.dispose = function () { this.c.dispose(); }, t.prototype.getConfig = function () { return {learningRate: this.learningRate}; }, t.fromConfig = function (t, e) { return new t(e.learningRate); }, t.className = 'SGDOptimizer', t;
  }(_c));

  yc(Ic); const Dc = (function (o) {
    function t(t, e, n) {
      void 0 === n && (n = !1); const r = o.call(this, t) || this;

      return r.learningRate = t, r.momentum = e, r.useNesterov = n, r.m = ne(r.momentum), r.accumulations = {}, r;
    }

    return s(t, o), t.prototype.applyGradients = function (t) {
      const a = this; const e = function (n) {
        const r = mt.engine.registeredVariables[n];

        s.accumulations[n] == null && bt(() => { a.accumulations[n] = Te(r).variable(!1); }); const o = s.accumulations[n]; const i = t[n];

        bt(() => {
          let t; const e = a.m.mul(o).add(i);

          t = a.useNesterov ? a.c.mul(i.add(e.mul(a.m))).add(r) : a.c.mul(e).add(r), a.accumulations[n].assign(e), r.assign(t);
        });
      }; var s = this;

      for (const n in t)e(n);
    }, t.prototype.dispose = function () { if (o.prototype.dispose.call(this), this.m.dispose(), this.accumulations != null) for (const t in this.accumulations) this.accumulations[t].dispose(); }, t.prototype.setMomentum = function (t) { this.momentum = t; }, t.prototype.getConfig = function () { return {learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov}; }, t.fromConfig = function (t, e) { return new t(e.learningRate, e.momentum, e.useNesterov); }, t.className = 'MomentumOptimizer', t;
  }(Ic));

  yc(Dc); const Nc = (function (a) {
    function t(t, e, n, r, o) {
      void 0 === e && (e = 0.9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1); const i = a.call(this) || this;

      return i.learningRate = t, i.decay = e, i.momentum = n, i.epsilon = r, i.accumulatedMeanSquares = {}, i.accumulatedMeanGrads = {}, i.accumulatedMoments = {}, i.c = wt(ne(t)), i.decayScalar = wt(ne(e)), i.momentumScalar = wt(ne(n)), i.oneMinusDecay = wt(ne(1 - e)), i.centered = o, r === null && (r = mt.get('EPSILON')), i.epsilonScalar = wt(ne(r)), i;
    }

    return s(t, a), t.prototype.applyGradients = function (t) {
      const h = this; const e = function (i) {
        const a = mt.engine.registeredVariables[i];

        n.accumulatedMeanSquares[i] == null && bt(() => { h.accumulatedMeanSquares[i] = Te(a).variable(!1); }), n.accumulatedMeanGrads[i] == null && n.centered && bt(() => { h.accumulatedMeanGrads[i] = Te(a).variable(!1); }), n.accumulatedMoments[i] == null && bt(() => { h.accumulatedMoments[i] = Te(a).variable(!1); }); const s = n.accumulatedMeanSquares[i]; const u = n.accumulatedMeanGrads[i]; const c = n.accumulatedMoments[i]; const l = t[i];

        bt(() => {
          const t = h.decayScalar.mul(s).add(h.oneMinusDecay.mul(l.square()));

          if (h.centered) {
            const e = h.decayScalar.mul(u).add(h.oneMinusDecay.mul(l)); var n = h.momentumScalar.mul(c).add(h.c.mul(l).div(t.sub(e.square().add(h.epsilonScalar)).sqrt()));

            h.accumulatedMeanSquares[i].assign(t), h.accumulatedMeanGrads[i].assign(e), h.accumulatedMoments[i].assign(n); var r = a.sub(n);

            a.assign(r);
          }
          else {
            const o = h.decayScalar.mul(s).add(h.oneMinusDecay.mul(l.square()));

            n = h.momentumScalar.mul(c).add(h.c.mul(l).div(o.add(h.epsilonScalar).sqrt())), h.accumulatedMeanSquares[i].assign(o), h.accumulatedMoments[i].assign(n), r = a.sub(n), a.assign(r);
          }
        });
      }; var n = this;

      for (const r in t)e(r);
    }, t.prototype.dispose = function () {
      const e = this;

      this.c.dispose(), this.epsilonScalar.dispose(), this.decayScalar.dispose(), this.momentumScalar.dispose(), this.oneMinusDecay.dispose(), this.accumulatedMeanSquares != null && Object.keys(this.accumulatedMeanSquares).forEach((t) => e.accumulatedMeanSquares[t].dispose()), this.accumulatedMeanGrads != null && this.centered && Object.keys(this.accumulatedMeanGrads).forEach((t) => e.accumulatedMeanGrads[t].dispose()), this.accumulatedMoments != null && Object.keys(this.accumulatedMoments).forEach((t) => e.accumulatedMoments[t].dispose());
    }, t.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered
      };
    }, t.fromConfig = function (t, e) { return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered); }, t.className = 'RMSPropOptimizer', t;
  }(_c));

  yc(Nc); const Ac = (function () {
    function t() {}

    return t.sgd = function (t) { return new Ic(t); }, t.momentum = function (t, e, n) { return void 0 === n && (n = !1), new Dc(t, e, n); }, t.rmsprop = function (t, e, n, r, o) { return void 0 === e && (e = 0.9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1), new Nc(t, e, n, r, o); }, t.adam = function (t, e, n, r) { return void 0 === t && (t = 0.001), void 0 === e && (e = 0.9), void 0 === n && (n = 0.999), void 0 === r && (r = null), new Tc(t, e, n, r); }, t.adadelta = function (t, e, n) { return void 0 === t && (t = 0.001), void 0 === e && (e = 0.95), void 0 === n && (n = null), new Cc(t, e, n); }, t.adamax = function (t, e, n, r, o) { return void 0 === t && (t = 0.002), void 0 === e && (e = 0.9), void 0 === n && (n = 0.999), void 0 === r && (r = null), void 0 === o && (o = 0), new kc(t, e, n, r, o); }, t.adagrad = function (t, e) { return void 0 === e && (e = 0.1), new Rc(t, e); }, t;
  }()); const Mc = {
    sgd: Ac.sgd, momentum: Ac.momentum, adadelta: Ac.adadelta, adagrad: Ac.adagrad, rmsprop: Ac.rmsprop, adamax: Ac.adamax, adam: Ac.adam
  }; const Oc = ft.setBackend; const Pc = ft.getBackend; const Fc = ft.disposeVariables; const Lc = ft.memory;

  K = bu; const Bc = Object.freeze({
    setBackend: Oc,
    getBackend: Pc,
    disposeVariables: Fc,
    memory: Lc,
    version_core: '0.13.8',
    nextFrame() { return new Promise(((t) => Eu(() => t()))); },
    environment: vt,
    io: fc,
    math: mc,
    serialization: xc,
    test_util: Ec,
    util: L,
    webgl: Sc,
    AdadeltaOptimizer: Cc,
    AdagradOptimizer: Rc,
    AdamOptimizer: Tc,
    AdamaxOptimizer: kc,
    MomentumOptimizer: Dc,
    Optimizer: _c,
    RMSPropOptimizer: Nc,
    SGDOptimizer: Ic,
    Tensor: Y,
    TensorBuffer: H,
    variable: J,
    Variable: Q,
    get Rank() { return me; },
    get Reduction() { return Ys; },
    ENV: mt,
    Environment: ft,
    DataStorage: Ne,
    image: xu,
    linalg: pu,
    losses: uu,
    spectral: Ks,
    op: Yt,
    batchNormalization2d: Xi,
    batchNormalization3d: Yi,
    batchNormalization4d: Qi,
    batchNormalization: Ji,
    complex: Jt,
    real: Zt,
    imag: te,
    concat: So,
    concat1d: _o,
    concat2d: Co,
    concat3d: Ro,
    concat4d: To,
    split: ko,
    conv1d: ha,
    conv2d: pa,
    conv2dDerFilter: fa,
    depthwiseConv2d: da,
    separableConv2d: ma,
    conv2dTranspose: va,
    matMul: aa,
    dot: sa,
    outerProduct: ua,
    reverse: ga,
    reverse1d: ya,
    reverse2d: xa,
    reverse3d: ba,
    reverse4d: wa,
    maxPool: _a,
    avgPool: Ca,
    pool: Ra,
    slice: Ta,
    slice1d: ka,
    slice2d: Ia,
    slice3d: Da,
    slice4d: Na,
    abs: vi,
    acos: gi,
    acosh: yi,
    asin: xi,
    asinh: bi,
    atan: wi,
    atanh: Ei,
    ceil: Si,
    clipByValue: _i,
    cos: Ci,
    cosh: Ri,
    erf: Ti,
    exp: ki,
    expm1: Ii,
    floor: Di,
    log: Ni,
    log1p: Ai,
    logSigmoid: Mi,
    neg: Oi,
    reciprocal: Pi,
    round: Fi,
    rsqrt: Li,
    sigmoid: Bi,
    sign: zi,
    sin: Wi,
    sinh: Ui,
    softplus: Vi,
    sqrt: Gi,
    square: qi,
    step: ji,
    tan: Hi,
    tanh: $i,
    all: Ma,
    any: Oa,
    argMax: Pa,
    argMin: Fa,
    logSumExp: La,
    max: Ba,
    mean: za,
    min: Wa,
    moments: Ua,
    sum: Va,
    prod: Ga,
    equal: qa,
    equalStrict: ja,
    greater: Ha,
    greaterEqual: $a,
    greaterEqualStrict: Ka,
    greaterStrict: Xa,
    less: Ya,
    lessEqual: Qa,
    lessEqualStrict: Ja,
    lessStrict: Za,
    notEqual: ts,
    notEqualStrict: es,
    add: ns,
    addN: rs,
    addStrict: os,
    atan2: is,
    div: as,
    divStrict: ss,
    floorDiv: us,
    maximum: cs,
    maximumStrict: ls,
    minimum: hs,
    minimumStrict: ps,
    mod: fs,
    modStrict: ds,
    mul: ms,
    mulStrict: vs,
    pow: gs,
    powStrict: ys,
    squaredDifference: xs,
    squaredDifferenceStrict: bs,
    sub: ws,
    subStrict: Es,
    elu: Is,
    leakyRelu: Ds,
    prelu: Ns,
    relu: As,
    selu: Ms,
    logicalAnd: Ss,
    logicalNot: _s,
    logicalOr: Cs,
    logicalXor: Rs,
    where: Ts,
    whereAsync: ks,
    buffer: Wo,
    toPixels: zo,
    print: Uo,
    batchToSpaceND: Vo,
    cast: Go,
    clone: qo,
    cumsum: jo,
    depthToSpace: Ho,
    expandDims: $o,
    eye: Ko,
    fromPixels: Xo,
    multinomial: Yo,
    oneHot: Qo,
    pad: Jo,
    pad1d: Zo,
    pad2d: ti,
    pad3d: ei,
    pad4d: ni,
    rand: ri,
    randomNormal: oi,
    randomUniform: ii,
    reshape: ai,
    spaceToBatchND: si,
    squeeze: ui,
    stack: ci,
    tile: li,
    truncatedNormal: hi,
    unstack: pi,
    fill: he,
    linspace: pe,
    ones: ce,
    range: fe,
    scalar: ne,
    tensor: ee,
    tensor1d: re,
    tensor2d: oe,
    tensor3d: ie,
    tensor4d: ae,
    tensor5d: se,
    tensor6d: ue,
    zeros: le,
    onesLike: Re,
    zerosLike: Te,
    transpose: Os,
    softmax: Qt,
    localResponseNormalization: Ps,
    norm: Fs,
    gather: zs,
    unsortedSegmentSum: Ws,
    basicLSTMCell: Us,
    multiRNNCell: Vs,
    movingAverage: Gs,
    stridedSlice: qs,
    topk: js,
    scatterND: Hs,
    fft: $s,
    sparseToDense: Xs,
    gatherND: Js,
    train: Mc,
    tidy: bt,
    keep: wt,
    dispose: Et,
    time: St,
    profile: _t,
    customGrad: yt,
    grad(i) {
      return D(k(i), 'The f passed in grad(f) must be a function'), function (r, o) {
        return D(r instanceof Y, 'The x passed in grad(f)(x) must be a tensor'), D(o == null || o instanceof Y, 'The dy passed in grad(f)(x, dy) must be a tensor'), mt.engine.tidy(() => {
          const t = mt.engine.gradients(() => i(r), [r], o); const e = t.value; const n = t.grads;

          return o != null && f(e.shape, o.shape, 'The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)'), xt(n), n[0];
        });
      };
    },
    grads(i) {
      return D(k(i), 'The f passed in grads(f) must be a function'), function (r, o) {
        return D(Array.isArray(r) && r.every((t) => t instanceof Y), 'The args passed in grads(f)(args) must be an array of tensors'), D(o == null || o instanceof Y, 'The dy passed in grads(f)(args, dy) must be a tensor'), mt.engine.tidy(() => {
          const t = mt.engine.gradients(() => i.apply(void 0, r), r, o); const e = t.value; const n = t.grads;

          return o != null && f(e.shape, o.shape, 'The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])'), xt(n), n;
        });
      };
    },
    valueAndGrad(i) {
      return D(k(i), 'The f passed in valueAndGrad(f) must be a function'), function (t, e) {
        D(t instanceof Y, 'The x passed in valueAndGrad(f)(x) must be a tensor'), D(e == null || e instanceof Y, 'The dy passed in valueAndGrad(f)(x, dy) must be a tensor'); const n = mt.engine.gradients(() => i(t), [t], e); const r = n.grads; const o = n.value;

        return xt(r), {grad: r[0], value: o};
      };
    },
    valueAndGrads(r) {
      return D(k(r), 'The f passed in valueAndGrads(f) must be a function'), function (t, e) {
        D(Array.isArray(t) && t.every((t) => t instanceof Y), 'The args passed in valueAndGrads(f)(args) must be array of tensors'), D(e == null || e instanceof Y, 'The dy passed in valueAndGrads(f)(args, dy) must be a tensor'); const n = mt.engine.gradients(() => r.apply(void 0, t), t, e);

        return e != null && f(n.value.shape, e.shape, 'The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])'), xt(n.grads), n;
      };
    },
    variableGrads: gt
  }); var zc = function (t, e) { return (zc = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); })(t, e); };

  function Wc(t, e) { function n() { this.constructor = t; }zc(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n()); } var Uc = function () {
    return (Uc = Object.assign || function (t) {
      for (var e, n = 1, r = arguments.length; n < r; n++) for (const o in e = arguments[n])Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);

      return t;
    }).apply(this, arguments);
  };

  function Vc(i, a, s, u) {
    return new (s || (s = Promise))(((t, e) => {
      function n(t) {
        try { o(u.next(t)); }
        catch (t) { e(t); }
      } function r(t) {
        try { o(u.throw(t)); }
        catch (t) { e(t); }
      } function o(e) { e.done ? t(e.value) : new s(((t) => { t(e.value); })).then(n, r); }o((u = u.apply(i, a || [])).next());
    }));
  } function Gc(n, r) {
    let o; let i; let a; let t; let s = {
      label: 0,
      sent() {
        if (1 & a[0]) throw a[1];

        return a[1];
      },
      trys: [],
      ops: []
    };

    return t = {next: e(0), throw: e(1), return: e(2)}, typeof Symbol === 'function' && (t[Symbol.iterator] = function () { return this; }), t; function e(e) {
      return function (t) {
        return (function (e) {
          if (o) throw new TypeError('Generator is already executing.'); for (;s;) {
            try { if (o = 1, i && (a = 2 & e[0] ? i.return : e[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, e[1])).done) return a; switch (i = 0, a && (e = [2 & e[0], a.value]), e[0]) { case 0: case 1: a = e; break; case 4: return s.label++, {value: e[1], done: !1}; case 5: s.label++, i = e[1], e = [0]; continue; case 7: e = s.ops.pop(), s.trys.pop(); continue; default: if (!(a = (a = s.trys).length > 0 && a[a.length - 1]) && (e[0] === 6 || e[0] === 2)) { s = 0; continue; } if (e[0] === 3 && (!a || e[1] > a[0] && e[1] < a[3])) { s.label = e[1]; break; } if (e[0] === 6 && s.label < a[1]) { s.label = a[1], a = e; break; } if (a && s.label < a[2]) { s.label = a[2], s.ops.push(e); break; }a[2] && s.ops.pop(), s.trys.pop(); continue; }e = r.call(n, s); }
            catch (t) { e = [6, t], i = 0; }
            finally { o = a = 0; }
          } if (5 & e[0]) throw e[1];

          return {value: e[0] ? e[1] : void 0, done: !0};
        }([e, t]));
      };
    }
  } const qc = (function () {
    function t(t, e) { if (!rl(t) || !rl(e)) throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width: t, height: e})}`); this._width = t, this._height = e; }

    return Object.defineProperty(t.prototype, 'width', {get() { return this._width; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'height', {get() { return this._height; }, enumerable: !0, configurable: !0}), t.prototype.reverse = function () { return new t(1 / this.width, 1 / this.height); }, t;
  }()); const jc = (function () {
    function e(t, e) { this._x = t, this._y = e; }

    return Object.defineProperty(e.prototype, 'x', {get() { return this._x; }, enumerable: !0, configurable: !0}), Object.defineProperty(e.prototype, 'y', {get() { return this._y; }, enumerable: !0, configurable: !0}), e.prototype.add = function (t) { return new e(this.x + t.x, this.y + t.y); }, e.prototype.sub = function (t) { return new e(this.x - t.x, this.y - t.y); }, e.prototype.mul = function (t) { return new e(this.x * t.x, this.y * t.y); }, e.prototype.div = function (t) { return new e(this.x / t.x, this.y / t.y); }, e.prototype.abs = function () { return new e(Math.abs(this.x), Math.abs(this.y)); }, e.prototype.magnitude = function () { return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)); }, e.prototype.floor = function () { return new e(Math.floor(this.x), Math.floor(this.y)); }, e;
  }());

  function Hc(t, e) { return t instanceof Y && t.shape.length === e; } function $c(t) { return Hc(t, 2); } function Kc(t) { return Hc(t, 3); } function Xc(t) { return Hc(t, 4); } function Yc(t) { return t % 1 != 0; } function Qc(t) { return t % 2 == 0; } function Jc(t, e) {
    void 0 === e && (e = 2); const n = Math.pow(10, e);

    return Math.floor(t * n) / n;
  } function Zc(t) { return t && t.width && t.height; } function tl(t, e) {
    const n = t.width; const r = t.height; const o = e / Math.max(r, n);

    return new qc(Math.round(n * o), Math.round(r * o));
  } function el(t) { return t.reduce((t, e) => t.add(e), new jc(0, 0)).div(new jc(t.length, t.length)); } function nl(t, n, r) { return Array(t).fill(0).map((t, e) => n + e * r); } function rl(t) { return !!t && t !== 1 / 0 && t !== -1 / 0 && !isNaN(t) || t === 0; } function ol(t) { return rl(t) && t >= 0 && t <= 1; } let il; const al = (function () {
    function l(t, e) {
      void 0 === e && (e = !1); const n = t || {}; const r = [n.left, n.top, n.right, n.bottom].every(rl); const o = [n.x, n.y, n.width, n.height].every(rl);

      if (!o && !r) throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(n)}`); const i = o ? [n.x, n.y, n.width, n.height] : [n.left, n.top, n.right - n.left, n.bottom - n.top]; const a = i[0]; const s = i[1]; const u = i[2]; const c = i[3];

      l.assertIsValidBox({
        x: a, y: s, width: u, height: c
      }, 'Box.constructor', e), this._x = a, this._y = s, this._width = u, this._height = c;
    }

    return l.isRect = function (t) { return !!t && [t.x, t.y, t.width, t.height].every(rl); }, l.assertIsValidBox = function (t, e, n) { if (void 0 === n && (n = !1), !l.isRect(t)) throw new Error(`${e} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`); if (!n && (t.width < 0 || t.height < 0)) throw new Error(`${e} - width (${t.width}) and height (${t.height}) must be positive numbers`); }, Object.defineProperty(l.prototype, 'x', {get() { return this._x; }, enumerable: !0, configurable: !0}), Object.defineProperty(l.prototype, 'y', {get() { return this._y; }, enumerable: !0, configurable: !0}), Object.defineProperty(l.prototype, 'width', {get() { return this._width; }, enumerable: !0, configurable: !0}), Object.defineProperty(l.prototype, 'height', {get() { return this._height; }, enumerable: !0, configurable: !0}), Object.defineProperty(l.prototype, 'left', {get() { return this.x; }, enumerable: !0, configurable: !0}), Object.defineProperty(l.prototype, 'top', {get() { return this.y; }, enumerable: !0, configurable: !0}), Object.defineProperty(l.prototype, 'right', {get() { return this.x + this.width; }, enumerable: !0, configurable: !0}), Object.defineProperty(l.prototype, 'bottom', {get() { return this.y + this.height; }, enumerable: !0, configurable: !0}), Object.defineProperty(l.prototype, 'area', {get() { return this.width * this.height; }, enumerable: !0, configurable: !0}), l.prototype.round = function () {
      const t = [this.x, this.y, this.width, this.height].map((t) => Math.round(t));

      return new l({
        x: t[0], y: t[1], width: t[2], height: t[3]
      });
    }, l.prototype.floor = function () {
      const t = [this.x, this.y, this.width, this.height].map((t) => Math.floor(t));

      return new l({
        x: t[0], y: t[1], width: t[2], height: t[3]
      });
    }, l.prototype.toSquare = function () {
      let t = this.x; let e = this.y; let n = this.width; let r = this.height; const o = Math.abs(n - r);

      return n < r && (t -= o / 2, n += o), r < n && (e -= o / 2, r += o), new l({
        x: t, y: e, width: n, height: r
      });
    }, l.prototype.rescale = function (t) {
      const e = Zc(t) ? t.width : t; const n = Zc(t) ? t.height : t;

      return new l({
        x: this.x * e, y: this.y * n, width: this.width * e, height: this.height * n
      });
    }, l.prototype.pad = function (t, e) {
      const n = [this.x - t / 2, this.y - e / 2, this.width + t, this.height + e];

      return new l({
        x: n[0], y: n[1], width: n[2], height: n[3]
      });
    }, l.prototype.clipAtImageBorders = function (t, e) {
      const n = this.x; const r = this.y; const o = this.right; const i = this.bottom; const a = Math.max(n, 0); const s = Math.max(r, 0); const u = o - a; const c = i - s;

      return new l({
        x: a, y: s, width: Math.min(u, t - a), height: Math.min(c, e - s)
      }).floor();
    }, l.prototype.padAtBorders = function (t, e) {
      const n = this.width + 1; const r = this.height + 1; let o = n; let i = r; let a = this.left; let s = this.top; let u = this.right; let c = this.bottom;

      return e < u && (o = -u + e + n, u = e), t < c && (i = -c + t + r, c = t), a < 1 && (i = 2 - a, a = 1), s < 1 && (i = 2 - s, s = 1), {
        dy: 1, edy: i, dx: 1, edx: o, y: s, ey: c, x: a, ex: u, w: n, h: r
      };
    }, l.prototype.calibrate = function (t) {
      return new l({
        left: this.left + t.left * this.width, top: this.top + t.top * this.height, right: this.right + t.right * this.width, bottom: this.bottom + t.bottom * this.height
      }).toSquare().round();
    }, l;
  }()); const sl = (function (o) {
    function t(t, e, n, r) {
      return o.call(this, {
        left: t, top: e, right: n, bottom: r
      }) || this;
    }

    return Wc(t, o), t;
  }(al)); const ul = (function (r) {
    function t(t, e) {
      const n = r.call(this, t) || this;

      return n._text = e, n;
    }

    return Wc(t, r), Object.defineProperty(t.prototype, 'text', {get() { return this._text; }, enumerable: !0, configurable: !0}), t;
  }(al)); const cl = (function (r) {
    function t(t, e) {
      const n = r.call(this, t) || this;

      return n._label = e, n;
    }

    return Wc(t, r), t.assertIsValidLabeledBox = function (t, e) { if (al.assertIsValidBox(t, e), !rl(t.label)) throw new Error(`${e} - expected property label (${t.label}) to be a number`); }, Object.defineProperty(t.prototype, 'label', {get() { return this._label; }, enumerable: !0, configurable: !0}), t;
  }(al)); const ll = (function () {
    function n(t, e, n, r, o) { this._imageDims = new qc(o.width, o.height), this._score = t, this._classScore = e, this._className = n, this._box = new al(r).rescale(this._imageDims); }

    return Object.defineProperty(n.prototype, 'score', {get() { return this._score; }, enumerable: !0, configurable: !0}), Object.defineProperty(n.prototype, 'classScore', {get() { return this._classScore; }, enumerable: !0, configurable: !0}), Object.defineProperty(n.prototype, 'className', {get() { return this._className; }, enumerable: !0, configurable: !0}), Object.defineProperty(n.prototype, 'box', {get() { return this._box; }, enumerable: !0, configurable: !0}), Object.defineProperty(n.prototype, 'imageDims', {get() { return this._imageDims; }, enumerable: !0, configurable: !0}), Object.defineProperty(n.prototype, 'imageWidth', {get() { return this.imageDims.width; }, enumerable: !0, configurable: !0}), Object.defineProperty(n.prototype, 'imageHeight', {get() { return this.imageDims.height; }, enumerable: !0, configurable: !0}), Object.defineProperty(n.prototype, 'relativeBox', {get() { return new al(this._box).rescale(this.imageDims.reverse()); }, enumerable: !0, configurable: !0}), n.prototype.forSize = function (t, e) { return new n(this.score, this.classScore, this.className, this.relativeBox, {width: t, height: e}); }, n;
  }()); const hl = (function (i) {
    function t(t, e, n, r) {
      const o = i.call(this, t, e) || this;

      return o._score = n, o._classScore = r, o;
    }

    return Wc(t, i), t.assertIsValidPredictedBox = function (t, e) { if (cl.assertIsValidLabeledBox(t, e), !ol(t.score) || !ol(t.classScore)) throw new Error(`${e} - expected properties score (${t.score}) and (${t.classScore}) to be a number between [0, 1]`); }, Object.defineProperty(t.prototype, 'score', {get() { return this._score; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'classScore', {get() { return this._classScore; }, enumerable: !0, configurable: !0}), t;
  }(cl)); const pl = (function (o) {
    function t(t, e, n, r) {
      return o.call(this, {
        x: t, y: e, width: n, height: r
      }) || this;
    }

    return Wc(t, o), t;
  }(al));

  function fl(t, n) { Object.keys(t).forEach((e) => { n.some((t) => t.originalPath === e) || t[e].dispose(); }); } function dl(o, i) {
    return function (t, e, n) {
      const r = o[t];

      if (!Hc(r, e)) throw new Error(`expected weightMap[${t}] to be a Tensor${e}D, instead have ${r}`);

      return i.push({originalPath: t, paramPath: n || t}), r;
    };
  } function ml(t) {
    let n = t;

    return {
      extractWeights(t) {
        const e = n.slice(0, t);

        return n = n.slice(t), e;
      },
      getRemainingWeights() { return n; }
    };
  } function vl(t, e) {
    const n = `${e}-weights_manifest.json`;

    if (!t) return {modelBaseUri: '', manifestUri: n}; if (t === '/') return {modelBaseUri: '/', manifestUri: `/${n}`}; const r = t.startsWith('http://') ? 'http://' : t.startsWith('https://') ? 'https://' : '';
    const o = (t = t.replace(r, '')).split('/').filter((t) => t); const i = t.endsWith('.json') ? o[o.length - 1] : n; let
      a = r + (t.endsWith('.json') ? o.slice(0, o.length - 1) : o).join('/');

    return {modelBaseUri: a = t.startsWith('/') ? `/${a}` : a, manifestUri: a === '/' ? `/${i}` : `${a}/${i}`};
  } function gl() { return typeof module !== 'undefined' && !!module.exports && typeof process !== 'undefined' && !!process.version; } function yl() {
    return gl() ? (function () {
      const t = global.Canvas || global.HTMLCanvasElement; const e = global.Image || global.HTMLImageElement; const n = global.fetch || function () { throw new Error('fetch - missing fetch implementation for nodejs environment'); }; let o = null; let r = '';

      try { o = require('fs'); }
      catch (t) { r = t.toString(); } const i = o ? function (t) { return new Promise(((n, r) => { o.readFile(t, (t, e) => (t ? r(t) : n(e))); })); } : function () { throw new Error(`readFile - failed to require fs in nodejs environment with error: ${r}`); };

      return {
        Canvas: t || function () {}, Image: e || function () {}, ImageData: global.ImageData || function () {}, Video: global.HTMLVideoElement || function () {}, createCanvasElement() { if (t) return new t(); throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment'); }, createImageElement() { if (e) return new e(); throw new Error('createImageElement - missing Image implementation for nodejs environment'); }, fetch: n, readFile: i
      };
    }()) : (t = window.fetch || function () { throw new Error('fetch - missing fetch implementation for browser environment'); }, {
      Canvas: HTMLCanvasElement, Image: HTMLImageElement, ImageData, Video: HTMLVideoElement, createCanvasElement() { return document.createElement('canvas'); }, createImageElement() { return document.createElement('img'); }, fetch: t, readFile() { throw new Error('readFile - filesystem not available for browser environment'); }
    }); let t;
  } function xl() { il = yl(); } const bl = {
    getEnv() { return il; },
    initialize: xl,
    monkeyPatch(t) {
      il = il || yl(); const e = t.Canvas; const n = void 0 === e ? il.Canvas : e; const r = t.Image; const o = void 0 === r ? il.Image : r;

      il.Canvas = n, il.Image = o, il.createCanvasElement = t.createCanvasElement || function () { return new n(); }, il.createImageElement = t.createImageElement || function () { return new o(); }, il.ImageData = t.ImageData || il.ImageData, il.Video = t.Video || il.Video, il.fetch = t.fetch || il.fetch, il.readFile = t.readFile || il.readFile;
    },
    isNodejs: gl
  };

  function wl(t) {
    const e = bl.getEnv(); const n = e.Image; const r = e.Video;

    return t instanceof n && t.complete || t instanceof r && t.readyState >= 3;
  } function El(t) { return new Promise(((e, n) => { if (t instanceof bl.getEnv().Canvas || wl(t)) return e(); function r(t) { t.currentTarget && (t.currentTarget.removeEventListener('load', r), t.currentTarget.removeEventListener('error', o), e(t)); } function o(t) { t.currentTarget && (t.currentTarget.removeEventListener('load', r), t.currentTarget.removeEventListener('error', o), n(t)); }t.addEventListener('load', r), t.addEventListener('error', o); })); } function Sl(t) {
    return new Promise(((e, n) => {
      if (!(t instanceof Blob)) return n('bufferToImage - expected buf to be of type: Blob'); const r = new FileReader();

      r.onload = function () {
        if (typeof r.result !== 'string') return n('bufferToImage - expected reader.result to be a string, in onload'); const t = bl.getEnv().createImageElement();

        t.onload = function () { return e(t); }, t.onerror = n, t.src = r.result;
      }, r.onerror = n, r.readAsDataURL(t);
    }));
  } function _l(t) {
    const e = t.getContext('2d');

    if (!e) throw new Error('canvas 2d context is null');

    return e;
  } function Cl(t) {
    const e = bl.getEnv(); const n = e.Image; const r = e.Video;

    return t instanceof n ? new qc(t.naturalWidth, t.naturalHeight) : t instanceof r ? new qc(t.videoWidth, t.videoHeight) : new qc(t.width, t.height);
  } function Rl(t) {
    const e = t.width; const n = t.height; const r = (0, bl.getEnv().createCanvasElement)();

    return r.width = e, r.height = n, r;
  } function Tl(t, e) {
    const n = bl.getEnv().ImageData;

    if (!(t instanceof n || wl(t))) throw new Error('createCanvasFromMedia - media has not finished loading yet'); const r = e || Cl(t); const o = r.width; const i = r.height; const a = Rl({width: o, height: i});

    return t instanceof n ? _l(a).putImageData(t, 0, 0) : _l(a).drawImage(t, 0, 0, o, i), a;
  } function kl(t) {
    return void 0 === t && (t = {}), Object.assign({}, {
      boxColor: 'blue', textColor: 'red', lineWidth: 2, fontSize: 20, fontStyle: 'Georgia', withScore: !0, withClassName: !0
    }, t);
  } function Il(t, e, n, r, o, i) {
    const a = Object.assign(kl(), i || {});

    t.strokeStyle = a.boxColor, t.lineWidth = a.lineWidth, t.strokeRect(e, n, r, o);
  } function Dl(t, e, n, r, o) {
    void 0 === o && (o = {}); const i = Object.assign(kl(), o); const a = 2 + i.lineWidth;

    t.fillStyle = i.textColor, t.font = `${i.fontSize}px ${i.fontStyle}`, t.fillText(r, e + a, n + a + 0.6 * i.fontSize);
  } function Nl(t) { return bl.isNodejs() || typeof t !== 'string' ? t : document.getElementById(t); } function Al(n, r) {
    return Vc(this, void 0, void 0, function () {
      let e;

      return Gc(this, (t) => {
        switch (t.label) {
          case 0: return [4, (0, bl.getEnv().fetch)(n, r)]; case 1: if (!((e = t.sent()).status < 400)) throw new Error(`failed to fetch: (${e.status}) ${e.statusText}, from url: ${e.url}`);

            return [2, e];
        }
      });
    });
  } function Ml(e) { return Vc(this, void 0, void 0, function () { return Gc(this, (t) => { switch (t.label) { case 0: return [4, Al(e)]; case 1: return [2, t.sent().json()]; } }); }); } function Ol(s, u) {
    return Vc(this, void 0, void 0, function () {
      let e, n, r, o, i, a;

      return Gc(this, (t) => { switch (t.label) { case 0: return e = u || bl.getEnv().createCanvasElement(), n = s.shape.slice(Xc(s) ? 1 : 0), r = n[0], o = n[1], i = n[2], [4, zo(a = bt(() => s.as3D(r, o, i).toInt()), e)]; case 1: return t.sent(), a.dispose(), [2, e]; } });
    });
  } function Pl(t, e, n) {
    void 0 === n && (n = !1); const r = bl.getEnv(); const o = r.Image; const i = r.Canvas;

    if (!(t instanceof o || t instanceof i)) throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement'); const a = Cl(t); const s = e / Math.max(a.height, a.width); const u = s * a.width; const c = s * a.height; const l = Rl({width: e, height: e}); const h = t instanceof i ? t : Tl(t); const p = Math.abs(u - c) / 2; const f = n && u < c ? p : 0; const d = n && c < u ? p : 0;

    return _l(l).drawImage(h, f, d, u, c), l;
  } function Fl(t) {
    const e = bl.getEnv(); const n = e.Image; const r = e.Canvas; const o = e.Video;

    return t instanceof n || t instanceof r || t instanceof o;
  } function Ll(i, a) {
    return Vc(this, void 0, void 0, function () {
      let e, n, r, o;

      return Gc(this, (t) => { switch (t.label) { case 0: return e = vl(i, a), n = e.manifestUri, r = e.modelBaseUri, [4, Ml(n)]; case 1: return o = t.sent(), [2, fc.loadWeights(o, r)]; } });
    });
  } function Bl(l, h) {
    return void 0 === h && (h = !1), bt(() => {
      const t = l.shape.slice(1); const e = t[0]; const n = t[1];

      if (e === n) return l; const r = Math.abs(e - n); const o = Math.round(r * (h ? 0.5 : 1)); const i = n < e ? 2 : 1; const a = function (t) {
        const e = l.shape.slice();

        return e[i] = t, he(e, 0);
      }; const s = a(o); const u = r - s.shape[i]; const c = [h && u ? a(u) : null, l, s].filter((t) => !!t).map((t) => t.toFloat());

      return So(c, i);
    });
  }xl(); const zl = (function () {
    function t(t, e) {
      void 0 === e && (e = !1); const o = this;

      if (this._imageTensors = [], this._canvases = [], this._treatAsBatchInput = !1, this._inputDimensions = [], !Array.isArray(t)) throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${t}`); this._treatAsBatchInput = e, this._batchSize = t.length, t.forEach((t, e) => {
        if (Kc(t)) return o._imageTensors[e] = t, void (o._inputDimensions[e] = t.shape); if (Xc(t)) {
          const n = t.shape[0];

          if (n !== 1) throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);

          return o._imageTensors[e] = t, void (o._inputDimensions[e] = t.shape.slice(1));
        } const r = t instanceof bl.getEnv().Canvas ? t : Tl(t);

        o._canvases[e] = r, o._inputDimensions[e] = [r.height, r.width, 3];
      });
    }

    return Object.defineProperty(t.prototype, 'imageTensors', {get() { return this._imageTensors; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'canvases', {get() { return this._canvases; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'isBatchInput', {get() { return this.batchSize > 1 || this._treatAsBatchInput; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'batchSize', {get() { return this._batchSize; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'inputDimensions', {get() { return this._inputDimensions; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'inputSize', {get() { return this._inputSize; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'reshapedInputDimensions', {
      get() {
        const n = this;

        return nl(this.batchSize, 0, 1).map((t, e) => n.getReshapedInputDimensions(e));
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.getInput = function (t) { return this.canvases[t] || this.imageTensors[t]; }, t.prototype.getInputDimensions = function (t) { return this._inputDimensions[t]; }, t.prototype.getInputHeight = function (t) { return this._inputDimensions[t][0]; }, t.prototype.getInputWidth = function (t) { return this._inputDimensions[t][1]; }, t.prototype.getReshapedInputDimensions = function (t) {
      if (typeof this.inputSize !== 'number') throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');

      return tl({width: this.getInputWidth(t), height: this.getInputHeight(t)}, this.inputSize);
    }, t.prototype.toBatchTensor = function (r, o) {
      const i = this;

      return void 0 === o && (o = !0), this._inputSize = r, bt(() => {
        const t = nl(i.batchSize, 0, 1).map((t) => {
          const e = i.getInput(t);

          if (e instanceof Y) {
            let n = Xc(e) ? e : e.expandDims();

            return (n = Bl(n, o)).shape[1] === r && n.shape[2] === r || (n = xu.resizeBilinear(n, [r, r])), n.as3D(r, r, 3);
          } if (e instanceof bl.getEnv().Canvas) return Xo(Pl(e, r, o)); throw new Error(`toBatchTensor - at batchIdx ${t}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${e}`);
        });

        return ci(t.map((t) => t.toFloat())).as4D(i.batchSize, r, r, 3);
      });
    }, t;
  }());

  function Wl(n) {
    return Vc(this, void 0, void 0, function () {
      let r, o, e;

      return Gc(this, (t) => {
        switch (t.label) {
          case 0: if (n instanceof zl) return [2, n]; if (!(r = Array.isArray(n) ? n : [n]).length) throw new Error('toNetInput - empty array passed as input');

            return o = function (t) { return Array.isArray(n) ? ` at input index ${t}:` : ''; }, (e = r.map(Nl)).forEach((t, e) => {
              if (!Fl(t) && !Kc(t) && !Xc(t)) { if (typeof r[e] === 'string') throw new Error(`toNetInput -${o(e)} string passed, but could not resolve HTMLElement for element id ${r[e]}`); throw new Error(`toNetInput -${o(e)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`); } if (Xc(t)) {
                const n = t.shape[0];

                if (n !== 1) throw new Error(`toNetInput -${o(e)} tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);
              }
            }), [4, Promise.all(e.map((t) => Fl(t) && El(t)))]; case 1: return t.sent(), [2, new zl(e, Array.isArray(n))];
        }
      });
    });
  } function Ul(t, e, n) {
    void 0 === n && (n = !0); const r = Math.max(0, Math.min(t.right, e.right) - Math.max(t.left, e.left)) * Math.max(0, Math.min(t.bottom, e.bottom) - Math.max(t.top, e.top));

    return n ? r / (t.area + e.area - r) : r / Math.min(t.area, e.area);
  } function Vl(s, t, u, c) {
    void 0 === c && (c = !0); for (var l = t.map((t, e) => ({score: t, boxIndex: e})).sort((t, e) => t.score - e.score).map((t) => t.boxIndex), h = [], e = function () {
      const t = l.pop();

      h.push(t); for (var e = l, n = [], r = 0; r < e.length; r++) {
        const o = e[r]; const i = s[t]; const a = s[o];

        n.push(Ul(i, a, c));
      }l = l.filter((t, e) => n[e] <= u);
    }; l.length > 0;)e();

    return h;
  } function Gl(s, u) {
    return bt(() => {
      const t = u[0]; const e = u[1]; const n = u[2]; const r = he(s.shape.slice(0, 3).concat([1]), t); const o = he(s.shape.slice(0, 3).concat([1]), e); const i = he(s.shape.slice(0, 3).concat([1]), n); const a = So([r, o, i], 3);

      return ws(s, a);
    });
  } function ql(t) { return 1 / (1 + Math.exp(-t)); } const jl = {
    float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1
  }; const Hl = (function () {
    function t(t) { this._name = t, this._params = void 0, this._paramMappings = []; }

    return Object.defineProperty(t.prototype, 'params', {get() { return this._params; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'paramMappings', {get() { return this._paramMappings; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'isLoaded', {get() { return !!this.params; }, enumerable: !0, configurable: !0}), t.prototype.getParamFromPath = function (t) {
      const e = this.traversePropertyPath(t);

      return e.obj[e.objProp];
    }, t.prototype.reassignParamFromPath = function (t, e) {
      const n = this.traversePropertyPath(t); const r = n.obj; const o = n.objProp;

      r[o].dispose(), r[o] = e;
    }, t.prototype.getParamList = function () {
      const n = this;

      return this._paramMappings.map((t) => {
        const e = t.paramPath;

        return {path: e, tensor: n.getParamFromPath(e)};
      });
    }, t.prototype.getTrainableParams = function () { return this.getParamList().filter((t) => t.tensor instanceof Q); }, t.prototype.getFrozenParams = function () { return this.getParamList().filter((t) => !(t.tensor instanceof Q)); }, t.prototype.variable = function () {
      const r = this;

      this.getFrozenParams().forEach((t) => {
        const e = t.path; const n = t.tensor;

        r.reassignParamFromPath(e, n.variable());
      });
    }, t.prototype.freeze = function () {
      const o = this;

      this.getTrainableParams().forEach((t) => {
        const e = t.path; const n = t.tensor; const r = ee(n.dataSync());

        n.dispose(), o.reassignParamFromPath(e, r);
      });
    }, t.prototype.dispose = function (e) { void 0 === e && (e = !0), this.getParamList().forEach((t) => { if (e && t.tensor.isDisposed) throw new Error(`param tensor has already been disposed for path ${t.path}`); t.tensor.dispose(); }), this._params = void 0; }, t.prototype.serializeParams = function () {
      return new Float32Array(this.getParamList().map((t) => {
        const e = t.tensor;

        return Array.from(e.dataSync());
      }).reduce((t, e) => t.concat(e)));
    }, t.prototype.load = function (e) { return Vc(this, void 0, void 0, function () { return Gc(this, function (t) { switch (t.label) { case 0: return e instanceof Float32Array ? (this.extractWeights(e), [2]) : [4, this.loadFromUri(e)]; case 1: return t.sent(), [2]; } }); }); }, t.prototype.loadFromUri = function (n) {
      return Vc(this, void 0, void 0, function () {
        let e;

        return Gc(this, function (t) {
          switch (t.label) {
            case 0: if (n && typeof n !== 'string') throw new Error(`${this._name}.loadFromUri - expected model uri`);

              return [4, Ll(n, this.getDefaultModelName())]; case 1: return e = t.sent(), this.loadFromWeightMap(e), [2];
          }
        });
      });
    }, t.prototype.loadFromDisk = function (l) {
      return Vc(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s, u, c;

        return Gc(this, function (t) {
          switch (t.label) {
            case 0: if (l && typeof l !== 'string') throw new Error(`${this._name}.loadFromDisk - expected model file path`);

              return e = bl.getEnv().readFile, n = vl(l, this.getDefaultModelName()), r = n.manifestUri, o = n.modelBaseUri, i = (function (i) {
                const t = this;

                return function (f, o, d) {
                  return void 0 === o && (o = ''), Vc(t, void 0, void 0, function () {
                    let a, c, s, u, e, n, r, l, h, p;

                    return Gc(this, (t) => {
                      switch (t.label) {
                        case 0: if (a = f.map(() => !1), c = {}, s = d != null ? d.map(() => !1) : [], u = [], f.forEach((t, o) => {
                          let i = 0;

                          t.weights.forEach((n) => {
                            let t = n.quantization ? n.quantization.dtype : n.dtype; const e = jl[t] * L.sizeFromShape(n.shape); const r = function () { a[o] = !0, c[o] == null && (c[o] = []), c[o].push({manifestEntry: n, groupOffset: i, sizeBytes: e}); };

                            d != null ? d.forEach((t, e) => { t === n.name && (r(), s[e] = !0); }) : r(), u.push(n.name), i += e;
                          });
                        }), !s.every((t) => t) && d) throw e = d.filter((t, e) => !s[e]), new Error(`Could not find weights in manifest with names: ${e.join(', ')}. \nManifest JSON has weights with names: ${u.join(', ')}.`);

                          return n = a.reduce((t, e, n) => e && t.push(n), t, []), r = [], n.forEach((t) => {
                            f[t].paths.forEach((t) => {
                              let e = o + (o.endsWith('/') ? '' : '/') + t;

                              r.push(e);
                            });
                          }), [4, i(r)]; case 1: return l = t.sent(), h = {}, p = 0, n.forEach((t) => {
                          for (var e = f[t].paths.length, n = 0, r = 0; r < e; r++)n += l[p + r].byteLength; for (var o = new ArrayBuffer(n), i = new Uint8Array(o), a = 0, s = 0; s < e; s++) {
                            const u = new Uint8Array(l[p + s]);

                            i.set(u, a), a += u.byteLength;
                          }c[t].forEach((t) => {
 const e = o.slice(t.groupOffset, t.groupOffset + t.sizeBytes); const n = fc.decodeWeights(e, [t.manifestEntry]);

                            for (const r in n)h[r] = n[r]; 
}), p += e;
                        }), [2, h];
                      }
                    });
                  });
                };
              }((t) => Promise.all(t.map((t) => e(t).then((t) => t.buffer))))), u = (s = JSON).parse, [4, e(r)]; case 1: return a = u.apply(s, [t.sent().toString()]), [4, i(a, o)]; case 2: return c = t.sent(), this.loadFromWeightMap(c), [2];
          }
        });
      });
    }, t.prototype.loadFromWeightMap = function (t) {
      const e = this.extractParamsFromWeigthMap(t); const n = e.paramMappings; const r = e.params;

      this._paramMappings = n, this._params = r;
    }, t.prototype.extractWeights = function (t) {
      const e = this.extractParams(t); const n = e.paramMappings; const r = e.params;

      this._paramMappings = n, this._params = r;
    }, t.prototype.traversePropertyPath = function (n) {
      if (!this.params) throw new Error('traversePropertyPath - model has no loaded params'); const t = n.split('/').reduce((t, e) => {
        if (!t.nextObj.hasOwnProperty(e)) throw new Error(`traversePropertyPath - object does not have property ${e}, for path ${n}`);

        return {obj: t.nextObj, objProp: e, nextObj: t.nextObj[e]};
      }, {nextObj: this.params}); const e = t.obj; const r = t.objProp;

      if (!(e && r && e[r] instanceof Y)) throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${n}`);

      return {obj: e, objProp: r};
    }, t;
  }()); const $l = (function (r) {
    function t(t, e, n) { return r.call(this, t, t, '', e, n) || this; }

    return Wc(t, r), t;
  }(ll)); const Kl = (function () {
    function r(t, e) { this._detection = t, this._unshiftedLandmarks = e; }

    return Object.defineProperty(r.prototype, 'detection', {get() { return this._detection; }, enumerable: !0, configurable: !0}), Object.defineProperty(r.prototype, 'unshiftedLandmarks', {get() { return this._unshiftedLandmarks; }, enumerable: !0, configurable: !0}), Object.defineProperty(r.prototype, 'alignedRect', {
      get() {
        const t = this.landmarks.align(); const e = this.detection.imageDims;

        return new $l(this._detection.score, t.rescale(e.reverse()), e);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(r.prototype, 'landmarks', {
      get() {
        const t = this.detection.box; const e = t.x; const n = t.y;

        return this._unshiftedLandmarks.shiftBy(e, n);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(r.prototype, 'faceDetection', {get() { return this.detection; }, enumerable: !0, configurable: !0}), Object.defineProperty(r.prototype, 'faceLandmarks', {get() { return this.landmarks; }, enumerable: !0, configurable: !0}), r.prototype.forSize = function (t, e) {
      const n = this._detection.forSize(t, e);

      return new r(n, this._unshiftedLandmarks.forSize(n.box.width, n.box.height));
    }, r;
  }()); const Xl = (function () {
    function t(t, e, n) {
      void 0 === n && (n = new jc(0, 0)); const r = e.width; const o = e.height;

      this._imgDims = new qc(r, o), this._shift = n, this._positions = t.map((t) => t.mul(new jc(r, o)).add(n));
    }

    return Object.defineProperty(t.prototype, 'shift', {get() { return new jc(this._shift.x, this._shift.y); }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'imageWidth', {get() { return this._imgDims.width; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'imageHeight', {get() { return this._imgDims.height; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'positions', {get() { return this._positions; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'relativePositions', {
      get() {
        const e = this;

        return this._positions.map((t) => t.sub(e._shift).div(new jc(e.imageWidth, e.imageHeight)));
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.forSize = function (t, e) { return new this.constructor(this.relativePositions, {width: t, height: e}); }, t.prototype.shiftBy = function (t, e) { return new this.constructor(this.relativePositions, this._imgDims, new jc(t, e)); }, t.prototype.shiftByPoint = function (t) { return this.shiftBy(t.x, t.y); }, t.prototype.align = function (t) {
      if (t) {
        const e = t instanceof $l ? t.box.floor() : t;

        return this.shiftBy(e.x, e.y).align();
      } const n = this.getRefPointsForAlignment(); const r = n[0]; const o = n[1]; const i = n[2]; const a = function (t) { return i.sub(t).magnitude(); }; const s = (a(r) + a(o)) / 2; const u = Math.floor(s / 0.45); const c = el(n); const l = Math.floor(Math.max(0, c.x - 0.5 * u)); const h = Math.floor(Math.max(0, c.y - 0.43 * u));

      return new pl(l, h, Math.min(u, this.imageWidth + l), Math.min(u, this.imageHeight + h));
    }, t.prototype.getRefPointsForAlignment = function () { throw new Error('getRefPointsForAlignment not implemented by base class'); }, t;
  }()); const Yl = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e.prototype.getRefPointsForAlignment = function () {
      const t = this.positions;

      return [t[0], t[1], el([t[3], t[4]])];
    }, e;
  }(Xl)); const Ql = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e.prototype.getJawOutline = function () { return this.positions.slice(0, 17); }, e.prototype.getLeftEyeBrow = function () { return this.positions.slice(17, 22); }, e.prototype.getRightEyeBrow = function () { return this.positions.slice(22, 27); }, e.prototype.getNose = function () { return this.positions.slice(27, 36); }, e.prototype.getLeftEye = function () { return this.positions.slice(36, 42); }, e.prototype.getRightEye = function () { return this.positions.slice(42, 48); }, e.prototype.getMouth = function () { return this.positions.slice(48, 68); }, e.prototype.getRefPointsForAlignment = function () { return [this.getLeftEye(), this.getRightEye(), this.getMouth()].map(el); }, e;
  }(Xl)); const Jl = (function () {
    function t(t, e) { this._label = t, this._distance = e; }

    return Object.defineProperty(t.prototype, 'label', {get() { return this._label; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'distance', {get() { return this._distance; }, enumerable: !0, configurable: !0}), t.prototype.toString = function (t) { return void 0 === t && (t = !0), this.label + (t ? ` (${Jc(this.distance)})` : ''); }, t;
  }()); const Zl = (function (o) {
    function r(t, e, n) {
      const r = o.call(this, t, e) || this;

      return r._descriptor = n, r;
    }

    return Wc(r, o), Object.defineProperty(r.prototype, 'descriptor', {get() { return this._descriptor; }, enumerable: !0, configurable: !0}), r.prototype.forSize = function (t, e) {
      const n = o.prototype.forSize.call(this, t, e);

      return new r(n.detection, n.landmarks, this.descriptor);
    }, r;
  }(Kl)); const th = (function () {
    function t(t, e) { if (typeof t !== 'string') throw new Error('LabeledFaceDescriptors - constructor expected label to be a string'); if (!Array.isArray(e) || e.some((t) => !(t instanceof Float32Array))) throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array'); this._label = t, this._descriptors = e; }

    return Object.defineProperty(t.prototype, 'label', {get() { return this._label; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'descriptors', {get() { return this._descriptors; }, enumerable: !0, configurable: !0}), t;
  }());

  function eh(i, a, t) {
    if (void 0 === t && (t = !1), i.beginPath(), a.slice(1).forEach((t, e) => {
      const n = t.x; const r = t.y; const o = a[e];

      i.moveTo(o.x, o.y), i.lineTo(n, r);
    }), t) {
      const e = a[a.length - 1]; const n = a[0];

      if (!e || !n) return; i.moveTo(e.x, e.y), i.lineTo(n.x, n.y);
    }i.stroke();
  } function nh(s, u) {
    return Vc(this, void 0, void 0, function () {
      let e, n, r, o, i, a;

      return Gc(this, (t) => {
        switch (t.label) {
          case 0: return e = bl.getEnv().Canvas, (n = s) instanceof e ? [3, 5] : [4, Wl(s)]; case 1: if ((r = t.sent()).batchSize > 1) throw new Error('extractFaces - batchSize > 1 not supported');

            return (o = r.getInput(0)) instanceof e ? (i = o, [3, 4]) : [3, 2]; case 2: return [4, Ol(o)]; case 3: i = t.sent(), t.label = 4; case 4: n = i, t.label = 5; case 5: return a = _l(n), [2, u.map((t) => (t instanceof $l ? t.forSize(n.width, n.height).box.floor() : t)).map((t) => t.clipAtImageBorders(n.width, n.height)).map((t) => {
            const e = t.x; const n = t.y; const r = t.width; const o = t.height; const i = Rl({width: r, height: o});

            return _l(i).putImageData(a.getImageData(e, n, r, o), 0, 0), i;
          })];
        }
      });
    });
  } function rh(u, e) {
    return Vc(this, void 0, void 0, function () {
      return Gc(this, (t) => {
        if (!Kc(u) && !Xc(u)) throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D'); if (Xc(u) && u.shape[0] > 1) throw new Error('extractFaceTensors - batchSize > 1 not supported');

        return [2, bt(() => {
          const t = u.shape.slice(Xc(u) ? 1 : 0); const i = t[0]; const a = t[1]; const s = t[2];

          return e.map((t) => (t instanceof $l ? t.forSize(a, i).box : t)).map((t) => t.clipAtImageBorders(a, i)).map((t) => {
            const e = t.x; const n = t.y; const r = t.width; const o = t.height;

            return Da(u.as3D(i, a, s), [n, e, 0], [o, r, s]);
          });
        })];
      });
    });
  } function oh(e, n, r) {
    return bt(() => {
      let t = ma(e, n.depthwise_filter, n.pointwise_filter, r, 'same');

      return t = ns(t, n.bias);
    });
  } function ih(e, n, r, o) {
    return void 0 === r && (r = 'same'), void 0 === o && (o = !1), bt(() => {
      const t = ns(pa(e, n.filters, [1, 1], r), n.bias);

      return o ? As(t) : t;
    });
  } function ah(a, s) {
    return function (t, e, n, r) {
      const o = ae(a(t * e * n * n), [n, n, t, e]); const i = re(a(e));

      return s.push({paramPath: `${r}/filters`}, {paramPath: `${r}/bias`}), {filters: o, bias: i};
    };
  } const sh = function (t, e, n) { this.depthwise_filter = t, this.pointwise_filter = e, this.bias = n; }; const uh = function (t) { return typeof t === 'number'; };

  function ch(t) {
    if (![t.noObjectScale, t.objectScale, t.coordScale, t.classScale].every(uh)) throw new Error('for training you have to specify noObjectScale, objectScale, coordScale, classScale parameters in your config.json file');

    return t;
  } let lh; let hh; const ph = [3, 16, 32, 64, 128, 256, 512, 1024, 1024];

  function fh(e) {
    return bt(() => {
      const t = ms(e, ne(0.10000000149011612));

      return ns(As(ws(e, t)), t);
    });
  } function dh(e, n) {
    return bt(() => {
      let t = Jo(e, [[0, 0], [1, 1], [1, 1], [0, 0]]);

      return t = pa(t, n.conv.filters, [1, 1], 'valid'), t = ws(t, n.bn.sub), t = ms(t, n.bn.truediv), fh(t = ns(t, n.conv.bias));
    });
  } function mh(e, n) {
    return bt(() => {
      let t = Jo(e, [[0, 0], [1, 1], [1, 1], [0, 0]]);

      return t = ma(t, n.depthwise_filter, n.pointwise_filter, [1, 1], 'valid'), fh(t = ns(t, n.bias));
    });
  } function vh(s, u) {
    const c = ah(s, u); let a; let l; const t = (a = s, l = u, function (t, e, n) {
      const r = ae(a(9 * t), [3, 3, t, 1]); const o = ae(a(t * e), [1, 1, t, e]); const i = re(a(e));

      return l.push({paramPath: `${n}/depthwise_filter`}, {paramPath: `${n}/pointwise_filter`}, {paramPath: `${n}/bias`}), new sh(r, o, i);
    });

    return {
      extractConvParams: c,
      extractConvWithBatchNormParams(t, e, n) {
        let r, o, i, a;

        return {conv: c(t, e, 3, `${n}/conv`), bn: (o = `${n}/bn`, i = re(s(r = e)), a = re(s(r)), u.push({paramPath: `${o}/sub`}, {paramPath: `${o}/truediv`}), {sub: i, truediv: a})};
      },
      extractSeparableConvParams: t
    };
  } function gh(t, e) {
    let o; const n = dl(t, e);

    function r(t) { return {filters: n(`${t}/filters`, 4), bias: n(`${t}/bias`, 1)}; }

    return {
      extractConvParams: r,
      extractConvWithBatchNormParams(t) {
        let e;

        return {conv: r(`${t}/conv`), bn: {sub: n(`${e = `${t}/bn`}/sub`, 1), truediv: n(`${e}/truediv`, 1)}};
      },
      extractSeparableConvParams: (o = n, function (t) {
        const e = o(`${t}/depthwise_filter`, 4); const n = o(`${t}/pointwise_filter`, 4); const r = o(`${t}/bias`, 1);

        return new sh(e, n, r);
      })
    };
  }(hh = lh || (lh = {}))[hh.XS = 224] = 'XS', hh[hh.SM = 320] = 'SM', hh[hh.MD = 416] = 'MD', hh[hh.LG = 608] = 'LG'; const yh = (function () {
    function t(t) {
      const e = void 0 === t ? {} : t; const n = e.inputSize; const r = e.scoreThreshold;

      if (this._name = 'TinyYolov2Options', this._inputSize = n || 416, this._scoreThreshold = r || 0.5, typeof this._inputSize !== 'number' || this._inputSize % 32 != 0) throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`); if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`);
    }

    return Object.defineProperty(t.prototype, 'inputSize', {get() { return this._inputSize; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'scoreThreshold', {get() { return this._scoreThreshold; }, enumerable: !0, configurable: !0}), t;
  }()); const xh = (function (n) {
    function t(t) {
      const e = n.call(this, 'TinyYolov2') || this;

      return (function (t) { if (!t) throw new Error(`invalid config: ${t}`); if (typeof t.withSeparableConvs !== 'boolean') throw new Error(`config.withSeparableConvs has to be a boolean, have: ${t.withSeparableConvs}`); if (!uh(t.iouThreshold) || t.iouThreshold < 0 || t.iouThreshold > 1) throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${t.iouThreshold}`); if (!Array.isArray(t.classes) || !t.classes.length || !t.classes.every((t) => typeof t == 'string')) throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(t.classes)}`); if (!Array.isArray(t.anchors) || !t.anchors.length || !t.anchors.map((t) => t || {}).every((t) => uh(t.x) && uh(t.y))) throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(t.anchors)}`); if (t.meanRgb && (!Array.isArray(t.meanRgb) || t.meanRgb.length !== 3 || !t.meanRgb.every(uh))) throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(t.meanRgb)}`); }(t)), e._config = t, e;
    }

    return Wc(t, n), Object.defineProperty(t.prototype, 'config', {get() { return this._config; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'withClassScores', {get() { return this.config.withClassScores || this.config.classes.length > 1; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'boxEncodingSize', {get() { return 5 + (this.withClassScores ? this.config.classes.length : 0); }, enumerable: !0, configurable: !0}), t.prototype.runTinyYolov2 = function (t, e) {
      let n = dh(t, e.conv0);

      return n = dh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv1), n = dh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv2), n = dh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv3), n = dh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv4), n = dh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv5), ih(n = dh(n = dh(n = _a(n, [2, 2], [1, 1], 'same'), e.conv6), e.conv7), e.conv8, 'valid', !1);
    }, t.prototype.runMobilenet = function (t, e) {
      let n = this.config.isFirstLayerConv2d ? fh(ih(t, e.conv0, 'valid', !1)) : mh(t, e.conv0);

      return n = mh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv1), n = mh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv2), n = mh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv3), n = mh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv4), n = mh(n = _a(n, [2, 2], [2, 2], 'same'), e.conv5), n = _a(n, [2, 2], [1, 1], 'same'), n = e.conv6 ? mh(n, e.conv6) : n, ih(n = e.conv7 ? mh(n, e.conv7) : n, e.conv8, 'valid', !1);
    }, t.prototype.forwardInput = function (e, n) {
      const r = this; const o = this.params;

      if (!o) throw new Error('TinyYolov2 - load model before inference');

      return bt(() => {
        let t = e.toBatchTensor(n, !1).toFloat();

        return t = (t = r.config.meanRgb ? Gl(t, r.config.meanRgb) : t).div(ne(256)), r.config.withSeparableConvs ? r.runMobilenet(t, o) : r.runTinyYolov2(t, o);
      });
    }, t.prototype.forward = function (n, r) {
      return Vc(this, void 0, void 0, function () {
        let e;

        return Gc(this, function (t) { switch (t.label) { case 0: return e = this.forwardInput, [4, Wl(n)]; case 1: return [4, e.apply(this, [t.sent(), r])]; case 2: return [2, t.sent()]; } });
      });
    }, t.prototype.detect = function (m, v) {
      return void 0 === v && (v = {}), Vc(this, void 0, void 0, function () {
        let e; let n; let r; let o; let i; let a; let s; let u; let c; let l; let h; let p; let f; const d = this;

        return Gc(this, function (t) { switch (t.label) { case 0: return e = new yh(v), n = e.inputSize, r = e.scoreThreshold, [4, Wl(m)]; case 1: return o = t.sent(), [4, this.forwardInput(o, n)]; case 2: return i = t.sent(), a = bt(() => pi(i)[0].expandDims()), s = {width: o.getInputWidth(0), height: o.getInputHeight(0)}, u = this.extractBoxes(a, o.getReshapedInputDimensions(0), r), i.dispose(), a.dispose(), c = u.map((t) => t.box), l = u.map((t) => t.score), h = u.map((t) => t.classScore), p = u.map((t) => d.config.classes[t.label]), f = Vl(c.map((t) => t.rescale(n)), l, this.config.iouThreshold, !0), [2, f.map((t) => new ll(l[t], h[t], p[t], c[t], s))]; } });
      });
    }, t.prototype.getDefaultModelName = function () { return ''; }, t.prototype.extractParamsFromWeigthMap = function (t) {
      return (function (t, e) {
        let n; const r = []; const o = gh(t, r); const i = o.extractConvParams; const a = o.extractConvWithBatchNormParams; const s = o.extractSeparableConvParams;

        if (e.withSeparableConvs) {
          const u = e.filterSizes && e.filterSizes.length || 9;

          n = {
            conv0: e.isFirstLayerConv2d ? i('conv0') : s('conv0'), conv1: s('conv1'), conv2: s('conv2'), conv3: s('conv3'), conv4: s('conv4'), conv5: s('conv5'), conv6: u > 7 ? s('conv6') : void 0, conv7: u > 8 ? s('conv7') : void 0, conv8: i('conv8')
          };
        }
        else {
          n = {
            conv0: a('conv0'), conv1: a('conv1'), conv2: a('conv2'), conv3: a('conv3'), conv4: a('conv4'), conv5: a('conv5'), conv6: a('conv6'), conv7: a('conv7'), conv8: i('conv8')
          };
        }

        return fl(t, r), {params: n, paramMappings: r};
      }(t, this.config));
    }, t.prototype.extractParams = function (t) {
      const e = this.config.filterSizes || ph; const n = e ? e.length : void 0;

      if (n !== 7 && n !== 8 && n !== 9) throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${n} filterSizes in config`);

      return (function (t, e, n, r) {
        let o; const i = ml(t); const a = i.extractWeights; const s = i.getRemainingWeights; const u = []; const c = vh(a, u); const l = c.extractConvParams; const h = c.extractConvWithBatchNormParams; const p = c.extractSeparableConvParams;

        if (e.withSeparableConvs) {
          var f = r[0]; var d = r[1]; var m = r[2]; var v = r[3]; var g = r[4]; var y = r[5]; var x = r[6]; var b = r[7]; var w = r[8];

          o = {
            conv0: e.isFirstLayerConv2d ? l(f, d, 3, 'conv0') : p(f, d, 'conv0'), conv1: p(d, m, 'conv1'), conv2: p(m, v, 'conv2'), conv3: p(v, g, 'conv3'), conv4: p(g, y, 'conv4'), conv5: p(y, x, 'conv5'), conv6: b ? p(x, b, 'conv6') : void 0, conv7: w ? p(b, w, 'conv7') : void 0, conv8: l(w || b || x, 5 * n, 1, 'conv8')
          };
        }
        else {
          f = r[0], d = r[1], m = r[2], v = r[3], g = r[4], y = r[5], x = r[6], b = r[7], w = r[8], o = {
            conv0: h(f, d, 'conv0'), conv1: h(d, m, 'conv1'), conv2: h(m, v, 'conv2'), conv3: h(v, g, 'conv3'), conv4: h(g, y, 'conv4'), conv5: h(y, x, 'conv5'), conv6: h(x, b, 'conv6'), conv7: h(b, w, 'conv7'), conv8: l(w, 5 * n, 1, 'conv8')
          };
        } if (s().length !== 0) throw new Error(`weights remaing after extract: ${s().length}`);

        return {params: o, paramMappings: u};
      }(t, this.config, this.boxEncodingSize, e));
    }, t.prototype.extractBoxes = function (e, t, n) {
      for (var r = this, o = t.width, i = t.height, a = Math.max(o, i), s = a / o, u = a / i, c = e.shape[1], l = this.config.anchors.length, h = bt(() => {
          const t = e.reshape([c, c, l, r.boxEncodingSize]);

          return [t.slice([0, 0, 0, 0], [c, c, l, 4]), t.slice([0, 0, 0, 4], [c, c, l, 1]), r.withClassScores ? Qt(t.slice([0, 0, 0, 5], [c, c, l, r.config.classes.length]), 3) : ne(0)];
        }), p = h[0], f = h[1], d = h[2], m = [], v = 0; v < c; v++) {
        for (let g = 0; g < c; g++) {
          for (let y = 0; y < l; y++) {
            let x = ql(f.get(v, g, y, 0));

            if (!n || n < x) {
              let b = (g + ql(p.get(v, g, y, 0))) / c * s; const w = (v + ql(p.get(v, g, y, 1))) / c * u; const E = Math.exp(p.get(v, g, y, 2)) * this.config.anchors[y].x / c * s; const S = Math.exp(p.get(v, g, y, 3)) * this.config.anchors[y].y / c * u; const _ = b - E / 2; const C = w - S / 2; const R = {row: v, col: g, anchor: y}; const T = this.withClassScores ? this.extractPredictedClass(d, R) : {classScore: 1, label: 0}; const k = T.classScore; const I = T.label;

              m.push(Uc({
                box: new sl(_, C, _ + E, C + S), score: x, classScore: x * k, label: I
              }, R));
            }
          }
        }
      }

      return p.dispose(), f.dispose(), d.dispose(), m;
    }, t.prototype.extractPredictedClass = function (n, t) {
      const r = t.row; const o = t.col; const i = t.anchor;

      return Array(this.config.classes.length).fill(0).map((t, e) => n.get(r, o, i, e)).map((t, e) => ({classScore: t, label: e}))
        .reduce((t, e) => (t.classScore > e.classScore ? t : e));
    }, t;
  }(Hl)); const bh = (function () {
    function t(t, e, n, r, o) {
      this._config = o, this._reshapedImgDims = new qc(r.width, r.height), this._outputTensor = t, this._predictedBoxes = n, this.validateGroundTruthBoxes(e), this._groundTruth = this.assignGroundTruthToAnchors(e); const i = this.createGroundTruthMask(); const a = this.createCoordAndScoreMasks(); const s = a.coordBoxOffsetMask; const u = a.coordBoxSizeMask; const c = a.scoreMask;

      this.noObjectLossMask = bt(() => ms(c, ws(ne(1), i))), this.objectLossMask = bt(() => ms(c, i)), this.coordBoxOffsetMask = bt(() => ms(s, i)), this.coordBoxSizeMask = bt(() => ms(u, i)); const l = bt(() => ws(ne(1), s.add(u).add(c)));

      this.groundTruthClassScoresMask = bt(() => ms(l, i));
    }

    return Object.defineProperty(t.prototype, 'config', {get() { return this._config; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'reshapedImgDims', {get() { return this._reshapedImgDims; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'outputTensor', {get() { return this._outputTensor; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'groundTruth', {get() { return this._groundTruth; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'predictedBoxes', {get() { return this._predictedBoxes; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'inputSize', {get() { return Math.max(this.reshapedImgDims.width, this.reshapedImgDims.height); }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'withClassScores', {get() { return this._config.withClassScores || this._config.classes.length > 1; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'boxEncodingSize', {get() { return 5 + (this.withClassScores ? this._config.classes.length : 0); }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'anchors', {get() { return this._config.anchors; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'numBoxes', {get() { return this.anchors.length; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'numCells', {get() { return this.inputSize / 32; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'gridCellEncodingSize', {get() { return this.boxEncodingSize * this.numBoxes; }, enumerable: !0, configurable: !0}), t.prototype.toOutputTensorShape = function (t) {
      const e = this;

      return bt(() => t.reshape([1, e.numCells, e.numCells, e.gridCellEncodingSize]));
    }, t.prototype.computeLoss = function () {
      const i = this;

      return bt(() => {
        const t = i.computeNoObjectLoss(); const e = i.computeObjectLoss(); const n = i.computeCoordLoss(); const r = i.withClassScores ? i.computeClassLoss() : ne(0); const o = bt(() => t.add(e).add(n).add(r));

        return {
          noObjectLoss: t, objectLoss: e, coordLoss: n, classLoss: r, totalLoss: o
        };
      });
    }, t.prototype.computeNoObjectLoss = function () {
      const t = this;

      return bt(() => t.computeLossTerm(t.config.noObjectScale, t.toOutputTensorShape(t.noObjectLossMask), Bi(t.outputTensor)));
    }, t.prototype.computeObjectLoss = function () {
      const t = this;

      return bt(() => t.computeLossTerm(t.config.objectScale, t.toOutputTensorShape(t.objectLossMask), ws(t.toOutputTensorShape(t.computeIous()), Bi(t.outputTensor))));
    }, t.prototype.computeClassLoss = function () {
      const n = this;

      return bt(() => {
        const t = bt(() => {
          const t = ms(Qt(n.outputTensor.reshape([n.numCells, n.numCells, n.numBoxes, n.boxEncodingSize]), 3), n.groundTruthClassScoresMask); const e = n.createOneHotClassScoreMask();

          return ws(e, t);
        });

        return n.computeLossTerm(n.config.classScale, ne(1), t);
      });
    }, t.prototype.computeCoordLoss = function () {
      const t = this;

      return bt(() => t.computeLossTerm(t.config.coordScale, ne(1), ns(t.computeCoordBoxOffsetError(), t.computeCoordBoxSizeError())));
    }, t.prototype.computeCoordBoxOffsetError = function () {
      const r = this;

      return bt(() => {
        const t = r.toOutputTensorShape(r.coordBoxOffsetMask); const e = ms(t, r.toOutputTensorShape(r.computeCoordBoxOffsets())); const n = ms(t, Bi(r.outputTensor));

        return ws(e, n);
      });
    }, t.prototype.computeCoordBoxSizeError = function () {
      const r = this;

      return bt(() => {
        const t = r.toOutputTensorShape(r.coordBoxSizeMask); const e = ms(t, r.toOutputTensorShape(r.computeCoordBoxSizes())); const n = ms(t, r.outputTensor);

        return ws(e, n);
      });
    }, t.prototype.computeLossTerm = function (t, e, n) {
      const r = this;

      return bt(() => ms(ne(t), r.squaredSumOverMask(e, n)));
    }, t.prototype.squaredSumOverMask = function (t, e) { return bt(() => Va(qi(ms(t, e)))); }, t.prototype.validateGroundTruthBoxes = function (t) {
      const a = this;

      t.forEach((t) => {
        const e = t.x; const n = t.y; const r = t.width; const o = t.height; const i = t.label;

        if (typeof i !== 'number' || i < 0 || i > a.config.classes.length - 1) throw new Error(`invalid ground truth data, expected label to be a number in [0, ${a.config.classes.length - 1}]`); if (e < 0 || e > 1 || n < 0 || n > 1 || r < 0 || e + r > 1 || o < 0 || n + o > 1) {
          throw new Error(`invalid ground truth data, box is out of image boundaries ${JSON.stringify({
            x: e, y: n, width: r, height: o
          })}`);
        }
      });
    }, t.prototype.assignGroundTruthToAnchors = function (t) {
      const h = this;

      return t.map((t) => {
        const e = t.x; const n = t.y; const r = t.width; const o = t.height; const i = t.label;

        return {box: new pl(e, n, r, o), label: i};
      }).map((t) => {
        const e = t.box; const n = t.label; const r = e.rescale(h.reshapedImgDims); const o = r.left; const i = r.top; const a = (r.bottom, r.right, r.x, r.y, r.width); const s = r.height; const u = o + a / 2; const c = i + s / 2; const l = Math.floor(u / h.inputSize * h.numCells);

        return {
          row: Math.floor(c / h.inputSize * h.numCells), col: l, anchor: h.anchors.map((t, e) => ({idx: e, iou: Ul(new sl(0, 0, 32 * t.x, 32 * t.y), new sl(0, 0, a, s))})).sort((t, e) => e.iou - t.iou)[0].idx, box: e, label: n
        };
      });
    }, t.prototype.createGroundTruthMask = function () {
      const i = this; const t = le([this.numCells, this.numCells, this.numBoxes, this.boxEncodingSize]); const a = t.buffer();

      return this.groundTruth.forEach((t) => { for (let e = t.row, n = t.col, r = t.anchor, o = 0; o < i.boxEncodingSize; o++)a.set(1, e, n, r, o); }), t;
    }, t.prototype.createCoordAndScoreMasks = function () {
      const c = this;

      return bt(() => {
        for (var t = le([c.numCells, c.numCells, c.numBoxes, c.boxEncodingSize]), e = le([c.numCells, c.numCells, c.numBoxes, c.boxEncodingSize]), n = le([c.numCells, c.numCells, c.numBoxes, c.boxEncodingSize]), r = t.buffer(), o = e.buffer(), i = n.buffer(), a = 0; a < c.numCells; a++) for (let s = 0; s < c.numCells; s++) for (let u = 0; u < c.numBoxes; u++)r.set(1, a, s, u, 0), r.set(1, a, s, u, 1), o.set(1, a, s, u, 2), o.set(1, a, s, u, 3), i.set(1, a, s, u, 4);

        return {coordBoxOffsetMask: t, coordBoxSizeMask: e, scoreMask: n};
      });
    }, t.prototype.createOneHotClassScoreMask = function () {
      const t = le([this.numCells, this.numCells, this.numBoxes, this.boxEncodingSize]); const i = t.buffer();

      return this.groundTruth.forEach((t) => {
        const e = t.row; const n = t.col; const r = t.anchor; const o = t.label;

        i.set(1, e, n, r, 5 + o);
      }), t;
    }, t.prototype.computeIous = function () {
      const c = this; const t = le([this.numCells, this.numCells, this.gridCellEncodingSize]); const l = t.buffer();

      return this.groundTruth.forEach((t) => {
        let e; const n = t.row; const r = t.col; const o = t.anchor; const i = t.box; const a = c.predictedBoxes.find((e = {row: n, col: r, anchor: o}, function (t) { return e.row === t.row && e.col === t.col && e.anchor === t.anchor; }));

        if (!a) throw new Error(`no output box found for: row ${n}, col ${r}, anchor ${o}`); const s = Ul(i.rescale(c.reshapedImgDims), a.box.rescale(c.reshapedImgDims)); const u = c.boxEncodingSize * o;

        l.set(s, n, r, u + 4);
      }), t;
    }, t.prototype.computeCoordBoxOffsets = function () {
      const c = this; const t = le([this.numCells, this.numCells, this.numBoxes, this.boxEncodingSize]); const l = t.buffer();

      return this.groundTruth.forEach((t) => {
        const e = t.row; const n = t.col; const r = t.anchor; const o = t.box.rescale(c.reshapedImgDims); const i = o.left; const a = o.top; const s = ((i + o.right) / 2 - 32 * n) / 32; const u = ((a + o.bottom) / 2 - 32 * e) / 32;

        l.set(s, e, n, r, 0), l.set(u, e, n, r, 1);
      }), t;
    }, t.prototype.computeCoordBoxSizes = function () {
      const c = this; const t = le([this.numCells, this.numCells, this.numBoxes, this.boxEncodingSize]); const l = t.buffer();

      return this.groundTruth.forEach((t) => {
        const e = t.row; const n = t.col; const r = t.anchor; const o = t.box.rescale(c.reshapedImgDims); const i = o.width; const a = o.height; const s = Math.log(i / (32 * c.anchors[r].x)); const u = Math.log(a / (32 * c.anchors[r].y));

        l.set(s, e, n, r, 2), l.set(u, e, n, r, 3);
      }), t;
    }, t;
  }());

  !(function (r) {
    function t(t, e) {
      const n = r.call(this, t) || this;

      return n._trainableConfig = ch(t), n._optimizer = e, n;
    }Wc(t, r), Object.defineProperty(t.prototype, 'trainableConfig', {get() { return this._trainableConfig; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'optimizer', {get() { return this._optimizer; }, enumerable: !0, configurable: !0}), t.prototype.backward = function (o, i, p, a) {
      return void 0 === a && (a = {}), Vc(this, void 0, void 0, function () {
        let n; let r; let s; let u; let c; let l; const h = this;

        return Gc(this, function (t) {
          switch (t.label) {
            case 0: return e = a, n = Object.assign({}, {minBoxSize: 32}, e), r = n.minBoxSize, s = n.reportLosses, u = tl(Cl(o), p), (c = this.filterGroundTruthBoxes(i, u, r)).length ? [4, Wl(Pl(o, p))] : [2, null]; case 1: return l = t.sent(), [2, this.optimizer.minimize(() => {
              const t = h.computeLoss(h.forwardInput(l, p), c, u); const e = t.noObjectLoss; const n = t.objectLoss; const r = t.coordLoss; const o = t.classLoss; const i = t.totalLoss;

              if (s) {
                const a = {
                  losses: {
                    totalLoss: i.dataSync()[0], noObjectLoss: e.dataSync()[0], objectLoss: n.dataSync()[0], coordLoss: r.dataSync()[0], classLoss: o.dataSync()[0]
                  },
                  numBoxes: c.length,
                  inputSize: p
                };

                s(a);
              }

              return i;
            }, !0)];
          } let e;
        });
      });
    }, t.prototype.computeLoss = function (t, e, n) {
      const r = ch(this.config); const o = Math.max(n.width, n.height);

      if (!o) throw new Error(`computeLoss - invalid inputSize: ${o}`); const i = this.extractBoxes(t, n);

      return bt(() => new bh(t, e, i, n, r).computeLoss());
    }, t.prototype.filterGroundTruthBoxes = function (t, e, a) {
      const s = e.height; const u = e.width;

      return t.filter((t) => {
        const e = t.x; const n = t.y; const r = t.width; const o = t.height; const i = new pl(e, n, r, o).rescale({height: s, width: u});

        return !(i.width < a || i.height < a);
      });
    }, t.prototype.load = function (e) { return Vc(this, void 0, void 0, function () { return Gc(this, function (t) { switch (t.label) { case 0: return [4, r.prototype.load.call(this, e)]; case 1: return t.sent(), this.variable(), [2]; } }); }); };
  }(xh)); function wh(a, s) {
    function i(t, e, n) {
      const r = ae(a(9 * t), [3, 3, t, 1]); const o = ae(a(t * e), [1, 1, t, e]); const i = re(a(e));

      return s.push({paramPath: `${n}/depthwise_filter`}, {paramPath: `${n}/pointwise_filter`}, {paramPath: `${n}/bias`}), new sh(r, o, i);
    } const o = ah(a, s);

    function u(t, e, n, r) { return void 0 === r && (r = !1), {conv0: r ? o(t, e, 3, `${n}/conv0`) : i(t, e, `${n}/conv0`), conv1: i(e, e, `${n}/conv1`), conv2: i(e, e, `${n}/conv2`)}; }

    return {
      extractDenseBlock3Params: u,
      extractDenseBlock4Params(t, e, n, r) {
        void 0 === r && (r = !1); const o = u(t, e, n, r);

        return {
          conv0: o.conv0, conv1: o.conv1, conv2: o.conv2, conv3: i(e, e, `${n}/conv3`)
        };
      },
      extractFCParams(t, e, n) {
        const r = oe(a(t * e), [t, e]); const o = re(a(e));

        return s.push({paramPath: `${n}/weights`}, {paramPath: `${n}/bias`}), {weights: r, bias: o};
      }
    };
  } function Eh(t, e) {
    const o = dl(t, e);

    function n(t) { return {filters: o(`${t}/filters`, 4), bias: o(`${t}/bias`, 1)}; } function r(t) {
      const e = o(`${t}/depthwise_filter`, 4); const n = o(`${t}/pointwise_filter`, 4); const r = o(`${t}/bias`, 1);

      return new sh(e, n, r);
    }

    return {
      extractDenseBlock3Params(t, e) { return void 0 === e && (e = !1), {conv0: e ? n(`${t}/conv0`) : r(`${t}/conv0`), conv1: r(`${t}/conv1`), conv2: r(`${t}/conv2`)}; },
      extractDenseBlock4Params(t, e) {
        return void 0 === e && (e = !1), {
          conv0: e ? n(`${t}/conv0`) : r(`${t}/conv0`), conv1: r(`${t}/conv1`), conv2: r(`${t}/conv2`), conv3: r(`${t}/conv3`)
        };
      },
      extractFcParams(t) { return {weights: o(`${t}/weights`, 2), bias: o(`${t}/bias`, 1)}; }
    };
  } const Sh = (function (n) {
    function t(t) {
      const e = n.call(this, t) || this;

      return e.__name = t, e;
    }

    return Wc(t, n), t.prototype.postProcess = function (t, o, e) {
      const i = e.map((t) => {
        const e = t.width; const n = t.height; const r = o / Math.max(n, e);

        return {width: e * r, height: n * r};
      }); const a = i.length;

      return bt(() => {
        const n = function (t, e) { return ci([he([68], t), he([68], e)], 1).as2D(1, 136).as1D(); }; const r = function (t, e) {
          const n = i[t]; const r = n.width; const o = n.height;

          return e(r, o) ? Math.abs(r - o) / 2 : 0;
        };

        return t.mul(he([a, 136], o)).sub(ci(Array.from(Array(a), (t, e) => n(r(e, (t, e) => t < e), r(e, (t, e) => e < t))))).div(ci(Array.from(Array(a), (t, e) => n(i[e].width, i[e].height))));
      });
    }, t.prototype.forwardInput = function (e) {
      const n = this;

      return bt(() => {
        const t = n.runNet(e);

        return n.postProcess(t, e.inputSize, e.inputDimensions.map((t) => ({height: t[0], width: t[1]})));
      });
    }, t.prototype.forward = function (n) {
      return Vc(this, void 0, void 0, function () {
        let e;

        return Gc(this, function (t) { switch (t.label) { case 0: return e = this.forwardInput, [4, Wl(n)]; case 1: return [2, e.apply(this, [t.sent()])]; } });
      });
    }, t.prototype.detectLandmarks = function (o) {
      return Vc(this, void 0, void 0, function () {
        let u; let e; let n; const r = this;

        return Gc(this, (t) => {
          switch (t.label) {
            case 0: return [4, Wl(o)]; case 1: return u = t.sent(), e = bt(() => pi(r.forwardInput(u))), [4, Promise.all(e.map((a, s) => Vc(r, void 0, void 0, function () {
              let e, n, r, o, i;

              return Gc(this, (t) => { switch (t.label) { case 0: return r = (n = Array).from, [4, a.data()]; case 1: return e = r.apply(n, [t.sent()]), o = e.filter((t, e) => Qc(e)), i = e.filter((t, e) => !Qc(e)), [2, new Ql(Array(68).fill(0).map((t, e) => new jc(o[e], i[e])), {height: u.getInputHeight(s), width: u.getInputWidth(s)})]; } });
            })))]; case 2: return n = t.sent(), e.forEach((t) => t.dispose()), [2, u.isBatchInput ? n : n[0]];
          }
        });
      });
    }, t;
  }(Hl));

  function _h(t, e) { return bt(() => ns(aa(t, e.weights), e.bias)); } function Ch(o, i, a) {
    return void 0 === a && (a = !1), bt(() => {
      const t = As(a ? ns(pa(o, i.conv0.filters, [2, 2], 'same'), i.conv0.bias) : oh(o, i.conv0, [2, 2])); const e = oh(t, i.conv1, [1, 1]); const n = oh(As(ns(t, e)), i.conv2, [1, 1]); const r = oh(As(ns(t, ns(e, n))), i.conv3, [1, 1]);

      return As(ns(t, ns(e, ns(n, r))));
    });
  } const Rh = (function (t) {
    function e() { return t.call(this, 'FaceLandmark68Net') || this; }

    return Wc(e, t), e.prototype.runNet = function (e) {
      const n = this.params;

      if (!n) throw new Error('FaceLandmark68Net - load model before inference');

      return bt(() => {
        let t = Ch(Gl(e.toBatchTensor(112, !0), [122.782, 117.001, 104.298]).div(ne(255)), n.dense0, !0);

        return t = Ch(t = Ch(t = Ch(t, n.dense1), n.dense2), n.dense3), _h((t = Ca(t, [7, 7], [2, 2], 'valid')).as2D(t.shape[0], -1), n.fc);
      });
    }, e.prototype.getDefaultModelName = function () { return 'face_landmark_68_model'; }, e.prototype.extractParamsFromWeigthMap = function (t) {
      return r = Eh(e = t, n = []), o = r.extractDenseBlock4Params, i = r.extractFcParams, a = {
        dense0: o('dense0', !0), dense1: o('dense1'), dense2: o('dense2'), dense3: o('dense3'), fc: i('fc')
      }, fl(e, n), {params: a, paramMappings: n}; let e, n, r, o, i, a;
    }, e.prototype.extractParams = function (t) {
      return (function (t) {
        const e = []; const n = ml(t); const r = n.extractWeights; const o = n.getRemainingWeights; const i = wh(r, e); const a = i.extractDenseBlock4Params; const s = i.extractFCParams; const u = a(3, 32, 'dense0', !0); const c = a(32, 64, 'dense1'); const l = a(64, 128, 'dense2'); const h = a(128, 256, 'dense3'); const p = s(256, 136, 'fc');

        if (o().length !== 0) throw new Error(`weights remaing after extract: ${o().length}`);

        return {
          paramMappings: e,
          params: {
            dense0: u, dense1: c, dense2: l, dense3: h, fc: p
          }
        };
      }(t));
    }, e;
  }(Sh));

  function Th(r, o, i) {
    return void 0 === i && (i = !1), bt(() => {
      const t = As(i ? ns(pa(r, o.conv0.filters, [2, 2], 'same'), o.conv0.bias) : oh(r, o.conv0, [2, 2])); const e = oh(t, o.conv1, [1, 1]); const n = oh(As(ns(t, e)), o.conv2, [1, 1]);

      return As(ns(t, ns(e, n)));
    });
  } const kh = (function (t) {
    function e() { return t.call(this, 'FaceLandmark68TinyNet') || this; }

    return Wc(e, t), e.prototype.runNet = function (e) {
      const n = this.params;

      if (!n) throw new Error('FaceLandmark68TinyNet - load model before inference');

      return bt(() => {
        let t = Th(Gl(e.toBatchTensor(112, !0), [122.782, 117.001, 104.298]).div(ne(255)), n.dense0, !0);

        return t = Th(t = Th(t, n.dense1), n.dense2), _h((t = Ca(t, [14, 14], [2, 2], 'valid')).as2D(t.shape[0], -1), n.fc);
      });
    }, e.prototype.getDefaultModelName = function () { return 'face_landmark_68_tiny_model'; }, e.prototype.extractParamsFromWeigthMap = function (t) {
      return r = Eh(e = t, n = []), o = r.extractDenseBlock3Params, i = r.extractFcParams, a = {
        dense0: o('dense0', !0), dense1: o('dense1'), dense2: o('dense2'), fc: i('fc')
      }, fl(e, n), {params: a, paramMappings: n}; let e, n, r, o, i, a;
    }, e.prototype.extractParams = function (t) {
      return (function (t) {
        const e = []; const n = ml(t); const r = n.extractWeights; const o = n.getRemainingWeights; const i = wh(r, e); const a = i.extractDenseBlock3Params; const s = i.extractFCParams; const u = a(3, 32, 'dense0', !0); const c = a(32, 64, 'dense1'); const l = a(64, 128, 'dense2'); const h = s(128, 136, 'fc');

        if (o().length !== 0) throw new Error(`weights remaing after extract: ${o().length}`);

        return {
          paramMappings: e,
          params: {
            dense0: u, dense1: c, dense2: l, fc: h
          }
        };
      }(t));
    }, e;
  }(Sh)); const Ih = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e;
  }(Rh));

  function Dh(t, e, n, r, o) {
    void 0 === o && (o = 'same'); let i; let a; const s = e.conv; const u = s.filters; const c = s.bias; let l = pa(t, u, n, o);

    return l = ns(l, c), i = l, a = e.scale, l = ns(ms(i, a.weights), a.biases), r ? As(l) : l;
  } function Nh(t, e) { return Dh(t, e, [1, 1], !1); } function Ah(t, e) { return Dh(t, e, [2, 2], !0, 'valid'); } function Mh(u, c) {
    function l(t, e, n, r) {
      const o = (function (t, e, n) {
        const r = u(t); const o = r.length / (e * n * n);

        if (Yc(o)) throw new Error(`depth has to be an integer: ${o}, weights.length: ${r.length}, numFilters: ${e}, filterSize: ${n}`);

        return bt(() => Os(ae(r, [e, o, n, n]), [2, 3, 1, 0]));
      }(t, e, n)); const i = re(u(e));

      return c.push({paramPath: `${r}/filters`}, {paramPath: `${r}/bias`}), {filters: o, bias: i};
    } function i(t, e, n, r) {
      let o, i, a, s;

      return {conv: l(t, e, n, `${r}/conv`), scale: (i = `${r}/scale`, a = re(u(o = e)), s = re(u(o)), c.push({paramPath: `${i}/weights`}, {paramPath: `${i}/biases`}), {weights: a, biases: s})};
    }

    return {extractConvLayerParams: i, extractResidualLayerParams(t, e, n, r, o) { return void 0 === o && (o = !1), {conv1: i((o ? 0.5 : 1) * t, e, n, `${r}/conv1`), conv2: i(t, e, n, `${r}/conv2`)}; }};
  } function Oh(t, e) {
    const n = dl(t, e);

    function r(t) {
      let e;

      return {conv: {filters: n(`${t}/conv/filters`, 4), bias: n(`${t}/conv/bias`, 1)}, scale: {weights: n(`${e = t}/scale/weights`, 1), biases: n(`${e}/scale/biases`, 1)}};
    }

    return {extractConvLayerParams: r, extractResidualLayerParams(t) { return {conv1: r(`${t}/conv1`), conv2: r(`${t}/conv2`)}; }};
  } function Ph(t, e) {
    let n; let r; let o = (n = t, r = e.conv1, Dh(n, r, [1, 1], !0));

    return o = Nh(o, e.conv2), o = ns(o, t), o = As(o);
  } function Fh(t, e) {
    let n = Ah(t, e.conv1);

    n = Nh(n, e.conv2); let r = Ca(t, 2, 2, 'valid'); const o = le(r.shape); const i = r.shape[3] !== n.shape[3];

    if (r.shape[1] !== n.shape[1] || r.shape[2] !== n.shape[2]) {
      const a = n.shape.slice();

      a[1] = 1; const s = le(a); const u = (n = So([n, s], 1)).shape.slice();

      u[2] = 1; const c = le(u);

      n = So([n, c], 2);
    }

    return r = i ? So([r, o], 3) : r, n = ns(r, n), n = As(n);
  } const Lh = (function (t) {
    function e() { return t.call(this, 'FaceRecognitionNet') || this; }

    return Wc(e, t), e.prototype.forwardInput = function (n) {
      const r = this.params;

      if (!r) throw new Error('FaceRecognitionNet - load model before inference');

      return bt(() => {
        let t = Ah(Gl(n.toBatchTensor(150, !0).toFloat(), [122.782, 117.001, 104.298]).div(ne(256)), r.conv32_down); const e = (t = Fh(t = Ph(t = Ph(t = Fh(t = Ph(t = Ph(t = Fh(t = Ph(t = Ph(t = Ph(t = Fh(t = Ph(t = Ph(t = Ph(t = _a(t, 3, 2, 'valid'), r.conv32_1), r.conv32_2), r.conv32_3), r.conv64_down), r.conv64_1), r.conv64_2), r.conv64_3), r.conv128_down), r.conv128_1), r.conv128_2), r.conv256_down), r.conv256_1), r.conv256_2), r.conv256_down_out)).mean([1, 2]);

        return aa(e, r.fc);
      });
    }, e.prototype.forward = function (n) {
      return Vc(this, void 0, void 0, function () {
        let e;

        return Gc(this, function (t) { switch (t.label) { case 0: return e = this.forwardInput, [4, Wl(n)]; case 1: return [2, e.apply(this, [t.sent()])]; } });
      });
    }, e.prototype.computeFaceDescriptor = function (i) {
      return Vc(this, void 0, void 0, function () {
        let e; let n; let r; const o = this;

        return Gc(this, (t) => { switch (t.label) { case 0: return [4, Wl(i)]; case 1: return e = t.sent(), n = bt(() => pi(o.forwardInput(e))), [4, Promise.all(n.map((t) => t.data()))]; case 2: return r = t.sent(), n.forEach((t) => t.dispose()), [2, e.isBatchInput ? r : r[0]]; } });
      });
    }, e.prototype.getDefaultModelName = function () { return 'face_recognition_model'; }, e.prototype.extractParamsFromWeigthMap = function (t) {
      return (function (t) {
        const e = []; const n = Oh(t, e); const r = n.extractConvLayerParams; const o = n.extractResidualLayerParams; const i = r('conv32_down'); const a = o('conv32_1'); const s = o('conv32_2'); const u = o('conv32_3'); const c = o('conv64_down'); const l = o('conv64_1'); const h = o('conv64_2'); const p = o('conv64_3'); const f = o('conv128_down'); const d = o('conv128_1'); const m = o('conv128_2'); const v = o('conv256_down'); const g = o('conv256_1'); const y = o('conv256_2'); const x = o('conv256_down_out'); const b = t.fc;

        if (e.push({originalPath: 'fc', paramPath: 'fc'}), !$c(b)) throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${b}`); const w = {
          conv32_down: i, conv32_1: a, conv32_2: s, conv32_3: u, conv64_down: c, conv64_1: l, conv64_2: h, conv64_3: p, conv128_down: f, conv128_1: d, conv128_2: m, conv256_down: v, conv256_1: g, conv256_2: y, conv256_down_out: x, fc: b
        };

        return fl(t, e), {params: w, paramMappings: e};
      }(t));
    }, e.prototype.extractParams = function (t) {
      return (function (t) {
        const e = ml(t); const n = e.extractWeights; const r = e.getRemainingWeights; const o = []; const i = Mh(n, o); const a = i.extractConvLayerParams; const s = i.extractResidualLayerParams; const u = a(4704, 32, 7, 'conv32_down'); const c = s(9216, 32, 3, 'conv32_1'); const l = s(9216, 32, 3, 'conv32_2'); const h = s(9216, 32, 3, 'conv32_3'); const p = s(36864, 64, 3, 'conv64_down', !0); const f = s(36864, 64, 3, 'conv64_1'); const d = s(36864, 64, 3, 'conv64_2'); const m = s(36864, 64, 3, 'conv64_3'); const v = s(147456, 128, 3, 'conv128_down', !0); const g = s(147456, 128, 3, 'conv128_1'); const y = s(147456, 128, 3, 'conv128_2'); const x = s(589824, 256, 3, 'conv256_down', !0); const b = s(589824, 256, 3, 'conv256_1'); const w = s(589824, 256, 3, 'conv256_2'); const E = s(589824, 256, 3, 'conv256_down_out'); const S = bt(() => Os(oe(n(32768), [128, 256]), [1, 0]));

        if (o.push({paramPath: 'fc'}), r().length !== 0) throw new Error(`weights remaing after extract: ${r().length}`);

        return {
          params: {
            conv32_down: u, conv32_1: c, conv32_2: l, conv32_3: h, conv64_down: p, conv64_1: f, conv64_2: d, conv64_3: m, conv128_down: v, conv128_1: g, conv128_2: y, conv256_down: x, conv256_1: b, conv256_2: w, conv256_down_out: E, fc: S
          },
          paramMappings: o
        };
      }(t));
    }, e;
  }(Hl)); const Bh = (function () {
    function t(t) {
      const e = void 0 === t ? {} : t; const n = e.minFaceSize; const r = e.scaleFactor; const o = e.maxNumScales; const i = e.scoreThresholds; const a = e.scaleSteps;

      if (this._name = 'MtcnnOptions', this._minFaceSize = n || 20, this._scaleFactor = r || 0.709, this._maxNumScales = o || 10, this._scoreThresholds = i || [0.6, 0.7, 0.7], this._scaleSteps = a, typeof this._minFaceSize !== 'number' || this._minFaceSize < 0) throw new Error(`${this._name} - expected minFaceSize to be a number > 0`); if (typeof this._scaleFactor !== 'number' || this._scaleFactor <= 0 || this._scaleFactor >= 1) throw new Error(`${this._name} - expected scaleFactor to be a number between 0 and 1`); if (typeof this._maxNumScales !== 'number' || this._maxNumScales < 0) throw new Error(`${this._name} - expected maxNumScales to be a number > 0`); if (!Array.isArray(this._scoreThresholds) || this._scoreThresholds.length !== 3 || this._scoreThresholds.some((t) => typeof t !== 'number')) throw new Error(`${this._name} - expected scoreThresholds to be an array of numbers of length 3`); if (this._scaleSteps && (!Array.isArray(this._scaleSteps) || this._scaleSteps.some((t) => typeof t !== 'number'))) throw new Error(`${this._name} - expected scaleSteps to be an array of numbers`);
    }

    return Object.defineProperty(t.prototype, 'minFaceSize', {get() { return this._minFaceSize; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'scaleFactor', {get() { return this._scaleFactor; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'maxNumScales', {get() { return this._maxNumScales; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'scoreThresholds', {get() { return this._scoreThresholds; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'scaleSteps', {get() { return this._scaleSteps; }, enumerable: !0, configurable: !0}), t;
  }());

  function zh(l, h) {
    function i(t, e, n, r, o) {
      const i = ae(l(t * e * n * n), [n, n, t, e]); const a = re(l(e));

      return h.push({paramPath: `${r}/filters`}, {paramPath: `${r}/${o ? 'batch_norm_offset' : 'bias'}`}), {filters: i, bias: a};
    } function p(t, e, n, r) {
      const o = i(t, e, n, r, !0);

      return {filters: o.filters, batch_norm_offset: o.bias};
    } function t(t, e, n) {
      let r, o, i, a, s, u, c;

      return {
        depthwise_conv: (o = `${n}/depthwise_conv`, i = ae(l(9 * (r = t)), [3, 3, r, 1]), a = re(l(r)), s = re(l(r)), u = re(l(r)), c = re(l(r)), h.push({paramPath: `${o}/filters`}, {paramPath: `${o}/batch_norm_scale`}, {paramPath: `${o}/batch_norm_offset`}, {paramPath: `${o}/batch_norm_mean`}, {paramPath: `${o}/batch_norm_variance`}), {
          filters: i, batch_norm_scale: a, batch_norm_offset: s, batch_norm_mean: u, batch_norm_variance: c
        }),
        pointwise_conv: p(t, e, 1, `${n}/pointwise_conv`)
      };
    }

    return {
      extractMobilenetV1Params() {
        return {
          conv_0: p(3, 32, 3, 'mobilenetv1/conv_0'), conv_1: t(32, 64, 'mobilenetv1/conv_1'), conv_2: t(64, 128, 'mobilenetv1/conv_2'), conv_3: t(128, 128, 'mobilenetv1/conv_3'), conv_4: t(128, 256, 'mobilenetv1/conv_4'), conv_5: t(256, 256, 'mobilenetv1/conv_5'), conv_6: t(256, 512, 'mobilenetv1/conv_6'), conv_7: t(512, 512, 'mobilenetv1/conv_7'), conv_8: t(512, 512, 'mobilenetv1/conv_8'), conv_9: t(512, 512, 'mobilenetv1/conv_9'), conv_10: t(512, 512, 'mobilenetv1/conv_10'), conv_11: t(512, 512, 'mobilenetv1/conv_11'), conv_12: t(512, 1024, 'mobilenetv1/conv_12'), conv_13: t(1024, 1024, 'mobilenetv1/conv_13')
        };
      },
      extractPredictionLayerParams() {
        return {
          conv_0: p(1024, 256, 1, 'prediction_layer/conv_0'), conv_1: p(256, 512, 3, 'prediction_layer/conv_1'), conv_2: p(512, 128, 1, 'prediction_layer/conv_2'), conv_3: p(128, 256, 3, 'prediction_layer/conv_3'), conv_4: p(256, 128, 1, 'prediction_layer/conv_4'), conv_5: p(128, 256, 3, 'prediction_layer/conv_5'), conv_6: p(256, 64, 1, 'prediction_layer/conv_6'), conv_7: p(64, 128, 3, 'prediction_layer/conv_7'), box_predictor_0: {box_encoding_predictor: i(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor'), class_predictor: i(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor')}, box_predictor_1: {box_encoding_predictor: i(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor'), class_predictor: i(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor')}, box_predictor_2: {box_encoding_predictor: i(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor'), class_predictor: i(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor')}, box_predictor_3: {box_encoding_predictor: i(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor'), class_predictor: i(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor')}, box_predictor_4: {box_encoding_predictor: i(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor'), class_predictor: i(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor')}, box_predictor_5: {box_encoding_predictor: i(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor'), class_predictor: i(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor')}
        };
      }
    };
  } function Wh(t) {
    const e = []; const n = (function (t, e) {
      const i = dl(t, e);

      function a(t, e, n) { return {filters: i(`${t}/Conv2d_${e}_pointwise/weights`, 4, `${n}/filters`), batch_norm_offset: i(`${t}/Conv2d_${e}_pointwise/convolution_bn_offset`, 1, `${n}/batch_norm_offset`)}; } function n(t) {
        const e = `mobilenetv1/conv_${t}`; const n = `MobilenetV1/Conv2d_${t}_depthwise`; const r = `${e}/depthwise_conv`; const o = `${e}/pointwise_conv`;

        return {
          depthwise_conv: {
            filters: i(`${n}/depthwise_weights`, 4, `${r}/filters`), batch_norm_scale: i(`${n}/BatchNorm/gamma`, 1, `${r}/batch_norm_scale`), batch_norm_offset: i(`${n}/BatchNorm/beta`, 1, `${r}/batch_norm_offset`), batch_norm_mean: i(`${n}/BatchNorm/moving_mean`, 1, `${r}/batch_norm_mean`), batch_norm_variance: i(`${n}/BatchNorm/moving_variance`, 1, `${r}/batch_norm_variance`)
          },
          pointwise_conv: a('MobilenetV1', t, o)
        };
      } function r(t, e) { return {filters: i(`${t}/weights`, 4, `${e}/filters`), bias: i(`${t}/biases`, 1, `${e}/bias`)}; } function o(t) { return {box_encoding_predictor: r(`Prediction/BoxPredictor_${t}/BoxEncodingPredictor`, `prediction_layer/box_predictor_${t}/box_encoding_predictor`), class_predictor: r(`Prediction/BoxPredictor_${t}/ClassPredictor`, `prediction_layer/box_predictor_${t}/class_predictor`)}; }

      return {
        extractMobilenetV1Params() {
          return {
            conv_0: a('MobilenetV1', 0, 'mobilenetv1/conv_0'), conv_1: n(1), conv_2: n(2), conv_3: n(3), conv_4: n(4), conv_5: n(5), conv_6: n(6), conv_7: n(7), conv_8: n(8), conv_9: n(9), conv_10: n(10), conv_11: n(11), conv_12: n(12), conv_13: n(13)
          };
        },
        extractPredictionLayerParams() {
          return {
            conv_0: a('Prediction', 0, 'prediction_layer/conv_0'), conv_1: a('Prediction', 1, 'prediction_layer/conv_1'), conv_2: a('Prediction', 2, 'prediction_layer/conv_2'), conv_3: a('Prediction', 3, 'prediction_layer/conv_3'), conv_4: a('Prediction', 4, 'prediction_layer/conv_4'), conv_5: a('Prediction', 5, 'prediction_layer/conv_5'), conv_6: a('Prediction', 6, 'prediction_layer/conv_6'), conv_7: a('Prediction', 7, 'prediction_layer/conv_7'), box_predictor_0: o(0), box_predictor_1: o(1), box_predictor_2: o(2), box_predictor_3: o(3), box_predictor_4: o(4), box_predictor_5: o(5)
          };
        }
      };
    }(t, e)); const r = n.extractMobilenetV1Params; const o = n.extractPredictionLayerParams; const i = t['Output/extra_dim'];

    if (e.push({originalPath: 'Output/extra_dim', paramPath: 'output_layer/extra_dim'}), !Kc(i)) throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${i}`); const a = {mobilenetv1: r(), prediction_layer: o(), output_layer: {extra_dim: i}};

    return fl(t, e), {params: a, paramMappings: e};
  } function Uh(e, n, r) {
    return bt(() => {
      let t = pa(e, n.filters, r, 'same');

      return t = ns(t, n.batch_norm_offset), _i(t, 0, 6);
    });
  } const Vh = 0.0010000000474974513;

  function Gh(t, e) {
    return bt(() => {
      let u = null; let c = Uh(t, e.conv_0, [2, 2]);

      if ([e.conv_1, e.conv_2, e.conv_3, e.conv_4, e.conv_5, e.conv_6, e.conv_7, e.conv_8, e.conv_9, e.conv_10, e.conv_11, e.conv_12, e.conv_13].forEach((t, e) => {
        let n; let r; let o; let i; const a = e + 1; const s = (n = a, [2, 4, 6, 12].some((t) => t === n) ? [2, 2] : [1, 1]);

        r = c, o = t.depthwise_conv, i = s, c = Uh(c = bt(() => {
          let t = da(r, o.filters, i, 'same');

          return t = Ji(t, o.batch_norm_mean, o.batch_norm_variance, Vh, o.batch_norm_scale, o.batch_norm_offset), _i(t, 0, 6);
        }), t.pointwise_conv, [1, 1]), a === 11 && (u = c);
      }), u === null) throw new Error('mobileNetV1 - output of conv layer 11 is null');

      return {out: c, conv11: u};
    });
  } function qh(t, e, n) {
    const r = Math.min(t.get(e, 0), t.get(e, 2)); const o = Math.min(t.get(e, 1), t.get(e, 3)); const i = Math.max(t.get(e, 0), t.get(e, 2)); const a = Math.max(t.get(e, 1), t.get(e, 3)); const s = Math.min(t.get(n, 0), t.get(n, 2)); const u = Math.min(t.get(n, 1), t.get(n, 3)); const c = Math.max(t.get(n, 0), t.get(n, 2)); const l = Math.max(t.get(n, 1), t.get(n, 3)); const h = (i - r) * (a - o); const p = (c - s) * (l - u);

    if (h <= 0 || p <= 0) return 0; const f = Math.max(r, s); const d = Math.max(o, u); const m = Math.min(i, c); const v = Math.min(a, l); const g = Math.max(m - f, 0) * Math.max(v - d, 0);

    return g / (h + p - g);
  } function jh(t, e) {
    let n; let r; const o = (n = pi(Os(t, [1, 0])), {sizes: r = [ws(n[2], n[0]), ws(n[3], n[1])], centers: [ns(n[0], as(r[0], ne(2))), ns(n[1], as(r[1], ne(2)))]}); const i = o.sizes; const a = o.centers; const s = pi(Os(e, [1, 0])); const u = as(ms(ki(as(s[2], ne(5))), i[0]), ne(2)); const c = ns(ms(as(s[0], ne(10)), i[0]), a[0]); const l = as(ms(ki(as(s[3], ne(5))), i[1]), ne(2)); const h = ns(ms(as(s[1], ne(10)), i[1]), a[1]);

    return Os(ci([ws(c, u), ws(h, l), ns(c, u), ns(h, l)]), [1, 0]);
  } function Hh(e, n) {
    return bt(() => {
      const t = e.shape[0];

      return {boxPredictionEncoding: ai(ih(e, n.box_encoding_predictor), [t, -1, 1, 4]), classPrediction: ai(ih(e, n.class_predictor), [t, -1, 3])};
    });
  } const $h = (function () {
    function t(t) {
      const e = void 0 === t ? {} : t; const n = e.minConfidence; const r = e.maxResults;

      if (this._name = 'SsdMobilenetv1Options', this._minConfidence = n || 0.5, this._maxResults = r || 100, typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`); if (typeof this._maxResults !== 'number') throw new Error(`${this._name} - expected maxResults to be a number`);
    }

    return Object.defineProperty(t.prototype, 'minConfidence', {get() { return this._minConfidence; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'maxResults', {get() { return this._maxResults; }, enumerable: !0, configurable: !0}), t;
  }()); const Kh = (function (t) {
    function e() { return t.call(this, 'SsdMobilenetv1') || this; }

    return Wc(e, t), e.prototype.forwardInput = function (u) {
      const c = this.params;

      if (!c) throw new Error('SsdMobilenetv1 - load model before inference');

      return bt(() => {
        let l; let h; let p; let o; let i; let a; const t = u.toBatchTensor(512, !1).toFloat(); const e = Gh(ws(ms(t, ne(0.007843137718737125)), ne(1)), c.mobilenetv1); const n = (l = e.out, h = e.conv11, p = c.prediction_layer, bt(() => {
          const t = Uh(Uh(l, p.conv_0, [1, 1]), p.conv_1, [2, 2]); const e = Uh(Uh(t, p.conv_2, [1, 1]), p.conv_3, [2, 2]); const n = Uh(Uh(e, p.conv_4, [1, 1]), p.conv_5, [2, 2]); const r = Uh(Uh(n, p.conv_6, [1, 1]), p.conv_7, [2, 2]); const o = Hh(h, p.box_predictor_0); const i = Hh(l, p.box_predictor_1); const a = Hh(t, p.box_predictor_2); const s = Hh(e, p.box_predictor_3); const u = Hh(n, p.box_predictor_4); const c = Hh(r, p.box_predictor_5);

          return {boxPredictions: So([o.boxPredictionEncoding, i.boxPredictionEncoding, a.boxPredictionEncoding, s.boxPredictionEncoding, u.boxPredictionEncoding, c.boxPredictionEncoding], 1), classPredictions: So([o.classPrediction, i.classPrediction, a.classPrediction, s.classPrediction, u.classPrediction, c.classPrediction], 1)};
        })); const r = n.boxPredictions; const s = n.classPredictions;

        return o = r, i = s, a = c.output_layer, bt(() => {
          const t = o.shape[0]; let e = jh(ai(li(a.extra_dim, [t, 1, 1]), [-1, 4]), ai(o, [-1, 4]));

          e = ai(e, [t, e.shape[0] / t, 4]); const n = Bi(Ta(i, [0, 0, 1], [-1, -1, -1])); let r = Ta(n, [0, 0, 0], [-1, -1, 1]);

          return r = ai(r, [t, r.shape[1]]), {boxes: pi(e), scores: pi(r)};
        });
      });
    }, e.prototype.forward = function (n) {
      return Vc(this, void 0, void 0, function () {
        let e;

        return Gc(this, function (t) { switch (t.label) { case 0: return e = this.forwardInput, [4, Wl(n)]; case 1: return [2, e.apply(this, [t.sent()])]; } });
      });
    }, e.prototype.locateFaces = function (I, D) {
      return void 0 === D && (D = {}), Vc(this, void 0, void 0, function () {
        let l, h, p, f, d, m, v, g, y, x, b, w, E, S, _, C, R, T, k;

        return Gc(this, function (t) {
          switch (t.label) {
            case 0: return l = new $h(D), h = l.maxResults, p = l.minConfidence, [4, Wl(I)]; case 1: for (f = t.sent(), d = this.forwardInput(f), m = d.boxes, v = d.scores, g = m[0], y = v[0], x = 1; x < m.length; x++)m[x].dispose(), v[x].dispose();

              return E = (w = Array).from, [4, y.data()]; case 2: return b = E.apply(w, [t.sent()]), e = b, n = h, i = 0.5, a = p, r = (o = g).shape[0], s = Math.min(n, r), u = e.map((t, e) => ({score: t, boxIndex: e})).filter((t) => t.score > a).sort((t, e) => e.score - t.score), c = [], u.forEach((t) => {
              if (!(c.length >= s)) {
                for (var e = t.score, n = c.length - 1; n >= 0; --n) {
                  const r = qh(o, t.boxIndex, c[n]);

                  if (r !== 0 && (t.score *= r <= i ? 1 : 0, t.score <= a)) break;
                }e === t.score && c.push(t.boxIndex);
              }
            }), S = c, _ = f.getReshapedInputDimensions(0), C = f.inputSize, R = C / _.width, T = C / _.height, k = S.map((t) => {
              const e = [Math.max(0, g.get(t, 0)), Math.min(1, g.get(t, 2))].map((t) => t * T); const n = e[0]; const r = e[1]; const o = [Math.max(0, g.get(t, 1)), Math.min(1, g.get(t, 3))].map((t) => t * R); const i = o[0]; const a = o[1];

              return new $l(b[t], new pl(i, n, a - i, r - n), {height: f.getInputHeight(0), width: f.getInputWidth(0)});
            }), g.dispose(), y.dispose(), [2, k];
          } let o, e, n, i, a, r, s, u, c;
        });
      });
    }, e.prototype.getDefaultModelName = function () { return 'ssd_mobilenetv1_model'; }, e.prototype.extractParamsFromWeigthMap = function (t) { return Wh(t); }, e.prototype.extractParams = function (t) {
      return (function (t) {
        const e = []; const n = ml(t); const r = n.extractWeights; const o = n.getRemainingWeights; const i = zh(r, e); const a = i.extractMobilenetV1Params; const s = i.extractPredictionLayerParams; const u = a(); const c = s(); const l = {extra_dim: ie(r(20472), [1, 5118, 4])};

        if (e.push({paramPath: 'output_layer/extra_dim'}), o().length !== 0) throw new Error(`weights remaing after extract: ${o().length}`);

        return {params: {mobilenetv1: u, prediction_layer: c, output_layer: l}, paramMappings: e};
      }(t));
    }, e;
  }(Hl));

  function Xh(t) {
    const e = new Kh();

    return e.extractWeights(t), e;
  } const Yh = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e;
  }(Kh)); const Qh = (function (e) {
    function t() {
      const t = e !== null && e.apply(this, arguments) || this;

      return t._name = 'TinyFaceDetectorOptions', t;
    }

    return Wc(t, e), t;
  }(yh)); const Jh = (function () {
    function t() {}

    return t.prototype.then = function (n) {
      return Vc(this, void 0, void 0, function () {
        let e;

        return Gc(this, function (t) { switch (t.label) { case 0: return e = n, [4, this.run()]; case 1: return [2, e.apply(void 0, [t.sent()])]; } });
      });
    }, t.prototype.run = function () { return Vc(this, void 0, void 0, function () { return Gc(this, (t) => { throw new Error('ComposableTask - run is not implemented'); }); }); }, t;
  }()); const Zh = 2; const tp = 12;

  function ep(r, o) {
    let i; let a; const u = ah(r, o); const c = (i = r, a = o, function (t, e, n) {
      const r = oe(i(t * e), [t, e]); const o = re(i(e));

      return a.push({paramPath: `${n}/weights`}, {paramPath: `${n}/bias`}), {weights: r, bias: o};
    });

    function l(t, e) {
      const n = re(r(t));

      return o.push({paramPath: e}), n;
    } function h(t, e, n) {
      return void 0 === n && (n = !1), {
        conv1: u(t[0], t[1], 3, `${e}/conv1`), prelu1_alpha: l(t[1], `${e}/prelu1_alpha`), conv2: u(t[1], t[2], 3, `${e}/conv2`), prelu2_alpha: l(t[2], `${e}/prelu2_alpha`), conv3: u(t[2], t[3], n ? 2 : 3, `${e}/conv3`), prelu3_alpha: l(t[3], `${e}/prelu3_alpha`)
      };
    }

    return {
      extractPNetParams() {
        const t = h([3, 10, 16, 32], 'pnet'); const e = u(32, 2, 1, 'pnet/conv4_1'); const n = u(32, 4, 1, 'pnet/conv4_2');

        return Uc({}, t, {conv4_1: e, conv4_2: n});
      },
      extractRNetParams() {
        const t = h([3, 28, 48, 64], 'rnet', !0); const e = c(576, 128, 'rnet/fc1'); const n = l(128, 'rnet/prelu4_alpha'); const r = c(128, 2, 'rnet/fc2_1'); const o = c(128, 4, 'rnet/fc2_2');

        return Uc({}, t, {
          fc1: e, prelu4_alpha: n, fc2_1: r, fc2_2: o
        });
      },
      extractONetParams() {
        const t = h([3, 32, 64, 64], 'onet'); const e = u(64, 128, 2, 'onet/conv4'); const n = l(128, 'onet/prelu4_alpha'); const r = c(1152, 256, 'onet/fc1'); const o = l(256, 'onet/prelu5_alpha'); const i = c(256, 2, 'onet/fc2_1'); const a = c(256, 4, 'onet/fc2_2'); const s = c(256, 10, 'onet/fc2_3');

        return Uc({}, t, {
          conv4: e, prelu4_alpha: n, fc1: r, prelu5_alpha: o, fc2_1: i, fc2_2: a, fc2_3: s
        });
      }
    };
  } function np(t) {
    const e = []; const n = (function (t, e) {
      const n = dl(t, e);

      function u(t) { return {filters: n(`${t}/weights`, 4, `${t}/filters`), bias: n(`${t}/bias`, 1)}; } function c(t) { return {weights: n(`${t}/weights`, 2), bias: n(`${t}/bias`, 1)}; } function l(t) { return n(t, 1); } function h(t) {
        return {
          conv1: u(`${t}/conv1`), prelu1_alpha: l(`${t}/prelu1_alpha`), conv2: u(`${t}/conv2`), prelu2_alpha: l(`${t}/prelu2_alpha`), conv3: u(`${t}/conv3`), prelu3_alpha: l(`${t}/prelu3_alpha`)
        };
      }

      return {
        extractPNetParams() {
          const t = h('pnet'); const e = u('pnet/conv4_1'); const n = u('pnet/conv4_2');

          return Uc({}, t, {conv4_1: e, conv4_2: n});
        },
        extractRNetParams() {
          const t = h('rnet'); const e = c('rnet/fc1'); const n = l('rnet/prelu4_alpha'); const r = c('rnet/fc2_1'); const o = c('rnet/fc2_2');

          return Uc({}, t, {
            fc1: e, prelu4_alpha: n, fc2_1: r, fc2_2: o
          });
        },
        extractONetParams() {
          const t = h('onet'); const e = u('onet/conv4'); const n = l('onet/prelu4_alpha'); const r = c('onet/fc1'); const o = l('onet/prelu5_alpha'); const i = c('onet/fc2_1'); const a = c('onet/fc2_2'); const s = c('onet/fc2_3');

          return Uc({}, t, {
            conv4: e, prelu4_alpha: n, fc1: r, prelu5_alpha: o, fc2_1: i, fc2_2: a, fc2_3: s
          });
        }
      };
    }(t, e)); const r = n.extractPNetParams; const o = n.extractRNetParams; const i = n.extractONetParams; const a = r(); const s = o(); const u = i();

    return fl(t, e), {params: {pnet: a, rnet: s, onet: u}, paramMappings: e};
  } function rp(t, e) {
    const n = e[0]; const r = e[1];

    return {height: Math.floor(n * t), width: Math.floor(r * t)};
  } const op = (function (o) {
    function t(t, e, n, r) {
      return o.call(this, {
        left: t, top: e, right: n, bottom: r
      }, !0) || this;
    }

    return Wc(t, o), t;
  }(al));

  function ip(t) { return bt(() => ms(ws(t, ne(127.5)), ne(0.0078125))); } function ap(t, e) { return bt(() => ns(As(t), ms(e, Oi(As(Oi(t)))))); } function sp(e, n, r) {
    return void 0 === r && (r = !1), bt(() => {
      let t = ih(e, n.conv1, 'valid');

      return t = ap(t, n.prelu1_alpha), t = ap(t = ih(t = _a(t, r ? [2, 2] : [3, 3], [2, 2], 'same'), n.conv2, 'valid'), n.prelu2_alpha), t = ap(t = ih(t = r ? t : _a(t, [3, 3], [2, 2], 'valid'), n.conv3, 'valid'), n.prelu3_alpha);
    });
  } function up(h, t, u, p, c) {
    c.stage1 = []; const e = t.map((l) => bt(() => {
      let o; let i; let r; let a; const t = {scale: l}; const e = (o = h, i = l, bt(() => {
        let t = rp(i, o.shape.slice(1)); const e = t.height; const n = t.width; const r = ip(xu.resizeBilinear(o, [e, n]));

        return Os(r, [0, 2, 1, 3]);
      })); const n = Date.now(); const s = (r = e, a = p, bt(() => {
 const t = sp(r, a, !0); const e = ih(t, a.conv4_1, 'valid'); const n = $o(Ba(e, 3), 3);

        return {prob: Qt(ws(e, n), 3), regions: ih(t, a.conv4_2, 'valid')}; 
})); const u = s.prob; const c = s.regions;

      return t.pnet = Date.now() - n, {
        scoresTensor: pi(pi(u, 3)[1])[0], regionsTensor: pi(c)[0], scale: l, statsForScale: t
      };
    })).map((t) => {
      const e = t.scoresTensor; const n = t.regionsTensor; const r = t.scale; const o = t.statsForScale; const i = (function (e, n, r, t) {
        for (var o = [], i = 0; i < e.shape[0]; i++) for (let a = 0; a < e.shape[1]; a++)e.get(i, a) >= t && o.push(new jc(a, i));

        return o.map((t) => ({cell: new sl(Math.round((t.y * Zh + 1) / r), Math.round((t.x * Zh + 1) / r), Math.round((t.y * Zh + tp) / r), Math.round((t.x * Zh + tp) / r)), score: e.get(t.y, t.x), region: new op(n.get(t.y, t.x, 0), n.get(t.y, t.x, 1), n.get(t.y, t.x, 2), n.get(t.y, t.x, 3))}));
      }(e, n, r, u));

      if (e.dispose(), n.dispose(), !i.length) return c.stage1.push(o), []; const a = Date.now(); const s = Vl(i.map((t) => t.cell), i.map((t) => t.score), 0.5);

      return o.nms = Date.now() - a, o.numBoxes = s.length, c.stage1.push(o), s.map((t) => i[t]);
    }).reduce((t, e) => t.concat(e), []); let n = []; let r = [];

    if (e.length > 0) {
      const o = Date.now(); const i = Vl(e.map((t) => t.cell), e.map((t) => t.score), 0.7);

      c.stage1_nms = Date.now() - o, r = i.map((t) => e[t].score), n = i.map((t) => e[t]).map((t) => {
        const e = t.cell; const n = t.region;

        return new sl(e.left + n.left * e.width, e.top + n.top * e.height, e.right + n.right * e.width, e.bottom + n.bottom * e.height).toSquare().round();
      });
    }

    return {boxes: n, scores: r};
  } function cp(h, r, t) {
    const a = t.width; const s = t.height;

    return Vc(this, void 0, void 0, function () {
      let l; let e; let i; const n = this;

      return Gc(this, (t) => {
        switch (t.label) {
          case 0: return l = _l(h), [4, Promise.all(r.map((c) => Vc(n, void 0, void 0, function () {
            let e, n, r, o, i, a, s, u;

            return Gc(this, (t) => e = c.padAtBorders(h.height, h.width), n = e.y, r = e.ey, o = e.x, i = e.ex, a = o - 1, s = n - 1, u = l.getImageData(a, s, i - a, r - s), [2, bl.isNodejs() ? Tl(u) : createImageBitmap(u)]);
          })))]; case 1: return e = t.sent(), i = [], e.forEach((t) => {
            const e = _l(Rl({width: a, height: s}));

            e.drawImage(t, 0, 0, a, s); for (var n = e.getImageData(0, 0, a, s).data, r = [], o = 0; o < n.length; o += 4)r.push(n[o + 2]), r.push(n[o + 1]), r.push(n[o]); i.push(r);
          }), [2, i.map((t) => bt(() => ip(Os(ae(t, [1, a, s, 3]), [0, 2, 1, 3]).toFloat())))];
        }
      });
    });
  } function lp(m, v, g, y, x) {
    return Vc(this, void 0, void 0, function () {
      let e, n, r, o, i, a, s, u, c, l, h, p, f, d;

      return Gc(this, (t) => {
        switch (t.label) {
          case 0: return e = Date.now(), [4, cp(m, v, {width: 24, height: 24})]; case 1: return n = t.sent(), x.stage2_extractImagePatches = Date.now() - e, e = Date.now(), r = n.map((t) => {
            let a; let s; const e = (a = t, s = y, bt(() => {
              const t = sp(a, s); const e = ap(_h(ai(t, [t.shape[0], s.fc1.weights.shape[0]]), s.fc1), s.prelu4_alpha); const n = _h(e, s.fc2_1); const r = $o(Ba(n, 1), 1); const o = Qt(ws(n, r), 1); const i = _h(e, s.fc2_2);

              return {scores: pi(o, 1)[1], regions: i};
            }));

            return t.dispose(), e;
          }), x.stage2_rnet = Date.now() - e, o = r.length > 1 ? So(r.map((t) => t.scores)) : r[0].scores, s = (a = Array).from, [4, o.data()]; case 2: return i = s.apply(a, [t.sent()]), o.dispose(), u = i.map((t, e) => ({score: t, idx: e})).filter((t) => t.score > g).map((t) => t.idx), c = u.map((t) => v[t]), l = u.map((t) => i[t]), h = [], p = [], c.length > 0 && (e = Date.now(), f = Vl(c, l, 0.7), x.stage2_nms = Date.now() - e, d = f.map((t) => new op(r[u[t]].regions.get(0, 0), r[u[t]].regions.get(0, 1), r[u[t]].regions.get(0, 2), r[u[t]].regions.get(0, 3))), p = f.map((t) => l[t]), h = f.map((t, e) => c[t].calibrate(d[e]))), r.forEach((t) => { t.regions.dispose(), t.scores.dispose(); }), [2, {boxes: h, scores: p}];
        }
      });
    });
  } function hp(v, g, y, x, b) {
    return Vc(this, void 0, void 0, function () {
      let e, n, o, r, i, a, s, u, c, l, h, p, f, d, m;

      return Gc(this, (t) => {
        switch (t.label) {
          case 0: return e = Date.now(), [4, cp(v, g, {width: 48, height: 48})]; case 1: return n = t.sent(), b.stage3_extractImagePatches = Date.now() - e, e = Date.now(), o = n.map((t) => {
            let s; let u; const e = (s = t, u = x, bt(() => {
              let t = sp(s, u);

              t = ap(t = ih(t = _a(t, [2, 2], [2, 2], 'same'), u.conv4, 'valid'), u.prelu4_alpha); const e = ap(_h(ai(t, [t.shape[0], u.fc1.weights.shape[0]]), u.fc1), u.prelu5_alpha); const n = _h(e, u.fc2_1); const r = $o(Ba(n, 1), 1); const o = Qt(ws(n, r), 1); const i = _h(e, u.fc2_2); const a = _h(e, u.fc2_3);

              return {scores: pi(o, 1)[1], regions: i, points: a};
            }));

            return t.dispose(), e;
          }), b.stage3_onet = Date.now() - e, r = o.length > 1 ? So(o.map((t) => t.scores)) : o[0].scores, s = (a = Array).from, [4, r.data()]; case 2: return i = s.apply(a, [t.sent()]), r.dispose(), u = i.map((t, e) => ({score: t, idx: e})).filter((t) => t.score > y).map((t) => t.idx), c = u.map((t) => new op(o[t].regions.get(0, 0), o[t].regions.get(0, 1), o[t].regions.get(0, 2), o[t].regions.get(0, 3))), l = u.map((t, e) => g[t].calibrate(c[e])), h = u.map((t) => i[t]), p = [], f = [], d = [], l.length > 0 && (e = Date.now(), m = Vl(l, h, 0.7, !1), b.stage3_nms = Date.now() - e, p = m.map((t) => l[t]), f = m.map((t) => h[t]), d = m.map((n, r) => Array(5).fill(0).map((t, e) => new jc(o[n].points.get(0, e) * (p[r].width + 1) + p[r].left, o[n].points.get(0, e + 5) * (p[r].height + 1) + p[r].top)))), o.forEach((t) => { t.regions.dispose(), t.scores.dispose(), t.points.dispose(); }), [2, {boxes: p, scores: f, points: d}];
        }
      });
    });
  } const pp = (function (t) {
    function e() { return t.call(this, 'Mtcnn') || this; }

    return Wc(e, t), e.prototype.forwardInput = function (E, S) {
      return void 0 === S && (S = {}), Vc(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s, u, c, l, h, p, f, d, m, v, g, y, x, b, w;

        return Gc(this, function (t) {
          switch (t.label) {
            case 0: if (!(e = this.params)) throw new Error('Mtcnn - load model before inference'); if (!(n = E.canvases[0])) throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');

              return r = {}, o = Date.now(), i = bt(() => { return t = $o(Xo(n)).toFloat(), bt(() => ci(pi(t, 3).reverse(), 3)); let t; }), a = function (t) { return i.dispose(), r.total = Date.now() - o, t; }, s = i.shape.slice(1), u = s[0], c = s[1], l = new Bh(S), h = l.minFaceSize, p = l.scaleFactor, f = l.maxNumScales, d = l.scoreThresholds, m = l.scaleSteps, v = (m || (function (t, e, n) {
                for (var r = n[0], o = n[1], i = tp / t, a = [], s = Math.min(r, o) * i, u = 0; s >= 12;)a.push(i * Math.pow(e, u)), s *= e, u += 1;

                return a;
              }(h, p, [u, c]))).filter((t) => {
                const e = rp(t, [u, c]);

                return Math.min(e.width, e.height) > tp;
              }).slice(0, f), r.scales = v, r.pyramid = v.map((t) => rp(t, [u, c])), g = Date.now(), [4, up(i, v, d[0], e.pnet, r)]; case 1: return y = t.sent(), r.total_stage1 = Date.now() - g, y.boxes.length ? (r.stage2_numInputBoxes = y.boxes.length, g = Date.now(), [4, lp(n, y.boxes, d[1], e.rnet, r)]) : [2, a({results: [], stats: r})]; case 2: return x = t.sent(), r.total_stage2 = Date.now() - g, x.boxes.length ? (r.stage3_numInputBoxes = x.boxes.length, g = Date.now(), [4, hp(n, x.boxes, d[2], e.onet, r)]) : [2, a({results: [], stats: r})]; case 3: return b = t.sent(), r.total_stage3 = Date.now() - g, w = b.boxes.map((e, t) => new Kl(new $l(b.scores[t], new pl(e.left / c, e.top / u, e.width / c, e.height / u), {height: u, width: c}), new Yl(b.points[t].map((t) => t.sub(new jc(e.left, e.top)).div(new jc(e.width, e.height))), {width: e.width, height: e.height}))), [2, a({results: w, stats: r})];
          }
        });
      });
    }, e.prototype.forward = function (n, r) {
      return void 0 === r && (r = {}), Vc(this, void 0, void 0, function () {
        let e;

        return Gc(this, function (t) { switch (t.label) { case 0: return e = this.forwardInput, [4, Wl(n)]; case 1: return [4, e.apply(this, [t.sent(), r])]; case 2: return [2, t.sent().results]; } });
      });
    }, e.prototype.forwardWithStats = function (n, r) {
      return void 0 === r && (r = {}), Vc(this, void 0, void 0, function () {
        let e;

        return Gc(this, function (t) { switch (t.label) { case 0: return e = this.forwardInput, [4, Wl(n)]; case 1: return [2, e.apply(this, [t.sent(), r])]; } });
      });
    }, e.prototype.getDefaultModelName = function () { return 'mtcnn_model'; }, e.prototype.extractParamsFromWeigthMap = function (t) { return np(t); }, e.prototype.extractParams = function (t) {
      return (function (t) {
        const e = ml(t); const n = e.extractWeights; const r = e.getRemainingWeights; const o = []; const i = ep(n, o); const a = i.extractPNetParams; const s = i.extractRNetParams; const u = i.extractONetParams; const c = a(); const l = s(); const h = u();

        if (r().length !== 0) throw new Error(`weights remaing after extract: ${r().length}`);

        return {params: {pnet: c, rnet: l, onet: h}, paramMappings: o};
      }(t));
    }, e;
  }(Hl)); const fp = [new jc(1.603231, 2.094468), new jc(6.041143, 7.080126), new jc(2.882459, 3.518061), new jc(4.266906, 5.178857), new jc(9.041765, 10.66308)]; const dp = [117.001, 114.697, 97.404]; const mp = (function (e) {
    function t() {
      const t = {
        withSeparableConvs: !0, iouThreshold: 0.4, classes: ['face'], anchors: fp, meanRgb: dp, isFirstLayerConv2d: !0, filterSizes: [3, 16, 32, 64, 128, 256, 512]
      };

      return e.call(this, t) || this;
    }

    return Wc(t, e), Object.defineProperty(t.prototype, 'anchors', {get() { return this.config.anchors; }, enumerable: !0, configurable: !0}), t.prototype.locateFaces = function (e, n) { return Vc(this, void 0, void 0, function () { return Gc(this, function (t) { switch (t.label) { case 0: return [4, this.detect(e, n)]; case 1: return [2, t.sent().map((t) => new $l(t.score, t.relativeBox, {width: t.imageWidth, height: t.imageHeight}))]; } }); }); }, t.prototype.getDefaultModelName = function () { return 'tiny_face_detector_model'; }, t.prototype.extractParamsFromWeigthMap = function (t) { return e.prototype.extractParamsFromWeigthMap.call(this, t); }, t;
  }(xh)); const vp = [new jc(0.738768, 0.874946), new jc(2.42204, 2.65704), new jc(4.30971, 7.04493), new jc(10.246, 4.59428), new jc(12.6868, 11.8741)]; const gp = [new jc(1.603231, 2.094468), new jc(6.041143, 7.080126), new jc(2.882459, 3.518061), new jc(4.266906, 5.178857), new jc(9.041765, 10.66308)]; const yp = [117.001, 114.697, 97.404]; const xp = (function (n) {
    function t(t) {
      void 0 === t && (t = !0); const e = Object.assign({}, {withSeparableConvs: t, iouThreshold: 0.4, classes: ['face']}, t ? {anchors: gp, meanRgb: yp} : {anchors: vp, withClassScores: !0});

      return n.call(this, e) || this;
    }

    return Wc(t, n), Object.defineProperty(t.prototype, 'withSeparableConvs', {get() { return this.config.withSeparableConvs; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'anchors', {get() { return this.config.anchors; }, enumerable: !0, configurable: !0}), t.prototype.locateFaces = function (e, n) { return Vc(this, void 0, void 0, function () { return Gc(this, function (t) { switch (t.label) { case 0: return [4, this.detect(e, n)]; case 1: return [2, t.sent().map((t) => new $l(t.score, t.relativeBox, {width: t.imageWidth, height: t.imageHeight}))]; } }); }); }, t.prototype.getDefaultModelName = function () { return this.withSeparableConvs ? 'tiny_yolov2_separable_conv_model' : 'tiny_yolov2_model'; }, t.prototype.extractParamsFromWeigthMap = function (t) { return n.prototype.extractParamsFromWeigthMap.call(this, t); }, t;
  }(xh)); const bp = {
    ssdMobilenetv1: new Kh(), tinyFaceDetector: new mp(), tinyYolov2: new xp(), mtcnn: new pp(), faceLandmark68Net: new Rh(), faceLandmark68TinyNet: new kh(), faceRecognitionNet: new Lh()
  }; const wp = function (t, e) { return bp.ssdMobilenetv1.locateFaces(t, e); }; const Ep = function (t) { return bp.faceLandmark68Net.detectLandmarks(t); }; const Sp = function (t) { return bp.ssdMobilenetv1.load(t); }; const _p = Sp; const Cp = wp; const Rp = Ep; const Tp = (function (r) {
    function t(t, e) {
      const n = r.call(this) || this;

      return n.detectFaceLandmarksTask = t, n.input = e, n;
    }

    return Wc(t, r), t;
  }(Jh)); const kp = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e.prototype.run = function () {
      return Vc(this, void 0, void 0, function () {
        let e; let n; let i; let r; let o; const a = this;

        return Gc(this, function (t) {
          switch (t.label) {
            case 0: return [4, this.detectFaceLandmarksTask]; case 1: return e = t.sent(), n = e.map((t) => t.alignedRect), this.input instanceof Y ? [4, rh(this.input, n)] : [3, 3]; case 2: return r = t.sent(), [3, 5]; case 3: return [4, nh(this.input, n)]; case 4: r = t.sent(), t.label = 5; case 5: return i = r, [4, Promise.all(e.map((t, n) => {
              const r = t.detection; const o = t.landmarks;

              return Vc(a, void 0, void 0, function () {
                let e;

                return Gc(this, (t) => { switch (t.label) { case 0: return [4, bp.faceRecognitionNet.computeFaceDescriptor(i[n])]; case 1: return e = t.sent(), [2, new Zl(r, o, e)]; } });
              });
            }))]; case 6: return o = t.sent(), i.forEach((t) => t instanceof Y && t.dispose()), [2, o];
          }
        });
      });
    }, e;
  }(Tp)); const Ip = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e.prototype.run = function () {
      return Vc(this, void 0, void 0, function () {
        let e, n, r, o, i, a, s;

        return Gc(this, function (t) { switch (t.label) { case 0: return [4, this.detectFaceLandmarksTask]; case 1: return (e = t.sent()) ? (n = e.detection, r = e.landmarks, o = e.alignedRect, this.input instanceof Y ? [4, rh(this.input, [o])] : [3, 3]) : [2]; case 2: return a = t.sent(), [3, 5]; case 3: return [4, nh(this.input, [o])]; case 4: a = t.sent(), t.label = 5; case 5: return i = a, [4, bp.faceRecognitionNet.computeFaceDescriptor(i[0])]; case 6: return s = t.sent(), i.forEach((t) => t instanceof Y && t.dispose()), [2, new Zl(n, r, s)]; } });
      });
    }, e;
  }(Tp)); const Dp = (function (o) {
    function t(t, e, n) {
      const r = o.call(this) || this;

      return r.detectFacesTask = t, r.input = e, r.useTinyLandmarkNet = n, r;
    }

    return Wc(t, o), Object.defineProperty(t.prototype, 'landmarkNet', {get() { return this.useTinyLandmarkNet ? bp.faceLandmark68TinyNet : bp.faceLandmark68Net; }, enumerable: !0, configurable: !0}), t;
  }(Jh)); const Np = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e.prototype.run = function () {
      return Vc(this, void 0, void 0, function () {
        let e; let n; let r; let o; const i = this;

        return Gc(this, function (t) { switch (t.label) { case 0: return [4, this.detectFacesTask]; case 1: return e = t.sent(), this.input instanceof Y ? [4, rh(this.input, e)] : [3, 3]; case 2: return r = t.sent(), [3, 5]; case 3: return [4, nh(this.input, e)]; case 4: r = t.sent(), t.label = 5; case 5: return n = r, [4, Promise.all(n.map((t) => i.landmarkNet.detectLandmarks(t)))]; case 6: return o = t.sent(), n.forEach((t) => t instanceof Y && t.dispose()), [2, e.map((t, e) => new Kl(t, o[e]))]; } });
      });
    }, e.prototype.withFaceDescriptors = function () { return new kp(this, this.input); }, e;
  }(Dp)); const Ap = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e.prototype.run = function () {
      return Vc(this, void 0, void 0, function () {
        let e, n, r, o;

        return Gc(this, function (t) { switch (t.label) { case 0: return [4, this.detectFacesTask]; case 1: return (e = t.sent()) ? this.input instanceof Y ? [4, rh(this.input, [e])] : [3, 3] : [2]; case 2: return r = t.sent(), [3, 5]; case 3: return [4, nh(this.input, [e])]; case 4: r = t.sent(), t.label = 5; case 5: return n = r, [4, this.landmarkNet.detectLandmarks(n[0])]; case 6: return o = t.sent(), n.forEach((t) => t instanceof Y && t.dispose()), [2, new Kl(e, o)]; } });
      });
    }, e.prototype.withFaceDescriptor = function () { return new Ip(this, this.input); }, e;
  }(Dp)); const Mp = (function (r) {
    function t(t, e) {
      void 0 === e && (e = new $h()); const n = r.call(this) || this;

      return n.input = t, n.options = e, n;
    }

    return Wc(t, r), t;
  }(Jh)); const Op = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e.prototype.run = function () {
      return Vc(this, void 0, void 0, function () {
        let e, n, r, o;

        return Gc(this, function (t) {
          switch (t.label) {
            case 0: return n = (e = this).input, (r = e.options) instanceof Bh ? [4, bp.mtcnn.forward(n, r)] : [3, 2]; case 1: return [2, t.sent().map((t) => t.faceDetection)]; case 2: if (!(o = r instanceof Qh ? function (t) { return bp.tinyFaceDetector.locateFaces(t, r); } : r instanceof $h ? function (t) { return bp.ssdMobilenetv1.locateFaces(t, r); } : r instanceof yh ? function (t) { return bp.tinyYolov2.locateFaces(t, r); } : null)) throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options');

              return [2, o(n)];
          }
        });
      });
    }, e.prototype.withFaceLandmarks = function (t) { return void 0 === t && (t = !1), new Np(this, this.input, t); }, e;
  }(Mp)); const Pp = (function (t) {
    function e() { return t !== null && t.apply(this, arguments) || this; }

    return Wc(e, t), e.prototype.run = function () {
      return Vc(this, void 0, void 0, function () {
        let e, n;

        return Gc(this, function (t) { switch (t.label) { case 0: return [4, new Op(this.input, this.options)]; case 1: return e = t.sent(), n = e[0], e.forEach((t) => { t.score > n.score && (n = t); }), [2, n]; } });
      });
    }, e.prototype.withFaceLandmarks = function (t) { return void 0 === t && (t = !1), new Ap(this, this.input, t); }, e;
  }(Mp));

  function Fp(t, e) { return void 0 === e && (e = new $h()), new Op(t, e); } function Lp(e, n) { return Vc(this, void 0, void 0, function () { return Gc(this, (t) => { switch (t.label) { case 0: return [4, Fp(e, new $h(n ? {minConfidence: n} : {})).withFaceLandmarks().withFaceDescriptors()]; case 1: return [2, t.sent()]; } }); }); } const Bp = Lp;

  function zp(t, e) {
    if (t.length !== e.length) throw new Error('euclideanDistance: arr1.length !== arr2.length'); const n = Array.from(t); const r = Array.from(e);

    return Math.sqrt(n.map((t, e) => t - r[e]).reduce((t, e) => t + Math.pow(e, 2), 0));
  } const Wp = (function () {
    function t(t, e) {
      void 0 === e && (e = 0.6), this._distanceThreshold = e; const n = Array.isArray(t) ? t : [t];

      if (!n.length) throw new Error('FaceRecognizer.constructor - expected atleast one input'); let r = 1; const o = function () { return `person ${r++}`; };

      this._labeledDescriptors = n.map((t) => { if (t instanceof th) return t; if (t instanceof Zl) return new th(o(), [t.descriptor]); if (t instanceof Float32Array) return new th(o(), [t]); throw new Error('FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | FullFaceDescription | Float32Array | Array<LabeledFaceDescriptors | FullFaceDescription | Float32Array>'); });
    }

    return Object.defineProperty(t.prototype, 'labeledDescriptors', {get() { return this._labeledDescriptors; }, enumerable: !0, configurable: !0}), Object.defineProperty(t.prototype, 'distanceThreshold', {get() { return this._distanceThreshold; }, enumerable: !0, configurable: !0}), t.prototype.computeMeanDistance = function (e, t) { return t.map((t) => zp(t, e)).reduce((t, e) => t + e, 0) / (t.length || 1); }, t.prototype.matchDescriptor = function (r) {
      const o = this;

      return this.labeledDescriptors.map((t) => {
        const e = t.descriptors; const n = t.label;

        return new Jl(n, o.computeMeanDistance(r, e));
      }).reduce((t, e) => (t.distance < e.distance ? t : e));
    }, t.prototype.findBestMatch = function (t) {
      const e = this.matchDescriptor(t);

      return e.distance < this.distanceThreshold ? e : new Jl('unknown', e.distance);
    }, t;
  }());

  t.tf = Bc, t.BoundingBox = sl, t.Box = al, t.BoxWithText = ul, t.Dimensions = qc, t.LabeledBox = cl, t.ObjectDetection = ll, t.Point = jc, t.PredictedBox = hl, t.Rect = pl, t.disposeUnusedWeightTensors = fl, t.extractWeightEntryFactory = dl, t.extractWeightsFactory = ml, t.getModelUris = vl, t.awaitMediaLoaded = El, t.bufferToImage = Sl, t.createCanvas = Rl, t.createCanvasFromMedia = Tl, t.drawBox = Il, t.drawDetection = function (t, e, l) {
    const n = bl.getEnv().Canvas; const h = Nl(t);

    if (!(h instanceof n)) throw new Error('drawDetection - expected canvas to be of type: HTMLCanvasElement'); (Array.isArray(e) ? e : [e]).forEach((t) => {
      const e = t instanceof ll ? t.box : t; const n = e.x; const r = e.y; const o = e.width; const i = e.height; const a = kl(l); const s = _l(h);

      Il(s, n, r, o, i, a); const u = a.withScore; const c = t instanceof ul ? t.text : u && t instanceof hl ? `${Jc(t.score)}` : t instanceof ll ? t.className + (u ? ` (${Jc(t.score)})` : '') : '';

      c && Dl(s, n, r + i, c, a);
    });
  }, t.drawText = Dl, t.fetchImage = function (r) {
    return Vc(this, void 0, void 0, function () {
      let e, n;

      return Gc(this, (t) => {
        switch (t.label) {
          case 0: return [4, Al(r)]; case 1: return [4, (e = t.sent()).blob()]; case 2: if (!(n = t.sent()).type.startsWith('image/')) throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${e.url}`);

            return [2, Sl(n)];
        }
      });
    });
  }, t.fetchJson = Ml, t.fetchNetWeights = function (n) {
    return Vc(this, void 0, void 0, function () {
      let e;

      return Gc(this, (t) => { switch (t.label) { case 0: return e = Float32Array.bind, [4, Al(n)]; case 1: return [4, t.sent().arrayBuffer()]; case 2: return [2, new (e.apply(Float32Array, [void 0, t.sent()]))()]; } });
    });
  }, t.fetchOrThrow = Al, t.getContext2dOrThrow = _l, t.getDefaultDrawOptions = kl, t.getMediaDimensions = Cl, t.imageTensorToCanvas = Ol, t.imageToSquare = Pl, t.isMediaElement = Fl, t.isMediaLoaded = wl, t.loadWeightMap = Ll, t.NetInput = zl, t.resolveInput = Nl, t.toNetInput = Wl, t.env = bl, t.sigmoid = ql, t.inverseSigmoid = function (t) { return Math.log(t / (1 - t)); }, t.iou = Ul, t.nonMaxSuppression = Vl, t.normalize = Gl, t.padToSquare = Bl, t.shuffleArray = function (t) {
    for (var e = t.slice(), n = e.length - 1; n > 0; n--) {
      const r = Math.floor(Math.random() * (n + 1)); const o = e[n];

      e[n] = e[r], e[r] = o;
    }

    return e;
  }, t.isTensor = Hc, t.isTensor1D = function (t) { return Hc(t, 1); }, t.isTensor2D = $c, t.isTensor3D = Kc, t.isTensor4D = Xc, t.isFloat = Yc, t.isEven = Qc, t.round = Jc, t.isDimensions = Zc, t.computeReshapedDimensions = tl, t.getCenterPoint = el, t.range = nl, t.isValidNumber = rl, t.isValidProbablitiy = ol, t.NeuralNetwork = Hl, t.FaceDetection = $l, t.FaceDetectionWithLandmarks = Kl, t.FaceLandmarks = Xl, t.FaceLandmarks5 = Yl, t.FaceLandmarks68 = Ql, t.FaceMatch = Jl, t.FullFaceDescription = Zl, t.LabeledFaceDescriptors = th, t.drawContour = eh, t.drawLandmarks = function (t, e, n) {
    const r = Nl(t);

    if (!(r instanceof bl.getEnv().Canvas)) throw new Error('drawLandmarks - expected canvas to be of type: HTMLCanvasElement'); const o = Object.assign(kl(n), n || {}); const i = Object.assign({drawLines: !1}, n || {}).drawLines; const a = _l(r); const s = o.lineWidth; const u = o.color; const c = void 0 === u ? 'blue' : u;

    (Array.isArray(e) ? e : [e]).forEach((t) => {
      if (i && t instanceof Ql) return a.strokeStyle = c, a.lineWidth = s, eh(a, t.getJawOutline()), eh(a, t.getLeftEyeBrow()), eh(a, t.getRightEyeBrow()), eh(a, t.getNose()), eh(a, t.getLeftEye(), !0), eh(a, t.getRightEye(), !0), void eh(a, t.getMouth(), !0); const e = s / 2;

      a.fillStyle = c, t.positions.forEach((t) => a.fillRect(t.x - e, t.y - e, s, s));
    });
  }, t.extractFaces = nh, t.extractFaceTensors = rh, t.FaceLandmarkNet = Ih, t.createFaceLandmarkNet = function (t) {
    const e = new Ih();

    return e.extractWeights(t), e;
  }, t.FaceLandmark68Net = Rh, t.FaceLandmark68TinyNet = kh, t.createFaceRecognitionNet = function (t) {
    const e = new Lh();

    return e.extractWeights(t), e;
  }, t.FaceRecognitionNet = Lh, t.allFacesSsdMobilenetv1 = Lp, t.allFacesTinyYolov2 = function (e, n) { return void 0 === n && (n = {}), Vc(this, void 0, void 0, function () { return Gc(this, (t) => { switch (t.label) { case 0: return [4, Fp(e, new yh(n)).withFaceLandmarks().withFaceDescriptors()]; case 1: return [2, t.sent()]; } }); }); }, t.allFacesMtcnn = function (e, n) { return void 0 === n && (n = {}), Vc(this, void 0, void 0, function () { return Gc(this, (t) => { switch (t.label) { case 0: return [4, Fp(e, new Bh(n)).withFaceLandmarks().withFaceDescriptors()]; case 1: return [2, t.sent()]; } }); }); }, t.allFaces = Bp, t.ComposableTask = Jh, t.ComputeFaceDescriptorsTaskBase = Tp, t.ComputeAllFaceDescriptorsTask = kp, t.ComputeSingleFaceDescriptorTask = Ip, t.detectSingleFace = function (t, e) { return void 0 === e && (e = new $h()), new Pp(t, e); }, t.detectAllFaces = Fp, t.DetectFacesTaskBase = Mp, t.DetectAllFacesTask = Op, t.DetectSingleFaceTask = Pp, t.DetectFaceLandmarksTaskBase = Dp, t.DetectAllFaceLandmarksTask = Np, t.DetectSingleFaceLandmarksTask = Ap, t.FaceMatcher = Wp, t.nets = bp, t.ssdMobilenetv1 = wp, t.tinyFaceDetector = function (t, e) { return bp.tinyFaceDetector.locateFaces(t, e); }, t.tinyYolov2 = function (t, e) { return bp.tinyYolov2.locateFaces(t, e); }, t.mtcnn = function (t, e) { return bp.mtcnn.forward(t, e); }, t.detectFaceLandmarks = Ep, t.detectFaceLandmarksTiny = function (t) { return bp.faceLandmark68TinyNet.detectLandmarks(t); }, t.computeFaceDescriptor = function (t) { return bp.faceRecognitionNet.computeFaceDescriptor(t); }, t.loadSsdMobilenetv1Model = Sp, t.loadTinyFaceDetectorModel = function (t) { return bp.tinyFaceDetector.load(t); }, t.loadMtcnnModel = function (t) { return bp.mtcnn.load(t); }, t.loadTinyYolov2Model = function (t) { return bp.tinyYolov2.load(t); }, t.loadFaceLandmarkModel = function (t) { return bp.faceLandmark68Net.load(t); }, t.loadFaceLandmarkTinyModel = function (t) { return bp.faceLandmark68TinyNet.load(t); }, t.loadFaceRecognitionModel = function (t) { return bp.faceRecognitionNet.load(t); }, t.loadFaceDetectionModel = _p, t.locateFaces = Cp, t.detectLandmarks = Rp, t.createMtcnn = function (t) {
    const e = new pp();

    return e.extractWeights(t), e;
  }, t.Mtcnn = pp, t.MtcnnOptions = Bh, t.createSsdMobilenetv1 = Xh, t.createFaceDetectionNet = function (t) { return Xh(t); }, t.FaceDetectionNet = Yh, t.SsdMobilenetv1 = Kh, t.SsdMobilenetv1Options = $h, t.createTinyFaceDetector = function (t) {
    const e = new mp();

    return e.extractWeights(t), e;
  }, t.TinyFaceDetector = mp, t.TinyFaceDetectorOptions = Qh, t.createTinyYolov2 = function (t, e) {
    void 0 === e && (e = !0); const n = new xp(e);

    return n.extractWeights(t), n;
  }, t.TinyYolov2 = xp, t.euclideanDistance = zp, Object.defineProperty(t, '__esModule', {value: !0});
}));
