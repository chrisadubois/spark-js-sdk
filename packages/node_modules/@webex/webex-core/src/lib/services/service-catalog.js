import AmpState from 'ampersand-state';

import ServiceUrl from './service-url';

/* eslint-disable no-underscore-dangle */
/**
 * @class
 */
const ServiceCatalog = AmpState.extend({
  namespace: 'ServiceCatalog',

  props: {
    serviceGroups: ['object', true, (() => ({
      discovery: [
        new ServiceUrl({
          name: 'u2c',
          defaultUrl: process.env.U2C_SERVICE_URL ||
            'https://u2c.wbx2.com/u2c/api/v1',
          hosts: []
        })
      ],
      preauth: [],
      postauth: [],
      signin: []
    }))],
    status: ['object', true, (() => ({
      preauth: {
        ready: false,
        collecting: false
      },
      postauth: {
        ready: false,
        collecting: false
      },
      signin: {
        ready: false,
        collecting: false
      }
    }))]
  },

  /**
   * @private
   * Search the service url array to locate a `ServiceUrl`
   * class object based on its name.
   * @param {string} name
   * @param {string} [serviceGroup]
   * @returns {ServiceUrl}
   */
  _getUrl(name, serviceGroup) {
    const serviceUrls = (typeof serviceGroup === 'string') ?
      this.serviceGroups[serviceGroup] || [] :
      [
        ...this.serviceGroups.discovery,
        ...this.serviceGroups.preauth,
        ...this.serviceGroups.signin,
        ...this.serviceGroups.postauth
      ];

    return serviceUrls.find((serviceUrl) => serviceUrl.name === name);
  },

  /**
   * @private
   * Safely load one or more `ServiceUrl`s into this `Services` instance.
   * @param {string} serviceGroup
   * @param  {Array<ServiceUrl>} services
   * @returns {Services}
   */
  _loadServiceUrls(serviceGroup, services) {
    // declare namespaces outside of loop
    let existingService;

    services.forEach((service) => {
      existingService = this._getUrl(service.name, serviceGroup);

      if (!existingService) {
        this.serviceGroups[serviceGroup].push(service);
      }
    });

    return this;
  },

  /**
   * @private
   * Safely unload one or more `ServiceUrl`s into this `Services` instance
   * @param {string} serviceGroup
   * @param  {Array<ServiceUrl>} services
   * @returns {Services}
   */
  _unloadServiceUrls(serviceGroup, services) {
    // declare namespaces outside of loop
    let existingService;

    services.forEach((service) => {
      existingService = this._getUrl(service.name, serviceGroup);

      if (existingService) {
        this.serviceGroups[serviceGroup].splice(
          this.serviceGroups[serviceGroup].indexOf(existingService), 1
        );
      }
    });

    return this;
  },

  /**
   * Get a service url from the current services list by name.
   * @param {string} name
   * @param {boolean} priorityHost
   * @param {string} serviceGroup
   * @returns {string}
   */
  get(name, priorityHost, serviceGroup) {
    const serviceUrl = this._getUrl(name, serviceGroup);

    return (serviceUrl) ? serviceUrl.get(priorityHost) : undefined;
  },

  /**
   * Creates an object where the keys are the service names
   * and the values are the service urls.
   * @param {boolean} priorityHost - use the highest priority if set to `true`
   * @param {string} [serviceGroup]
   * @returns {Record<string, string>}
   */
  list(priorityHost, serviceGroup) {
    const output = {};

    const serviceUrls = (typeof serviceGroup === 'string') ?
      this.serviceGroups[serviceGroup] || [] :
      [
        ...this.serviceGroups.discovery,
        ...this.serviceGroups.preauth,
        ...this.serviceGroups.signin,
        ...this.serviceGroups.postauth
      ];

    if (serviceUrls) {
      serviceUrls.forEach((serviceUrl) => {
        output[serviceUrl.name] = serviceUrl.get(priorityHost);
      });
    }

    return output;
  },

  /**
   * Mark a priority host service url as failed.
   * This will mark the host associated with the
   * `ServiceUrl` to be removed from the its
   * respective host array, and then return the next
   * viable host from the `ServiceUrls` host array,
   * or the `ServiceUrls` default url if no other priority
   * hosts are available, or if `noPriorityHosts` is set to
   * `true`.
   * @param {string} url
   * @param {boolean} noPriorityHosts
   * @returns {string}
   */
  markFailedUrl(url, noPriorityHosts) {
    const serviceUrl = this._getUrl(Object.keys(this.list()).find(
      (key) => this._getUrl(key).removeHost(url)
    ));

    if (!serviceUrl) {
      return undefined;
    }

    return (noPriorityHosts) ? serviceUrl.get(false) : serviceUrl.get(true);
  },

  /**
   * Update the current list of `ServiceUrl`s against a provided
   * service hostmap.
   * @emits ServiceCatalog#preauthorized
   * @emits ServiceCatalog#postauthorized
   * @param {string} serviceGroup
   * @param {object} serviceHostmap
   * @returns {Services}
   */
  updateServiceUrls(serviceGroup, serviceHostmap) {
    const currentServiceUrls = this.serviceGroups[serviceGroup];

    const unusedUrls = currentServiceUrls.filter(
      (serviceUrl) => serviceHostmap.every(
        (item) => item.name !== serviceUrl.name
      )
    );

    this._unloadServiceUrls(serviceGroup, unusedUrls);

    serviceHostmap.forEach((serviceObj) => {
      const service = this._getUrl(serviceObj.name, serviceGroup);

      if (service) {
        service.defaultUrl = serviceObj.defaultUrl;
        service.hosts = serviceObj.hosts;
      }
      else {
        this._loadServiceUrls(serviceGroup, [new ServiceUrl({
          ...serviceObj
        })]);
      }
    });

    this.status[serviceGroup].ready = true;
    this.trigger(serviceGroup);

    return this;
  },

  /**
   * Wait until the service catalog is available,
   * or reject after a timeout of 60 seconds.
   * @param {string} serviceGroup
   * @param {number} [timeout] - in seconds
   * @returns {Promise<void>}
   */
  waitForCatalog(serviceGroup, timeout) {
    return new Promise((resolve, reject) => {
      if (this.status[serviceGroup].ready) {
        resolve();
      }

      this.once(serviceGroup, () => resolve());

      setTimeout(() => reject(), (timeout) ? timeout * 1000 : 60000);
    });
  }
});
/* eslint-enable no-underscore-dangle */

export default ServiceCatalog;
