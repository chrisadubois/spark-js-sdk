/* eslint require-jsdoc:0 */
/* globals window */
import {SparkPlugin} from '@ciscospark/spark-core';
import Promise from 'bluebird';
import StateMachine from 'javascript-state-machine';

import {ROAP, ERROR, CONFLICT, IDLE, OFFER, REQUESTED, ANSWER} from '../constants';
import PeerConnectionManager from '../peer-connection-manager';

const config = window;

const State = StateMachine.factory({
  init: ROAP.ROAP_STATE.INIT,
  transitions: [
    {
      name: ROAP.ROAP_TRANSITIONS.TRANSITION,
      from: '*',
      to: (signal, meeting, prevState) => {
        let value;
        switch (prevState) {
          case ROAP.ROAP_STATE.INIT:
            if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {
              value = ROAP.ROAP_STATE.WAIT_TX_ANSWER;
            }
            else if (signal === ROAP.ROAP_SIGNAL.TX_OFFER) {
              value = ROAP.ROAP_STATE.WAIT_RX_ANSWER;
            }
            break;
          case ROAP.ROAP_STATE.WAIT_RX_OFFER:
            break;
          case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
            if (signal === ROAP.ROAP_SIGNAL.RX_ANSWER) {
              // There is a race condition where the /call response comes after mercury event from the server
              // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that
              if (meeting.mediaId) {
                value = ROAP.ROAP_STATE.WAIT_TX_OK;
              }
            }
            else if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {
              value = ROAP.ROAP_STATE.GLARE;
            }
            break;
          case ROAP.ROAP_STATE.WAIT_TX_OFFER:
            break;
          case ROAP.ROAP_STATE.WAIT_TX_ANSWER:
            if (signal === ROAP.ROAP_SIGNAL.TX_ANSWER) {
              value = ROAP.ROAP_STATE.WAIT_RX_OK;
            }
            break;
          case ROAP.ROAP_STATE.WAIT_TX_OK:
            if (signal === ROAP.ROAP_SIGNAL.TX_OK) {
              value = ROAP.ROAP_STATE.INIT;
            }
            break;
          case ROAP.ROAP_STATE.WAIT_RX_OK:
            if (signal === ROAP.ROAP_SIGNAL.RX_OK) {
              value = ROAP.ROAP_STATE.INIT;
            }
            break;
          case ROAP.ROAP_STATE.ERROR:
            // TODO: resolve error state. Add a signal constant and handle the cleanup
            value = ROAP.ROAP_STATE.INIT;
            break;
          case ROAP.ROAP_STATE.GLARE:
            value = ROAP.ROAP_STATE.WAIT_RX_ANSWER;
            break;
          default:
            break;
        }
        return value || prevState;
      }
    }
  ],
  methods: {
    onAfterTransition: (transition) => {
      console.log(
        `roap:state#onAfterTransition->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}''.`
      );
    }
  }
});

const RoapState = SparkPlugin.extend({
  initialize() {
    this.sessions = {};
  },

  createSession(id) {
    if (!this.sessions[id]) {
      this.sessions[id] = {};
      this.sessions[id].state = new State();
    }
    return this.sessions[id];
  },

  getSession(id) {
    return this.sessions[id];
  },

  deleteSession(id) {
    if (this.getSession(id)) {
      delete this.sessions[id];
    }
  },

  createSessionSequence(id, seqId) {
    const add = this.createSession(id);
    if (!add[seqId]) {
      add[seqId] = {};
    }
    return add[seqId];
  },

  getSessionSequence(id, seqId) {
    const session = this.getSession(id);
    if (session) {
      return session[seqId];
    }
    return session;
  },

  deleteSessionSequence(id, seqId) {
    if (this.getSessionSequence(id, seqId)) {
      delete this.sessions[id][seqId];
    }
  },

  start() {
    return Promise.try(() => {
      this.spark.internal.mercury.on(ROAP.ROAP_MERCURY, (result) => {
        const msg = result.data.message;
        const {correlationId} = result.data;
        // config.console.info(`Call-Mercury->-App: receives Roap Message [${JSON.stringify(msg, null, 2)}]`);
        this.submit({
          type: ROAP.RECEIVE_ROAP_MSG,
          msg,
          correlationId
        });
      });
    });
  },

  // returns true if a state update is to be triggered
  save(roap) {
    const {correlationId} = roap;
    const {seq: sequenceId, messageType, errorType} = roap.msg;

    config.console.info('Call-RoapHandler: CorrelationID, ', correlationId);

    const meeting = this.spark.meetings.meetingCollection.get(correlationId);

    if (messageType === ERROR && errorType === CONFLICT) {
      // reset the peer-connection and send the request

      PeerConnectionManager.rollBackLocalDescription({mediaPeerConnection: meeting.mediaPeerConnection})
        .then(() => {
          config.console.info('Delete the sequence data ', sequenceId);

          if (meeting) {
            config.console.info('emitting the callStore changes');
            meeting.shareStatus = IDLE;
          }
          delete this.sessions[correlationId][sequenceId];
        })
        .catch((err) => {
          config.console.info('Cannot reset the peer connection', err);
        });

      return false;
    }

    this.sessions[correlationId] = this.sessions[correlationId] || {};
    this.sessions[correlationId][sequenceId] = this.sessions[correlationId][sequenceId] || {};

    if (this.sessions[correlationId][sequenceId].OFFER && messageType === OFFER) {
      this.sessions[correlationId][sequenceId].GLARE_OFFER = roap.msg;
      this.sessions[correlationId][sequenceId].GLARE_OFFER.remote = !!roap.remote;
      config.console.info(`Its a GLARE condition seq:${sequenceId} new mercury event`);
    }
    else {
      // config.console.info(
      //   `Save OFFER/ANSWER seq:${sequenceId} new mercury event ${messageType}local state: ${JSON.stringify(
      //     this.sessions[correlationId][sequenceId].state,
      //     null,
      //     2
      //   )}`
      // );
      this.sessions[correlationId][sequenceId][messageType] = roap.msg;
      this.sessions[correlationId][sequenceId][messageType].remote = !!roap.remote;
    }

    if (meeting) {
      if (messageType === OFFER && roap.remote && meeting.shareStatus === REQUESTED) {
        // The peer-connection is waiting for answer but got an offer Reset. Try to
        // send the offer later after you accept the answer
        config.console.info(
          `Call-RoapHandler:The peer-connection has changed before sending the request:${sequenceId}`
        );
        // Roapint.sendRoapError(RoapHandler.sessions[correlationId][sequenceId], MeetingCollection.calls[correlationId], 'CONFLICT');
        return false;
      }
    }

    // initialize state
    if (!this.sessions[correlationId][sequenceId].state) {
      this.sessions[correlationId][sequenceId].state = new State();
    }

    // Assuming the mercury event has come first before the response for the event
    // we have to wait for the response and trigger the ROAP request later on
    if (meeting && (!meeting.mediaPeerConnection && !meeting.screenPeerConnection) && messageType === ANSWER) {
      config.console.info(
        `Call-RoapHandler: Got RemoteSdp Mercury event before \`/participants\` response correlationId: ${correlationId}`
      );
      return false;
    }

    config.console.info('Call-RoapHandler: success save proceeding with transition, ', roap.msg);

    return true;
  },

  performState(session, meeting) {
    config.console.info('CALL-RoapHandler: PerfomState ', session.state.state);

    const setRemoteDescription = () => {
      config.console.info('Call-RoapHandler: Transmite WAIT_TX_OK', meeting.correlationId);

      // if (meeting && meeting.shareStatus === 'REQUESTED') {
      //   MeetingClientActionCreators.sendFloorGrant(meeting);
      // }

      if (!(meeting && (meeting.mediaPeerConnection || meeting.screenPeerConnection))) {
        config.console.error('Call-RoapHandler: DANGER no media or screen peer connection', meeting.correlationId);
        return;
      }

      let promise;

      if (meeting.mediaPeerConnection && meeting.screenPeerConnection) {
        promise = Promise.all([
          PeerConnectionManager.setRemoteSessionDetails(
            meeting.mediaPeerConnection,
            'answer',
            session.ANSWER.sdps[0],
            meeting.clientIdentifiers
          ),
          PeerConnectionManager.setRemoteSessionDetails(
            meeting.screenPeerConnection,
            'answer',
            session.ANSWER.sdps[1],
            meeting.clientIdentifiers
          )
        ]);
      }
      else if (meeting.screenPeerConnection) {
        promise = PeerConnectionManager.setRemoteSessionDetails(
          meeting.screenPeerConnection,
          'answer',
          session.ANSWER.sdps[0],
          meeting.clientIdentifiers
        );
      }

      promise
        .then(() => {
          config.console.info('Call-RoapHandler: setRemote Description successfull', meeting.correlationId);

          return this.spark.meetings.roap.sendRoapOK({
            seq: session.ANSWER.seq,
            locusId: meeting.locusId,
            locusSelfId: meeting.locus.self.id,
            mediaId: meeting.mediaId,
            correlationId: meeting.correlationId
          });
        })
        .catch((err) => {
          config.console.error('Call-RoapHandler: Error setting remote and sending Roap Message', err);
        });
    };

    const mediaOffer = meeting.mediaPeerConnection && meeting.mediaPeerConnection.signalingState === 'have-local-offer';
    const screenOffer
      = meeting.screenPeerConnection && meeting.screenPeerConnection.signalingState === 'have-local-offer';

    switch (session.state.state) {
      // case ROAP.ROAP_STATE.INIT:
      // case ROAP.ROAP_STATE.WAIT_RX_OFFER:
      // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
      // case ROAP.ROAP_STATE.WAIT_RX_OK:

      // TODO: default audio and video , change later
      case ROAP.ROAP_STATE.WAIT_TX_ANSWER:
        // TODO: sometime the you get an answer while you are creating an offer so SKIP
        // Server will send the mercury event comes back

        if (mediaOffer || screenOffer) {
          return;
        }

        PeerConnectionManager.updatePeerConnection({
          offerSdp: session.OFFER.sdps,
          pc: meeting.mediaPeerConnection,
          screenPeerConnection: meeting.screenPeerConnection,
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        }).then((answerSdps) => {
          this.spark.meetings.roap.sendRoapAnswer({
            locusId: meeting.locusId,
            locusSelfId: meeting.locus.self.id,
            mediaId: meeting.mediaId,
            sdps: answerSdps,
            roapSeq: session.OFFER.seq,
            correlationId: meeting.correlationId
          });
        });
        break;
      case ROAP.ROAP_STATE.WAIT_TX_OK:
        setRemoteDescription();
        break;
      // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:
      case ROAP.ROAP_STATE.ERROR:
        config.console.error('Call-RoapHandler#ERROR state=error', session);
        break;
      case session.state.state === ROAP.ROAP_STATE.GLARE:
        session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
        session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;
        config.console.error('Resolve the GLARE condition');
        if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
          // 2
          config.console.error('local offer wins');
        }
        else {
          config.console.error('remote offer wins', session);
        }
        session.state.transition(ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting, session.state.state);
        this.performState(session, meeting);
        break;
      default:
        break;
    }
  },

  submit(action) {
    let session;
    const {correlationId} = action;
    const meeting = this.spark.meetings.meetingCollection.get(correlationId);
    let signal;
    let logging = true;

    switch (action.type) {
      case ROAP.RECEIVE_ROAP_MSG:
        // TODO: handle incomplete sequences

        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-RoapHandler#RECEIVE_ROAP_MSG: should always have meeting object on roap event');
          break;
        }
        action.remote = true;
        if (this.save(action)) {
          session = this.sessions[correlationId][action.msg.seq];
          signal = ROAP.ROAP_SIGNAL[`RX_${action.msg.messageType}`];
          session.state.transition(signal, meeting, session.state.state);
          this.performState(session, meeting);
        }
        break;

      case ROAP.SEND_ROAP_MSG:
        // TODO: handle incomplete sequences
        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-RoapHandler#SEND_ROAP_MSG: should always have meeting object on roap event');
          break;
        }
        action.local = true;
        if (this.save(action)) {
          session = this.sessions[correlationId][action.msg.seq];
          signal = ROAP.ROAP_SIGNAL[`TX_${action.msg.messageType}`];
          session.state.transition(signal, meeting, session.state.state);
          this.performState(session, meeting);
        }
        break;

      case ROAP.SEND_ROAP_MSG_SUCCESS:
        session = this.sessions[correlationId][action.seq];

        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-this#SEND_ROAP_MSG_SUCCESS: should always have meeting object on roap event');
          break;
        }
        // This means we got and answer and waiting for 200 ok for /participants
        if (this.sessions && this.sessions[correlationId][action.seq].ANSWER) {
          signal = ROAP.ROAP_SIGNAL.RX_ANSWER;
          // NOTE: When server send back an answer via mercury the
          // remote SDP is already saved sent and ok message is sent back
          // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
          // RoapHandler.transition(signal, session, meeting);
        }
        break;

      case 'RECEIVE_CALL_LEAVE':
        delete this.sessions[correlationId];
        config.console.info('Call-this#RECEIVE_CALL_LEAVE: cleaning up the RoapHandler', correlationId);
        break;
      case ROAP.RESET_ROAP_STATE:
        delete this.sessions[correlationId][action.msg.seq];
        config.console.info('Call-RoapHandler#RESET_ROAP_STATE: resetting the RoapHandler state', action.msg.seq);
        break;
      default:
        logging = false;
        return true;
    }

    if (logging) {
      config.console.log('Call-RoapHandler: Event %s ,  %s , %s', action.type, correlationId, action.msg);
    }
    return true;
  }
});

export default RoapState;
