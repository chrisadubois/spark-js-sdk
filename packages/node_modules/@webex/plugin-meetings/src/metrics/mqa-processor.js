
/**
 * @description MQAProcessor handles interval data for MQA
 * @export
 * @class MQAProcessor
 */
class MQAProcessor {
  /**
     * @constructor
     * @public
     * @memberof Meetings
     */
  constructor() {
    this.data = {};
    this.intervalNumber = 0;
  }

  process(id, interval) {
    let rtpJitter, rtpPackets, rtpEndToEndLost, transmittedFrameRate; // eslint-disable-line
    const vsTransmit = {};
    const videoTransmit = [vsTransmit];

    switch (id) {
      // case 'audioReceiver':
      //   // TODO: calculate them and then go beyond just chrome
      //   rtpJitter = interval[0].rtpInAudio.jitter;
      //   rtpPackets = interval[0].rtpInAudio.packetsReceived;
      //   // const receivedBitrate = interval[0].rtcCandidatePairAudio.availableIncomingBitrate;
      //   rtpEndToEndLost = interval[0].rtpInAudio.packetsLost;
      //   const audioReceive = {};

      //   audioReceive.common = {
      //     common: {}
      //   };
      //   audioReceive.streams = [{
      //     audioqoem: {
      //       version: -1,
      //       averageNetMOS: -1,
      //       minNetMOS: -1,
      //       averageJitterMOS: rtpJitter, // TODO: actually average
      //       minJitterMOS: rtpJitter // TODO: actually get min
      //     },
      //     common: {
      //       codec: '',
      //       concealedFrames: -1,
      //       csi: [],
      //       maxConcealRunLength: -1,
      //       optimalBitrate: 64000,
      //       optimalFrameRate: -1,
      //       receivedBitrate: -1,
      //       receivedFrameRate: -1,
      //       renderedFrameRate: -1,
      //       requestedBitrate: -1,
      //       requestedFrameRate: -1,
      //       rtpEndToEndLost,
      //       rtpJitter,
      //       rtpPackets,
      //       ssci: -1
      //     }
      //   }];
      //   this.data.audioReceive = audioReceive;
      //   break;
      case 'shareSender':

        rtpPackets = 100000;
        transmittedFrameRate = 8;


        vsTransmit.common = {
          availableBitrate: -1, // TODO:
          common: {
            direction: 'sendrecv',
            isMain: false, // always true for share sender
            mariFecEnabled: false, // unavailable
            mariQosEnabled: false, // unavailable
            multistreamEnabled: false // unavailable
          },
          dtlsBitrate: -1,
          dtlsPackets: -1,
          fecBitrate: -1, // unavailable
          fecPackets: -1, // unavailable
          maxBitrate: -1,
          queueDelay: -1, // unavailable
          remoteJitter: -1,
          remoteLossRate: -1,
          remoteReceiveRate: -1,
          roundTripTime: -1,
          rtcpBitrate: -1,
          rtcpPackets: -1,
          rtpBitrate: -1,
          rtpPackets,
          stunBitrate: -1, // unavailable
          stunPackets: -1, // unavailable
          transportType: 'UDP' // TODO: parse the transport type from the SDP and save globally
        };
        vsTransmit.streams = [
          {
            common: {
              codec: 'H264', // TODO: parse the codec from the SDP and save globally
              duplicateSsci: -1, // unavailable
              requestedBitrate: -1,
              requestedFrames: -1,
              rtpPackets: -1,
              ssci: -1, // unavailable
              transmittedBitrate: -1,
              transmittedFrameRate
            },
            h264CodecProfile: 'BP', // TODO: parse the profile level from h264 in the SDP and save globally
            localConfigurationChanges: -1,
            remoteConfigurationChanges: -1,
            requestedFrameSize: -1,
            requestedKeyFrames: -1,
            transmittedFrameSize: -1,
            transmittedHeight: -1,
            transmittedKeyFrames: -1,
            transmittedWidth: -1
          }
        ];

        this.data.videoTransmit = videoTransmit;
        break;
      default:
        break;
    }
    this.data.videoReceive = [];
    this.data.audioTransmit = [];
    this.data.audioReceive = [];
    this.data.intervalMetadata = {
      memoryUsage: {
        cpuBitWidth: 0,
        mainProcessMaximumMemoryBytes: 0,
        osBitWidth: 0,
        processAverageMemoryUsage: 0,
        processMaximumMemoryBytes: 0,
        processMaximumMemoryUsage: 0,
        systemAverageMemoryUsage: 0,
        systemMaximumMemoryUsage: 0
      },
      peerReflexiveIP: 'NULL', // TODO: save after ice trickling completes and use as a global variable
      processAverageCPU: 0,
      processMaximumCPU: 0,
      systemAverageCPU: 0,
      systemMaximumCPU: 0
    };
  }

  isReady() {
    return this.ready;
  }

  getData() {
    this.intervalNumber += 1;

    return {...this.data, intervalNumber: this.intervalNumber};
  }
}

export default MQAProcessor;
