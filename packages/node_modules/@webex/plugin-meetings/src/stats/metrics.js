import {StatelessWebexPlugin} from '@webex/webex-core';

import {
  MEETINGS,
  STATS,
  EVENT_TRIGGERS
} from '../constants';
import Trigger from '../common/events/trigger-proxy';

/**
  * Metrics Payload Event
  * Emitted when a Metric Payload is available
  * @event metrics:payload
  * @instance
  * @type {Object}
  * @memberof MediaMetrics
  */

/**
 * @class MediaMetrics
 * @private
 */
export default class MediaMetrics extends StatelessWebexPlugin {
  namespace = MEETINGS;

  /**
   * @param {Object} attrs
   * @param {Object} options
   * @param {Object} specs
   * @memberof MediaMetrics
   * @constructor
   */
  constructor(attrs, options, specs) {
    super({}, options);
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof MediaMetrics
     */
    this.attrs = attrs;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof MediaMetrics
     */
    this.options = options;
    /**
     * @instance
     * @type {MeetingStats}
     * @readonly
     * @private
     * @memberof MediaMetrics
     */
    this.stats = null;
    /**
     * @instance
     * @type {Number}
     * @readonly
     * @private
     * @memberof MediaMetrics
     */
    this.interval = specs.interval;
    /**
     * @instance
     * @type {Boolean}
     * @readonly
     * @private
     * @memberof MediaMetrics
     */
    this.event = specs.event;
  }

  /**
   * @param {MeetingStats} stats
   * @returns {undefined}
   * @memberof MediaMetrics
   */
  setStats(stats) {
    this.stats = stats;
  }

  /**
   * checks to see if we can send data based on the config interval
   * emits an event if so
   * @param {String} id
   * @param {MeetingStats} sendRecv
   * @returns {undefined}
   * @private
   * @memberof MediaMetrics
   */
  checkData(id, sendRecv) {
    const metrics = sendRecv.getMetrics();

    if (metrics && metrics.get().length >= this.interval) {
      // we could technically parse this data down with the analyzer, but don't want to throw data away
      const interval = metrics.getSlice(this.interval);

      if (this.event) {
        Trigger.trigger(
          this,
          {
            file: 'stats/metrics',
            function: 'senderData'
          },
          EVENT_TRIGGERS.METRICS_MEDIA_PAYLOAD,
          {
            id,
            interval
          }
        );
      }
      metrics.clear();
    }
  }

  /**
   * sets up all the default senders and receivers getStats to collect data
   * @returns {Object}
   * @public
   * @memberof MediaMetrics
   */
  initialize() {
    const metrics = this.config.stats.autoSendMediaDiagnostics;
    const mqa = this.config.metrics.autoSendMQA;

    return {
      useConfig: true,
      senders: [
        {
          id: STATS.audioSenderId,
          correlate: STATS.audioCorrelate,
          metrics,
          mqa,
          onData: () => {
            this.checkData(STATS.audioSenderId, this.stats.getSender(STATS.audioSenderId));
          }
        },
        {
          id: STATS.videoSenderId,
          correlate: STATS.videoCorrelate,
          metrics,
          mqa,
          onData: () => {
            this.checkData(STATS.videoSenderId, this.stats.getSender(STATS.videoSenderId));
          }
        },
        {
          id: STATS.shareSenderId,
          correlate: STATS.shareCorrelate,
          metrics,
          mqa,
          onData: () => {
            this.checkData(STATS.shareSenderId, this.stats.getSender(STATS.shareSenderId));
          }
        }
      ],
      receivers: [
        {
          id: STATS.audioReceiverId,
          correlate: STATS.audioCorrelate,
          metrics,
          mqa,
          onData: () => {
            this.checkData(STATS.audioReceiverId, this.stats.getReceiver(STATS.audioReceiverId));
          }
        },
        {
          id: STATS.videoReceiverId,
          correlate: STATS.videoCorrelate,
          metrics,
          mqa,
          onData: () => {
            this.checkData(STATS.videoReceiverId, this.stats.getReceiver(STATS.videoReceiverId));
          }
        },
        {
          id: STATS.shareReceiverId,
          correlate: STATS.shareCorrelate,
          metrics,
          mqa,
          onData: () => {
            this.checkData(STATS.shareReceiverId, this.stats.getReceiver(STATS.shareReceiverId));
          }
        }
      ]
    };
  }
}
