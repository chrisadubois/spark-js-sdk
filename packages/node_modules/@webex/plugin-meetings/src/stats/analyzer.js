import {forEach, isFinite, forEachRight} from 'lodash';

import {EVENTS} from '../constants';
import EventsScope from '../common/events/events-scope';
import LoggerProxy from '../common/logs/logger-proxy';

export default class StatsAnalyzer extends EventsScope {
  constructor(optionalCreateOptions) {
    super();
    this.check = 0;
    this.storage = [];
    this.valid = null;
    this.analysis = {};
    this.interval = null;
    this.relevance = null;
    this.populate(optionalCreateOptions);
  }

  populate(options) {
    if (options) {
      this.interval = options.interval;
      this.relevance = options.properties;
    }
  }

  withInterval(interval) {
    this.interval = interval;

    return this;
  }

  withProperties(relevance) {
    this.properties = relevance;

    return this;
  }

  analyze(data) {
    if (this.check >= this.interval) {
      this.conduct();
      this.clear();
    }
    else {
      this.increment();
    }
    const graphable = this.pull(this.access(data));

    this.add(graphable);
    this.update(graphable);
  }

  update(graphable) {
    this.emit({file: 'stats/analyzer', function: 'analyze'}, EVENTS.ANALYSIS_GRAPH, graphable);
  }

  clear() {
    this.check = 0;
    // leaves the last one in to have something to compare to
    for (let i = 1; i < this.storage.length; i += 1) {
      this.remove();
    }
  }

  increment() {
    this.check += 1;
  }

  decrement() {
    this.check -= 1;
  }

  // TODO: right now we are basing it off of a config value, bytesSent/bytesReceived
  // which could be changed, or added to, and we need to make this less brittle
  // https://www.w3.org/TR/webrtc-stats/#dom-rtcsentrtpstreamstats
  // indicates that it will be the total value, so the following algorithm works for that
  // but does not work for other schemes saved on the SSRC
  // if the stat is done on a per interval basis we will need to cover it differently
  conduct() {
    if (!this.relevance || !this.interval) {
      LoggerProxy.logger.error('stats/analyzer->conduct#No relevance and/or interval properties to conduct analyses with/on, returning with noop');

      return;
    }
    this.conductAnalysis();
    LoggerProxy.logger.trace(`stats/analyzer->conduct#Stats analysis completed: ${JSON.stringify(this.analysis)}`);
  }

  // private
  conductAnalysis() {
    this.valid = true;
    this.relevance.forEach((key) => {
      let saved = null;

      forEachRight(this.storage, (relevant) => {
        const data = relevant[key];

        if (!data || !isFinite(data)) {
          this.valid = false;

          return;
        }
        if (!saved) {
          saved = data;
        }
        else if (!(data > saved)) {
          this.valid = false;
        }
        else {
          this.valid = true;
        }
      });

      if (!this.valid) {
        this.analysis[key] = false;
        this.emit({file: 'stats/analyzer', function: 'conductAnalysis'}, EVENTS.ANALYSIS_FAILURE, {property: key});
      }
      else {
        this.analysis[key] = true;
      }
    });
  }

  remove() {
    return this.storage.pop();
  }

  add(relevant) {
    this.storage.unshift(relevant);
  }

  pull(data) {
    if (!this.relevance) {
      LoggerProxy.logger.error('stats/analyzer->conduct#No properties to conduct analyses with/on, returning with noop');

      return null;
    }
    const relevant = {}; // will look like {bytesSent: x, packetsSent: x, ..., n}

    forEach(data, (report) => {
      this.relevance.forEach((property) => {
        const value = report[property];

        if (isFinite(value)) {
          relevant[property] = value;
        }
      });
    });

    return relevant;
  }

  // TODO: need to fix this chain of datas
  access(data) {
    return data.data.getData();
  }

  getValidity() {
    return this.valid;
  }

  getAnalysis() {
    return this.analysis;
  }
}
